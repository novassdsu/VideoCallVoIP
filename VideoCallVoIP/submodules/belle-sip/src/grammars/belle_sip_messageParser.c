/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g
 *     -                            On : 2015-02-22 01:12:23
 *     -                for the parser : belle_sip_messageParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/*
    belle-sip - SIP (RFC3261) library.
    Copyright (C) 2010  Belledonne Communications SARL

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused"
#ifndef __clang__
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-function"
#endif

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "belle_sip_messageParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pbelle_sip_messageParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pbelle_sip_messageParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pbelle_sip_messageParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pbelle_sip_messageParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_message scope set 
 */
static pbelle_sip_messageParser_message_SCOPE   pbelle_sip_messageParser_messagePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL messageFree(pbelle_sip_messageParser_message_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL messageFree(pbelle_sip_messageParser_message_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser message scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_messageTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_message_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_message_SCOPE
pbelle_sip_messageParser_messagePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_message_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_messageStack->size(ctx->pbelle_sip_messageParser_messageStack) > ctx->pbelle_sip_messageParser_messageStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_message_SCOPE)ctx->pbelle_sip_messageParser_messageStack->get(ctx->pbelle_sip_messageParser_messageStack, ctx->pbelle_sip_messageParser_messageStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_message_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_message_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_messageStack->push(ctx->pbelle_sip_messageParser_messageStack, newAttributes, (void (*)(void *))messageFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_messageStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_message_raw scope set 
 */
static pbelle_sip_messageParser_message_raw_SCOPE   pbelle_sip_messageParser_message_rawPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL message_rawFree(pbelle_sip_messageParser_message_raw_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL message_rawFree(pbelle_sip_messageParser_message_raw_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser message_raw scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_message_rawTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_message_raw_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_message_raw_SCOPE
pbelle_sip_messageParser_message_rawPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_message_raw_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_message_rawStack->size(ctx->pbelle_sip_messageParser_message_rawStack) > ctx->pbelle_sip_messageParser_message_rawStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_message_raw_SCOPE)ctx->pbelle_sip_messageParser_message_rawStack->get(ctx->pbelle_sip_messageParser_message_rawStack, ctx->pbelle_sip_messageParser_message_rawStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_message_raw_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_message_raw_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_message_rawStack->push(ctx->pbelle_sip_messageParser_message_rawStack, newAttributes, (void (*)(void *))message_rawFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_message_rawStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_common_request scope set 
 */
static pbelle_sip_messageParser_common_request_SCOPE   pbelle_sip_messageParser_common_requestPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL common_requestFree(pbelle_sip_messageParser_common_request_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL common_requestFree(pbelle_sip_messageParser_common_request_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser common_request scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_common_requestTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_common_request_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_common_request_SCOPE
pbelle_sip_messageParser_common_requestPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_common_request_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_common_requestStack->size(ctx->pbelle_sip_messageParser_common_requestStack) > ctx->pbelle_sip_messageParser_common_requestStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_common_request_SCOPE)ctx->pbelle_sip_messageParser_common_requestStack->get(ctx->pbelle_sip_messageParser_common_requestStack, ctx->pbelle_sip_messageParser_common_requestStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_common_request_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_common_request_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_common_requestStack->push(ctx->pbelle_sip_messageParser_common_requestStack, newAttributes, (void (*)(void *))common_requestFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_common_requestStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_request_line scope set 
 */
static pbelle_sip_messageParser_request_line_SCOPE   pbelle_sip_messageParser_request_linePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL request_lineFree(pbelle_sip_messageParser_request_line_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL request_lineFree(pbelle_sip_messageParser_request_line_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser request_line scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_request_lineTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_request_line_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_request_line_SCOPE
pbelle_sip_messageParser_request_linePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_request_line_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_request_lineStack->size(ctx->pbelle_sip_messageParser_request_lineStack) > ctx->pbelle_sip_messageParser_request_lineStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_request_line_SCOPE)ctx->pbelle_sip_messageParser_request_lineStack->get(ctx->pbelle_sip_messageParser_request_lineStack, ctx->pbelle_sip_messageParser_request_lineStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_request_line_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_request_line_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_request_lineStack->push(ctx->pbelle_sip_messageParser_request_lineStack, newAttributes, (void (*)(void *))request_lineFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_request_lineStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_status_line scope set 
 */
static pbelle_sip_messageParser_status_line_SCOPE   pbelle_sip_messageParser_status_linePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL status_lineFree(pbelle_sip_messageParser_status_line_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL status_lineFree(pbelle_sip_messageParser_status_line_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser status_line scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_status_lineTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_status_line_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_status_line_SCOPE
pbelle_sip_messageParser_status_linePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_status_line_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_status_lineStack->size(ctx->pbelle_sip_messageParser_status_lineStack) > ctx->pbelle_sip_messageParser_status_lineStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_status_line_SCOPE)ctx->pbelle_sip_messageParser_status_lineStack->get(ctx->pbelle_sip_messageParser_status_lineStack, ctx->pbelle_sip_messageParser_status_lineStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_status_line_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_status_line_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_status_lineStack->push(ctx->pbelle_sip_messageParser_status_lineStack, newAttributes, (void (*)(void *))status_lineFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_status_lineStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_http_request_line scope set 
 */
static pbelle_sip_messageParser_http_request_line_SCOPE   pbelle_sip_messageParser_http_request_linePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL http_request_lineFree(pbelle_sip_messageParser_http_request_line_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL http_request_lineFree(pbelle_sip_messageParser_http_request_line_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser http_request_line scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_http_request_lineTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_http_request_line_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_http_request_line_SCOPE
pbelle_sip_messageParser_http_request_linePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_http_request_line_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_http_request_lineStack->size(ctx->pbelle_sip_messageParser_http_request_lineStack) > ctx->pbelle_sip_messageParser_http_request_lineStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_http_request_line_SCOPE)ctx->pbelle_sip_messageParser_http_request_lineStack->get(ctx->pbelle_sip_messageParser_http_request_lineStack, ctx->pbelle_sip_messageParser_http_request_lineStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_http_request_line_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_http_request_line_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_http_request_lineStack->push(ctx->pbelle_sip_messageParser_http_request_lineStack, newAttributes, (void (*)(void *))http_request_lineFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_http_request_lineStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec scope set 
 */
static pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE   pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL generic_uri_for_from_to_contact_addr_specFree(pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL generic_uri_for_from_to_contact_addr_specFree(pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser generic_uri_for_from_to_contact_addr_spec scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE
pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack->size(ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack) > ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE)ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack->get(ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack, ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack->push(ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack, newAttributes, (void (*)(void *))generic_uri_for_from_to_contact_addr_specFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_generic_uri scope set 
 */
static pbelle_sip_messageParser_generic_uri_SCOPE   pbelle_sip_messageParser_generic_uriPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL generic_uriFree(pbelle_sip_messageParser_generic_uri_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL generic_uriFree(pbelle_sip_messageParser_generic_uri_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser generic_uri scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_generic_uriTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_generic_uri_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_generic_uri_SCOPE
pbelle_sip_messageParser_generic_uriPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_generic_uri_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_generic_uriStack->size(ctx->pbelle_sip_messageParser_generic_uriStack) > ctx->pbelle_sip_messageParser_generic_uriStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_generic_uri_SCOPE)ctx->pbelle_sip_messageParser_generic_uriStack->get(ctx->pbelle_sip_messageParser_generic_uriStack, ctx->pbelle_sip_messageParser_generic_uriStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_generic_uri_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_generic_uri_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_generic_uriStack->push(ctx->pbelle_sip_messageParser_generic_uriStack, newAttributes, (void (*)(void *))generic_uriFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_generic_uriStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_authority_userinfo scope set 
 */
static pbelle_sip_messageParser_authority_userinfo_SCOPE   pbelle_sip_messageParser_authority_userinfoPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL authority_userinfoFree(pbelle_sip_messageParser_authority_userinfo_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL authority_userinfoFree(pbelle_sip_messageParser_authority_userinfo_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser authority_userinfo scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_authority_userinfoTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_authority_userinfo_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_authority_userinfo_SCOPE
pbelle_sip_messageParser_authority_userinfoPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_authority_userinfo_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_authority_userinfoStack->size(ctx->pbelle_sip_messageParser_authority_userinfoStack) > ctx->pbelle_sip_messageParser_authority_userinfoStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_authority_userinfo_SCOPE)ctx->pbelle_sip_messageParser_authority_userinfoStack->get(ctx->pbelle_sip_messageParser_authority_userinfoStack, ctx->pbelle_sip_messageParser_authority_userinfoStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_authority_userinfo_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_authority_userinfo_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_authority_userinfoStack->push(ctx->pbelle_sip_messageParser_authority_userinfoStack, newAttributes, (void (*)(void *))authority_userinfoFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_authority_userinfoStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_authority_hostport scope set 
 */
static pbelle_sip_messageParser_authority_hostport_SCOPE   pbelle_sip_messageParser_authority_hostportPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL authority_hostportFree(pbelle_sip_messageParser_authority_hostport_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL authority_hostportFree(pbelle_sip_messageParser_authority_hostport_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser authority_hostport scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_authority_hostportTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_authority_hostport_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_authority_hostport_SCOPE
pbelle_sip_messageParser_authority_hostportPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_authority_hostport_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_authority_hostportStack->size(ctx->pbelle_sip_messageParser_authority_hostportStack) > ctx->pbelle_sip_messageParser_authority_hostportStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_authority_hostport_SCOPE)ctx->pbelle_sip_messageParser_authority_hostportStack->get(ctx->pbelle_sip_messageParser_authority_hostportStack, ctx->pbelle_sip_messageParser_authority_hostportStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_authority_hostport_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_authority_hostport_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_authority_hostportStack->push(ctx->pbelle_sip_messageParser_authority_hostportStack, newAttributes, (void (*)(void *))authority_hostportFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_authority_hostportStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_generic_param scope set 
 */
static pbelle_sip_messageParser_generic_param_SCOPE   pbelle_sip_messageParser_generic_paramPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL generic_paramFree(pbelle_sip_messageParser_generic_param_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL generic_paramFree(pbelle_sip_messageParser_generic_param_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser generic_param scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_generic_paramTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_generic_param_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_generic_param_SCOPE
pbelle_sip_messageParser_generic_paramPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_generic_param_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_generic_paramStack->size(ctx->pbelle_sip_messageParser_generic_paramStack) > ctx->pbelle_sip_messageParser_generic_paramStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_generic_param_SCOPE)ctx->pbelle_sip_messageParser_generic_paramStack->get(ctx->pbelle_sip_messageParser_generic_paramStack, ctx->pbelle_sip_messageParser_generic_paramStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_generic_param_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_generic_param_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_generic_paramStack->push(ctx->pbelle_sip_messageParser_generic_paramStack, newAttributes, (void (*)(void *))generic_paramFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_generic_paramStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_allow scope set 
 */
static pbelle_sip_messageParser_header_allow_SCOPE   pbelle_sip_messageParser_header_allowPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_allowFree(pbelle_sip_messageParser_header_allow_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_allowFree(pbelle_sip_messageParser_header_allow_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_allow scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_allowTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_allow_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_allow_SCOPE
pbelle_sip_messageParser_header_allowPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_allow_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_allowStack->size(ctx->pbelle_sip_messageParser_header_allowStack) > ctx->pbelle_sip_messageParser_header_allowStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_allow_SCOPE)ctx->pbelle_sip_messageParser_header_allowStack->get(ctx->pbelle_sip_messageParser_header_allowStack, ctx->pbelle_sip_messageParser_header_allowStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_allow_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_allow_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_allowStack->push(ctx->pbelle_sip_messageParser_header_allowStack, newAttributes, (void (*)(void *))header_allowFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_allowStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_authorization scope set 
 */
static pbelle_sip_messageParser_header_authorization_SCOPE   pbelle_sip_messageParser_header_authorizationPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_authorizationFree(pbelle_sip_messageParser_header_authorization_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_authorizationFree(pbelle_sip_messageParser_header_authorization_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_authorization scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_authorizationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_authorization_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_authorization_SCOPE
pbelle_sip_messageParser_header_authorizationPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_authorization_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_authorizationStack->size(ctx->pbelle_sip_messageParser_header_authorizationStack) > ctx->pbelle_sip_messageParser_header_authorizationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_authorization_SCOPE)ctx->pbelle_sip_messageParser_header_authorizationStack->get(ctx->pbelle_sip_messageParser_header_authorizationStack, ctx->pbelle_sip_messageParser_header_authorizationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_authorization_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_authorization_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_authorizationStack->push(ctx->pbelle_sip_messageParser_header_authorizationStack, newAttributes, (void (*)(void *))header_authorizationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_authorizationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_call_id scope set 
 */
static pbelle_sip_messageParser_header_call_id_SCOPE   pbelle_sip_messageParser_header_call_idPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_call_idFree(pbelle_sip_messageParser_header_call_id_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_call_idFree(pbelle_sip_messageParser_header_call_id_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_call_id scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_call_idTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_call_id_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_call_id_SCOPE
pbelle_sip_messageParser_header_call_idPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_call_id_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_call_idStack->size(ctx->pbelle_sip_messageParser_header_call_idStack) > ctx->pbelle_sip_messageParser_header_call_idStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_call_id_SCOPE)ctx->pbelle_sip_messageParser_header_call_idStack->get(ctx->pbelle_sip_messageParser_header_call_idStack, ctx->pbelle_sip_messageParser_header_call_idStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_call_id_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_call_id_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_call_idStack->push(ctx->pbelle_sip_messageParser_header_call_idStack, newAttributes, (void (*)(void *))header_call_idFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_call_idStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_contact scope set 
 */
static pbelle_sip_messageParser_header_contact_SCOPE   pbelle_sip_messageParser_header_contactPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_contactFree(pbelle_sip_messageParser_header_contact_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_contactFree(pbelle_sip_messageParser_header_contact_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_contact scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_contactTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_contact_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_contact_SCOPE
pbelle_sip_messageParser_header_contactPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_contact_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_contactStack->size(ctx->pbelle_sip_messageParser_header_contactStack) > ctx->pbelle_sip_messageParser_header_contactStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_contact_SCOPE)ctx->pbelle_sip_messageParser_header_contactStack->get(ctx->pbelle_sip_messageParser_header_contactStack, ctx->pbelle_sip_messageParser_header_contactStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_contact_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_contact_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_contactStack->push(ctx->pbelle_sip_messageParser_header_contactStack, newAttributes, (void (*)(void *))header_contactFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_contactStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_contact_param scope set 
 */
static pbelle_sip_messageParser_contact_param_SCOPE   pbelle_sip_messageParser_contact_paramPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL contact_paramFree(pbelle_sip_messageParser_contact_param_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL contact_paramFree(pbelle_sip_messageParser_contact_param_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser contact_param scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_contact_paramTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_contact_param_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_contact_param_SCOPE
pbelle_sip_messageParser_contact_paramPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_contact_param_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_contact_paramStack->size(ctx->pbelle_sip_messageParser_contact_paramStack) > ctx->pbelle_sip_messageParser_contact_paramStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_contact_param_SCOPE)ctx->pbelle_sip_messageParser_contact_paramStack->get(ctx->pbelle_sip_messageParser_contact_paramStack, ctx->pbelle_sip_messageParser_contact_paramStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_contact_param_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_contact_param_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_contact_paramStack->push(ctx->pbelle_sip_messageParser_contact_paramStack, newAttributes, (void (*)(void *))contact_paramFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_contact_paramStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_content_length scope set 
 */
static pbelle_sip_messageParser_header_content_length_SCOPE   pbelle_sip_messageParser_header_content_lengthPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_content_lengthFree(pbelle_sip_messageParser_header_content_length_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_content_lengthFree(pbelle_sip_messageParser_header_content_length_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_content_length scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_content_lengthTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_content_length_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_content_length_SCOPE
pbelle_sip_messageParser_header_content_lengthPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_content_length_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_content_lengthStack->size(ctx->pbelle_sip_messageParser_header_content_lengthStack) > ctx->pbelle_sip_messageParser_header_content_lengthStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_content_length_SCOPE)ctx->pbelle_sip_messageParser_header_content_lengthStack->get(ctx->pbelle_sip_messageParser_header_content_lengthStack, ctx->pbelle_sip_messageParser_header_content_lengthStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_content_length_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_content_length_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_content_lengthStack->push(ctx->pbelle_sip_messageParser_header_content_lengthStack, newAttributes, (void (*)(void *))header_content_lengthFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_content_lengthStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_content_type scope set 
 */
static pbelle_sip_messageParser_header_content_type_SCOPE   pbelle_sip_messageParser_header_content_typePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_content_typeFree(pbelle_sip_messageParser_header_content_type_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_content_typeFree(pbelle_sip_messageParser_header_content_type_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_content_type scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_content_typeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_content_type_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_content_type_SCOPE
pbelle_sip_messageParser_header_content_typePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_content_type_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_content_typeStack->size(ctx->pbelle_sip_messageParser_header_content_typeStack) > ctx->pbelle_sip_messageParser_header_content_typeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_content_type_SCOPE)ctx->pbelle_sip_messageParser_header_content_typeStack->get(ctx->pbelle_sip_messageParser_header_content_typeStack, ctx->pbelle_sip_messageParser_header_content_typeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_content_type_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_content_type_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_content_typeStack->push(ctx->pbelle_sip_messageParser_header_content_typeStack, newAttributes, (void (*)(void *))header_content_typeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_content_typeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_cseq scope set 
 */
static pbelle_sip_messageParser_header_cseq_SCOPE   pbelle_sip_messageParser_header_cseqPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_cseqFree(pbelle_sip_messageParser_header_cseq_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_cseqFree(pbelle_sip_messageParser_header_cseq_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_cseq scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_cseqTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_cseq_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_cseq_SCOPE
pbelle_sip_messageParser_header_cseqPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_cseq_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_cseqStack->size(ctx->pbelle_sip_messageParser_header_cseqStack) > ctx->pbelle_sip_messageParser_header_cseqStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_cseq_SCOPE)ctx->pbelle_sip_messageParser_header_cseqStack->get(ctx->pbelle_sip_messageParser_header_cseqStack, ctx->pbelle_sip_messageParser_header_cseqStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_cseq_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_cseq_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_cseqStack->push(ctx->pbelle_sip_messageParser_header_cseqStack, newAttributes, (void (*)(void *))header_cseqFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_cseqStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_date scope set 
 */
static pbelle_sip_messageParser_header_date_SCOPE   pbelle_sip_messageParser_header_datePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_dateFree(pbelle_sip_messageParser_header_date_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_dateFree(pbelle_sip_messageParser_header_date_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_date scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_dateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_date_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_date_SCOPE
pbelle_sip_messageParser_header_datePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_date_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_dateStack->size(ctx->pbelle_sip_messageParser_header_dateStack) > ctx->pbelle_sip_messageParser_header_dateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_date_SCOPE)ctx->pbelle_sip_messageParser_header_dateStack->get(ctx->pbelle_sip_messageParser_header_dateStack, ctx->pbelle_sip_messageParser_header_dateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_date_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_date_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_dateStack->push(ctx->pbelle_sip_messageParser_header_dateStack, newAttributes, (void (*)(void *))header_dateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_dateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_expires scope set 
 */
static pbelle_sip_messageParser_header_expires_SCOPE   pbelle_sip_messageParser_header_expiresPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_expiresFree(pbelle_sip_messageParser_header_expires_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_expiresFree(pbelle_sip_messageParser_header_expires_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_expires scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_expiresTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_expires_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_expires_SCOPE
pbelle_sip_messageParser_header_expiresPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_expires_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_expiresStack->size(ctx->pbelle_sip_messageParser_header_expiresStack) > ctx->pbelle_sip_messageParser_header_expiresStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_expires_SCOPE)ctx->pbelle_sip_messageParser_header_expiresStack->get(ctx->pbelle_sip_messageParser_header_expiresStack, ctx->pbelle_sip_messageParser_header_expiresStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_expires_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_expires_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_expiresStack->push(ctx->pbelle_sip_messageParser_header_expiresStack, newAttributes, (void (*)(void *))header_expiresFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_expiresStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_from scope set 
 */
static pbelle_sip_messageParser_header_from_SCOPE   pbelle_sip_messageParser_header_fromPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_fromFree(pbelle_sip_messageParser_header_from_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_fromFree(pbelle_sip_messageParser_header_from_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_from scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_fromTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_from_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_from_SCOPE
pbelle_sip_messageParser_header_fromPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_from_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_fromStack->size(ctx->pbelle_sip_messageParser_header_fromStack) > ctx->pbelle_sip_messageParser_header_fromStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_from_SCOPE)ctx->pbelle_sip_messageParser_header_fromStack->get(ctx->pbelle_sip_messageParser_header_fromStack, ctx->pbelle_sip_messageParser_header_fromStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_from_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_from_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_fromStack->push(ctx->pbelle_sip_messageParser_header_fromStack, newAttributes, (void (*)(void *))header_fromFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_fromStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_max_forwards scope set 
 */
static pbelle_sip_messageParser_header_max_forwards_SCOPE   pbelle_sip_messageParser_header_max_forwardsPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_max_forwardsFree(pbelle_sip_messageParser_header_max_forwards_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_max_forwardsFree(pbelle_sip_messageParser_header_max_forwards_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_max_forwards scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_max_forwardsTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_max_forwards_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_max_forwards_SCOPE
pbelle_sip_messageParser_header_max_forwardsPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_max_forwards_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_max_forwardsStack->size(ctx->pbelle_sip_messageParser_header_max_forwardsStack) > ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_max_forwards_SCOPE)ctx->pbelle_sip_messageParser_header_max_forwardsStack->get(ctx->pbelle_sip_messageParser_header_max_forwardsStack, ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_max_forwards_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_max_forwards_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_max_forwardsStack->push(ctx->pbelle_sip_messageParser_header_max_forwardsStack, newAttributes, (void (*)(void *))header_max_forwardsFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_proxy_authenticate scope set 
 */
static pbelle_sip_messageParser_header_proxy_authenticate_SCOPE   pbelle_sip_messageParser_header_proxy_authenticatePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_proxy_authenticateFree(pbelle_sip_messageParser_header_proxy_authenticate_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_proxy_authenticateFree(pbelle_sip_messageParser_header_proxy_authenticate_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_proxy_authenticate scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_proxy_authenticateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_proxy_authenticate_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_proxy_authenticate_SCOPE
pbelle_sip_messageParser_header_proxy_authenticatePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_proxy_authenticate_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->size(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack) > ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authenticate_SCOPE)ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->get(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack, ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authenticate_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_proxy_authenticate_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->push(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack, newAttributes, (void (*)(void *))header_proxy_authenticateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_qop_opts scope set 
 */
static pbelle_sip_messageParser_qop_opts_SCOPE   pbelle_sip_messageParser_qop_optsPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL qop_optsFree(pbelle_sip_messageParser_qop_opts_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL qop_optsFree(pbelle_sip_messageParser_qop_opts_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser qop_opts scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_qop_optsTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_qop_opts_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_qop_opts_SCOPE
pbelle_sip_messageParser_qop_optsPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_qop_opts_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_qop_optsStack->size(ctx->pbelle_sip_messageParser_qop_optsStack) > ctx->pbelle_sip_messageParser_qop_optsStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_qop_opts_SCOPE)ctx->pbelle_sip_messageParser_qop_optsStack->get(ctx->pbelle_sip_messageParser_qop_optsStack, ctx->pbelle_sip_messageParser_qop_optsStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_qop_opts_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_qop_opts_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_qop_optsStack->push(ctx->pbelle_sip_messageParser_qop_optsStack, newAttributes, (void (*)(void *))qop_optsFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_qop_optsStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_proxy_authorization scope set 
 */
static pbelle_sip_messageParser_header_proxy_authorization_SCOPE   pbelle_sip_messageParser_header_proxy_authorizationPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_proxy_authorizationFree(pbelle_sip_messageParser_header_proxy_authorization_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_proxy_authorizationFree(pbelle_sip_messageParser_header_proxy_authorization_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_proxy_authorization scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_proxy_authorizationTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_proxy_authorization_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_proxy_authorization_SCOPE
pbelle_sip_messageParser_header_proxy_authorizationPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_proxy_authorization_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->size(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack) > ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authorization_SCOPE)ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->get(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack, ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_proxy_authorization_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_proxy_authorization_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->push(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack, newAttributes, (void (*)(void *))header_proxy_authorizationFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_service_route scope set 
 */
static pbelle_sip_messageParser_header_service_route_SCOPE   pbelle_sip_messageParser_header_service_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_service_routeFree(pbelle_sip_messageParser_header_service_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_service_routeFree(pbelle_sip_messageParser_header_service_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_service_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_service_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_service_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_service_route_SCOPE
pbelle_sip_messageParser_header_service_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_service_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_service_routeStack->size(ctx->pbelle_sip_messageParser_header_service_routeStack) > ctx->pbelle_sip_messageParser_header_service_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_service_route_SCOPE)ctx->pbelle_sip_messageParser_header_service_routeStack->get(ctx->pbelle_sip_messageParser_header_service_routeStack, ctx->pbelle_sip_messageParser_header_service_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_service_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_service_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_service_routeStack->push(ctx->pbelle_sip_messageParser_header_service_routeStack, newAttributes, (void (*)(void *))header_service_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_service_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_srv_route scope set 
 */
static pbelle_sip_messageParser_srv_route_SCOPE   pbelle_sip_messageParser_srv_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL srv_routeFree(pbelle_sip_messageParser_srv_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL srv_routeFree(pbelle_sip_messageParser_srv_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser srv_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_srv_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_srv_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_srv_route_SCOPE
pbelle_sip_messageParser_srv_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_srv_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_srv_routeStack->size(ctx->pbelle_sip_messageParser_srv_routeStack) > ctx->pbelle_sip_messageParser_srv_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_srv_route_SCOPE)ctx->pbelle_sip_messageParser_srv_routeStack->get(ctx->pbelle_sip_messageParser_srv_routeStack, ctx->pbelle_sip_messageParser_srv_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_srv_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_srv_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_srv_routeStack->push(ctx->pbelle_sip_messageParser_srv_routeStack, newAttributes, (void (*)(void *))srv_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_srv_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_record_route scope set 
 */
static pbelle_sip_messageParser_header_record_route_SCOPE   pbelle_sip_messageParser_header_record_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_record_routeFree(pbelle_sip_messageParser_header_record_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_record_routeFree(pbelle_sip_messageParser_header_record_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_record_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_record_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_record_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_record_route_SCOPE
pbelle_sip_messageParser_header_record_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_record_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_record_routeStack->size(ctx->pbelle_sip_messageParser_header_record_routeStack) > ctx->pbelle_sip_messageParser_header_record_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_record_route_SCOPE)ctx->pbelle_sip_messageParser_header_record_routeStack->get(ctx->pbelle_sip_messageParser_header_record_routeStack, ctx->pbelle_sip_messageParser_header_record_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_record_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_record_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_record_routeStack->push(ctx->pbelle_sip_messageParser_header_record_routeStack, newAttributes, (void (*)(void *))header_record_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_record_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_rec_route scope set 
 */
static pbelle_sip_messageParser_rec_route_SCOPE   pbelle_sip_messageParser_rec_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL rec_routeFree(pbelle_sip_messageParser_rec_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL rec_routeFree(pbelle_sip_messageParser_rec_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser rec_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_rec_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_rec_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_rec_route_SCOPE
pbelle_sip_messageParser_rec_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_rec_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_rec_routeStack->size(ctx->pbelle_sip_messageParser_rec_routeStack) > ctx->pbelle_sip_messageParser_rec_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_rec_route_SCOPE)ctx->pbelle_sip_messageParser_rec_routeStack->get(ctx->pbelle_sip_messageParser_rec_routeStack, ctx->pbelle_sip_messageParser_rec_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_rec_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_rec_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_rec_routeStack->push(ctx->pbelle_sip_messageParser_rec_routeStack, newAttributes, (void (*)(void *))rec_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_rec_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_route scope set 
 */
static pbelle_sip_messageParser_header_route_SCOPE   pbelle_sip_messageParser_header_routePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_routeFree(pbelle_sip_messageParser_header_route_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_routeFree(pbelle_sip_messageParser_header_route_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_route scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_routeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_route_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_route_SCOPE
pbelle_sip_messageParser_header_routePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_route_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_routeStack->size(ctx->pbelle_sip_messageParser_header_routeStack) > ctx->pbelle_sip_messageParser_header_routeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_route_SCOPE)ctx->pbelle_sip_messageParser_header_routeStack->get(ctx->pbelle_sip_messageParser_header_routeStack, ctx->pbelle_sip_messageParser_header_routeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_route_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_route_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_routeStack->push(ctx->pbelle_sip_messageParser_header_routeStack, newAttributes, (void (*)(void *))header_routeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_routeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_route_param scope set 
 */
static pbelle_sip_messageParser_route_param_SCOPE   pbelle_sip_messageParser_route_paramPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL route_paramFree(pbelle_sip_messageParser_route_param_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL route_paramFree(pbelle_sip_messageParser_route_param_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser route_param scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_route_paramTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_route_param_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_route_param_SCOPE
pbelle_sip_messageParser_route_paramPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_route_param_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_route_paramStack->size(ctx->pbelle_sip_messageParser_route_paramStack) > ctx->pbelle_sip_messageParser_route_paramStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_route_param_SCOPE)ctx->pbelle_sip_messageParser_route_paramStack->get(ctx->pbelle_sip_messageParser_route_paramStack, ctx->pbelle_sip_messageParser_route_paramStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_route_param_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_route_param_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_route_paramStack->push(ctx->pbelle_sip_messageParser_route_paramStack, newAttributes, (void (*)(void *))route_paramFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_route_paramStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_to scope set 
 */
static pbelle_sip_messageParser_header_to_SCOPE   pbelle_sip_messageParser_header_toPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_toFree(pbelle_sip_messageParser_header_to_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_toFree(pbelle_sip_messageParser_header_to_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_to scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_toTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_to_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_to_SCOPE
pbelle_sip_messageParser_header_toPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_to_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_toStack->size(ctx->pbelle_sip_messageParser_header_toStack) > ctx->pbelle_sip_messageParser_header_toStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_to_SCOPE)ctx->pbelle_sip_messageParser_header_toStack->get(ctx->pbelle_sip_messageParser_header_toStack, ctx->pbelle_sip_messageParser_header_toStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_to_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_to_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_toStack->push(ctx->pbelle_sip_messageParser_header_toStack, newAttributes, (void (*)(void *))header_toFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_toStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_user_agent scope set 
 */
static pbelle_sip_messageParser_header_user_agent_SCOPE   pbelle_sip_messageParser_header_user_agentPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_user_agentFree(pbelle_sip_messageParser_header_user_agent_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_user_agentFree(pbelle_sip_messageParser_header_user_agent_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_user_agent scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_user_agentTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_user_agent_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_user_agent_SCOPE
pbelle_sip_messageParser_header_user_agentPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_user_agent_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_user_agentStack->size(ctx->pbelle_sip_messageParser_header_user_agentStack) > ctx->pbelle_sip_messageParser_header_user_agentStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_user_agent_SCOPE)ctx->pbelle_sip_messageParser_header_user_agentStack->get(ctx->pbelle_sip_messageParser_header_user_agentStack, ctx->pbelle_sip_messageParser_header_user_agentStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_user_agent_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_user_agent_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_user_agentStack->push(ctx->pbelle_sip_messageParser_header_user_agentStack, newAttributes, (void (*)(void *))header_user_agentFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_user_agentStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_via scope set 
 */
static pbelle_sip_messageParser_header_via_SCOPE   pbelle_sip_messageParser_header_viaPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_viaFree(pbelle_sip_messageParser_header_via_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_viaFree(pbelle_sip_messageParser_header_via_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_via scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_viaTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_via_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_via_SCOPE
pbelle_sip_messageParser_header_viaPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_via_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_viaStack->size(ctx->pbelle_sip_messageParser_header_viaStack) > ctx->pbelle_sip_messageParser_header_viaStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_via_SCOPE)ctx->pbelle_sip_messageParser_header_viaStack->get(ctx->pbelle_sip_messageParser_header_viaStack, ctx->pbelle_sip_messageParser_header_viaStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_via_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_via_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_viaStack->push(ctx->pbelle_sip_messageParser_header_viaStack, newAttributes, (void (*)(void *))header_viaFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_viaStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_via_parm scope set 
 */
static pbelle_sip_messageParser_via_parm_SCOPE   pbelle_sip_messageParser_via_parmPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL via_parmFree(pbelle_sip_messageParser_via_parm_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL via_parmFree(pbelle_sip_messageParser_via_parm_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser via_parm scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_via_parmTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_via_parm_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_via_parm_SCOPE
pbelle_sip_messageParser_via_parmPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_via_parm_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_via_parmStack->size(ctx->pbelle_sip_messageParser_via_parmStack) > ctx->pbelle_sip_messageParser_via_parmStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_via_parm_SCOPE)ctx->pbelle_sip_messageParser_via_parmStack->get(ctx->pbelle_sip_messageParser_via_parmStack, ctx->pbelle_sip_messageParser_via_parmStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_via_parm_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_via_parm_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_via_parmStack->push(ctx->pbelle_sip_messageParser_via_parmStack, newAttributes, (void (*)(void *))via_parmFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_via_parmStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_www_authenticate scope set 
 */
static pbelle_sip_messageParser_header_www_authenticate_SCOPE   pbelle_sip_messageParser_header_www_authenticatePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_www_authenticateFree(pbelle_sip_messageParser_header_www_authenticate_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_www_authenticateFree(pbelle_sip_messageParser_header_www_authenticate_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_www_authenticate scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_www_authenticateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_www_authenticate_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_www_authenticate_SCOPE
pbelle_sip_messageParser_header_www_authenticatePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_www_authenticate_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_www_authenticateStack->size(ctx->pbelle_sip_messageParser_header_www_authenticateStack) > ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_www_authenticate_SCOPE)ctx->pbelle_sip_messageParser_header_www_authenticateStack->get(ctx->pbelle_sip_messageParser_header_www_authenticateStack, ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_www_authenticate_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_www_authenticate_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_www_authenticateStack->push(ctx->pbelle_sip_messageParser_header_www_authenticateStack, newAttributes, (void (*)(void *))header_www_authenticateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_subscription_state scope set 
 */
static pbelle_sip_messageParser_header_subscription_state_SCOPE   pbelle_sip_messageParser_header_subscription_statePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_subscription_stateFree(pbelle_sip_messageParser_header_subscription_state_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_subscription_stateFree(pbelle_sip_messageParser_header_subscription_state_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_subscription_state scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_subscription_stateTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_subscription_state_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_subscription_state_SCOPE
pbelle_sip_messageParser_header_subscription_statePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_subscription_state_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_subscription_stateStack->size(ctx->pbelle_sip_messageParser_header_subscription_stateStack) > ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_subscription_state_SCOPE)ctx->pbelle_sip_messageParser_header_subscription_stateStack->get(ctx->pbelle_sip_messageParser_header_subscription_stateStack, ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_subscription_state_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_subscription_state_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_subscription_stateStack->push(ctx->pbelle_sip_messageParser_header_subscription_stateStack, newAttributes, (void (*)(void *))header_subscription_stateFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_event scope set 
 */
static pbelle_sip_messageParser_header_event_SCOPE   pbelle_sip_messageParser_header_eventPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_eventFree(pbelle_sip_messageParser_header_event_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_eventFree(pbelle_sip_messageParser_header_event_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_event scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_eventTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_event_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_event_SCOPE
pbelle_sip_messageParser_header_eventPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_event_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_eventStack->size(ctx->pbelle_sip_messageParser_header_eventStack) > ctx->pbelle_sip_messageParser_header_eventStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_event_SCOPE)ctx->pbelle_sip_messageParser_header_eventStack->get(ctx->pbelle_sip_messageParser_header_eventStack, ctx->pbelle_sip_messageParser_header_eventStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_event_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_event_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_eventStack->push(ctx->pbelle_sip_messageParser_header_eventStack, newAttributes, (void (*)(void *))header_eventFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_eventStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_replaces scope set 
 */
static pbelle_sip_messageParser_header_replaces_SCOPE   pbelle_sip_messageParser_header_replacesPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_replacesFree(pbelle_sip_messageParser_header_replaces_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_replacesFree(pbelle_sip_messageParser_header_replaces_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_replaces scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_replacesTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_replaces_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_replaces_SCOPE
pbelle_sip_messageParser_header_replacesPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_replaces_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_replacesStack->size(ctx->pbelle_sip_messageParser_header_replacesStack) > ctx->pbelle_sip_messageParser_header_replacesStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_replaces_SCOPE)ctx->pbelle_sip_messageParser_header_replacesStack->get(ctx->pbelle_sip_messageParser_header_replacesStack, ctx->pbelle_sip_messageParser_header_replacesStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_replaces_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_replaces_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_replacesStack->push(ctx->pbelle_sip_messageParser_header_replacesStack, newAttributes, (void (*)(void *))header_replacesFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_replacesStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_privacy scope set 
 */
static pbelle_sip_messageParser_header_privacy_SCOPE   pbelle_sip_messageParser_header_privacyPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_privacyFree(pbelle_sip_messageParser_header_privacy_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_privacyFree(pbelle_sip_messageParser_header_privacy_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_privacy scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_privacyTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_privacy_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_privacy_SCOPE
pbelle_sip_messageParser_header_privacyPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_privacy_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_privacyStack->size(ctx->pbelle_sip_messageParser_header_privacyStack) > ctx->pbelle_sip_messageParser_header_privacyStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_privacy_SCOPE)ctx->pbelle_sip_messageParser_header_privacyStack->get(ctx->pbelle_sip_messageParser_header_privacyStack, ctx->pbelle_sip_messageParser_header_privacyStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_privacy_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_privacy_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_privacyStack->push(ctx->pbelle_sip_messageParser_header_privacyStack, newAttributes, (void (*)(void *))header_privacyFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_privacyStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_header_extension_base scope set 
 */
static pbelle_sip_messageParser_header_extension_base_SCOPE   pbelle_sip_messageParser_header_extension_basePush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL header_extension_baseFree(pbelle_sip_messageParser_header_extension_base_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL header_extension_baseFree(pbelle_sip_messageParser_header_extension_base_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser header_extension_base scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_header_extension_baseTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_header_extension_base_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_header_extension_base_SCOPE
pbelle_sip_messageParser_header_extension_basePush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_header_extension_base_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_header_extension_baseStack->size(ctx->pbelle_sip_messageParser_header_extension_baseStack) > ctx->pbelle_sip_messageParser_header_extension_baseStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_header_extension_base_SCOPE)ctx->pbelle_sip_messageParser_header_extension_baseStack->get(ctx->pbelle_sip_messageParser_header_extension_baseStack, ctx->pbelle_sip_messageParser_header_extension_baseStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_header_extension_base_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_header_extension_base_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_header_extension_baseStack->push(ctx->pbelle_sip_messageParser_header_extension_baseStack, newAttributes, (void (*)(void *))header_extension_baseFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_header_extension_baseStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_paramless_uri scope set 
 */
static pbelle_sip_messageParser_paramless_uri_SCOPE   pbelle_sip_messageParser_paramless_uriPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL paramless_uriFree(pbelle_sip_messageParser_paramless_uri_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL paramless_uriFree(pbelle_sip_messageParser_paramless_uri_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser paramless_uri scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_paramless_uriTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_paramless_uri_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_paramless_uri_SCOPE
pbelle_sip_messageParser_paramless_uriPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_paramless_uri_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_paramless_uriStack->size(ctx->pbelle_sip_messageParser_paramless_uriStack) > ctx->pbelle_sip_messageParser_paramless_uriStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_paramless_uri_SCOPE)ctx->pbelle_sip_messageParser_paramless_uriStack->get(ctx->pbelle_sip_messageParser_paramless_uriStack, ctx->pbelle_sip_messageParser_paramless_uriStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_paramless_uri_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_paramless_uri_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_paramless_uriStack->push(ctx->pbelle_sip_messageParser_paramless_uriStack, newAttributes, (void (*)(void *))paramless_uriFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_paramless_uriStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_uri scope set 
 */
static pbelle_sip_messageParser_uri_SCOPE   pbelle_sip_messageParser_uriPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL uriFree(pbelle_sip_messageParser_uri_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL uriFree(pbelle_sip_messageParser_uri_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser uri scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_uriTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_uri_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_uri_SCOPE
pbelle_sip_messageParser_uriPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_uri_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_uriStack->size(ctx->pbelle_sip_messageParser_uriStack) > ctx->pbelle_sip_messageParser_uriStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_uri_SCOPE)ctx->pbelle_sip_messageParser_uriStack->get(ctx->pbelle_sip_messageParser_uriStack, ctx->pbelle_sip_messageParser_uriStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_uri_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_uri_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_uriStack->push(ctx->pbelle_sip_messageParser_uriStack, newAttributes, (void (*)(void *))uriFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_uriStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_userinfo scope set 
 */
static pbelle_sip_messageParser_userinfo_SCOPE   pbelle_sip_messageParser_userinfoPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL userinfoFree(pbelle_sip_messageParser_userinfo_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL userinfoFree(pbelle_sip_messageParser_userinfo_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser userinfo scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_userinfoTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_userinfo_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_userinfo_SCOPE
pbelle_sip_messageParser_userinfoPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_userinfo_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_userinfoStack->size(ctx->pbelle_sip_messageParser_userinfoStack) > ctx->pbelle_sip_messageParser_userinfoStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_userinfo_SCOPE)ctx->pbelle_sip_messageParser_userinfoStack->get(ctx->pbelle_sip_messageParser_userinfoStack, ctx->pbelle_sip_messageParser_userinfoStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_userinfo_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_userinfo_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_userinfoStack->push(ctx->pbelle_sip_messageParser_userinfoStack, newAttributes, (void (*)(void *))userinfoFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_userinfoStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_hostport scope set 
 */
static pbelle_sip_messageParser_hostport_SCOPE   pbelle_sip_messageParser_hostportPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL hostportFree(pbelle_sip_messageParser_hostport_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL hostportFree(pbelle_sip_messageParser_hostport_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser hostport scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_hostportTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_hostport_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_hostport_SCOPE
pbelle_sip_messageParser_hostportPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_hostport_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_hostportStack->size(ctx->pbelle_sip_messageParser_hostportStack) > ctx->pbelle_sip_messageParser_hostportStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_hostport_SCOPE)ctx->pbelle_sip_messageParser_hostportStack->get(ctx->pbelle_sip_messageParser_hostportStack, ctx->pbelle_sip_messageParser_hostportStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_hostport_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_hostport_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_hostportStack->push(ctx->pbelle_sip_messageParser_hostportStack, newAttributes, (void (*)(void *))hostportFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_hostportStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_uri_parameters scope set 
 */
static pbelle_sip_messageParser_uri_parameters_SCOPE   pbelle_sip_messageParser_uri_parametersPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL uri_parametersFree(pbelle_sip_messageParser_uri_parameters_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL uri_parametersFree(pbelle_sip_messageParser_uri_parameters_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser uri_parameters scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_uri_parametersTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_uri_parameters_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_uri_parameters_SCOPE
pbelle_sip_messageParser_uri_parametersPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_uri_parameters_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_uri_parametersStack->size(ctx->pbelle_sip_messageParser_uri_parametersStack) > ctx->pbelle_sip_messageParser_uri_parametersStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_uri_parameters_SCOPE)ctx->pbelle_sip_messageParser_uri_parametersStack->get(ctx->pbelle_sip_messageParser_uri_parametersStack, ctx->pbelle_sip_messageParser_uri_parametersStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_uri_parameters_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_uri_parameters_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_uri_parametersStack->push(ctx->pbelle_sip_messageParser_uri_parametersStack, newAttributes, (void (*)(void *))uri_parametersFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_uri_parametersStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_headers scope set 
 */
static pbelle_sip_messageParser_headers_SCOPE   pbelle_sip_messageParser_headersPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL headersFree(pbelle_sip_messageParser_headers_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL headersFree(pbelle_sip_messageParser_headers_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser headers scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_headersTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_headers_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_headers_SCOPE
pbelle_sip_messageParser_headersPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_headers_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_headersStack->size(ctx->pbelle_sip_messageParser_headersStack) > ctx->pbelle_sip_messageParser_headersStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_headers_SCOPE)ctx->pbelle_sip_messageParser_headersStack->get(ctx->pbelle_sip_messageParser_headersStack, ctx->pbelle_sip_messageParser_headersStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_headers_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_headers_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_headersStack->push(ctx->pbelle_sip_messageParser_headersStack, newAttributes, (void (*)(void *))headersFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_headersStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_uri_header scope set 
 */
static pbelle_sip_messageParser_uri_header_SCOPE   pbelle_sip_messageParser_uri_headerPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL uri_headerFree(pbelle_sip_messageParser_uri_header_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL uri_headerFree(pbelle_sip_messageParser_uri_header_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser uri_header scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_uri_headerTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_uri_header_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_uri_header_SCOPE
pbelle_sip_messageParser_uri_headerPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_uri_header_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_uri_headerStack->size(ctx->pbelle_sip_messageParser_uri_headerStack) > ctx->pbelle_sip_messageParser_uri_headerStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_uri_header_SCOPE)ctx->pbelle_sip_messageParser_uri_headerStack->get(ctx->pbelle_sip_messageParser_uri_headerStack, ctx->pbelle_sip_messageParser_uri_headerStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_uri_header_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_uri_header_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_uri_headerStack->push(ctx->pbelle_sip_messageParser_uri_headerStack, newAttributes, (void (*)(void *))uri_headerFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_uri_headerStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sip_messageParser_host scope set 
 */
static pbelle_sip_messageParser_host_SCOPE   pbelle_sip_messageParser_hostPush(pbelle_sip_messageParser ctx);
static void ANTLR3_CDECL hostFree(pbelle_sip_messageParser_host_SCOPE scope);
/* ----------------------------------------------------------------------------- */

/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL hostFree(pbelle_sip_messageParser_host_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sip_messageParser host scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   ctx->pbelle_sip_messageParser_hostTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sip_messageParser_host_SCOPE ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 * 
 */ 
static pbelle_sip_messageParser_host_SCOPE
pbelle_sip_messageParser_hostPush(pbelle_sip_messageParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sip_messageParser_host_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sip_messageParser_hostStack->size(ctx->pbelle_sip_messageParser_hostStack) > ctx->pbelle_sip_messageParser_hostStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sip_messageParser_host_SCOPE)ctx->pbelle_sip_messageParser_hostStack->get(ctx->pbelle_sip_messageParser_hostStack, ctx->pbelle_sip_messageParser_hostStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sip_messageParser_host_SCOPE) ANTLR3_MALLOC(sizeof(belle_sip_messageParser_host_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sip_messageParser_hostStack->push(ctx->pbelle_sip_messageParser_hostStack, newAttributes, (void (*)(void *))hostFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sip_messageParser_hostStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   belle_sip_messageParserTokenNames[37+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "CRLF",
        (pANTLR3_UINT8) "SP",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "AT",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "DOLLARD",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "SEMI",
        (pANTLR3_UINT8) "QMARK",
        (pANTLR3_UINT8) "DASH",
        (pANTLR3_UINT8) "DQUOTE",
        (pANTLR3_UINT8) "BSLASH",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "OCTET",
        (pANTLR3_UINT8) "LSBRAQUET",
        (pANTLR3_UINT8) "RSBRAQUET",
        (pANTLR3_UINT8) "PERCENT",
        (pANTLR3_UINT8) "BQUOTE",
        (pANTLR3_UINT8) "HEX_CHAR",
        (pANTLR3_UINT8) "COMMON_CHAR",
        (pANTLR3_UINT8) "LAQUOT",
        (pANTLR3_UINT8) "RAQUOT",
        (pANTLR3_UINT8) "LBRACE",
        (pANTLR3_UINT8) "RBRACE",
        (pANTLR3_UINT8) "USCORE",
        (pANTLR3_UINT8) "EMARK",
        (pANTLR3_UINT8) "TILDE",
        (pANTLR3_UINT8) "SQUOTE",
        (pANTLR3_UINT8) "HTAB",
        (pANTLR3_UINT8) "OR"
       };

        
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_messageStack
 */
void
pbelle_sip_messageParser_messagePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(message)->free != NULL)
	{
        SCOPE_TOP(message)->free(SCOPE_TOP(message));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_messageStack_limit--;
    SCOPE_TOP(message) = (pbelle_sip_messageParser_message_SCOPE)(ctx->pbelle_sip_messageParser_messageStack->get(ctx->pbelle_sip_messageParser_messageStack, ctx->pbelle_sip_messageParser_messageStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_message_rawStack
 */
void
pbelle_sip_messageParser_message_rawPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(message_raw)->free != NULL)
	{
        SCOPE_TOP(message_raw)->free(SCOPE_TOP(message_raw));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_message_rawStack_limit--;
    SCOPE_TOP(message_raw) = (pbelle_sip_messageParser_message_raw_SCOPE)(ctx->pbelle_sip_messageParser_message_rawStack->get(ctx->pbelle_sip_messageParser_message_rawStack, ctx->pbelle_sip_messageParser_message_rawStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_common_requestStack
 */
void
pbelle_sip_messageParser_common_requestPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(common_request)->free != NULL)
	{
        SCOPE_TOP(common_request)->free(SCOPE_TOP(common_request));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_common_requestStack_limit--;
    SCOPE_TOP(common_request) = (pbelle_sip_messageParser_common_request_SCOPE)(ctx->pbelle_sip_messageParser_common_requestStack->get(ctx->pbelle_sip_messageParser_common_requestStack, ctx->pbelle_sip_messageParser_common_requestStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_request_lineStack
 */
void
pbelle_sip_messageParser_request_linePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(request_line)->free != NULL)
	{
        SCOPE_TOP(request_line)->free(SCOPE_TOP(request_line));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_request_lineStack_limit--;
    SCOPE_TOP(request_line) = (pbelle_sip_messageParser_request_line_SCOPE)(ctx->pbelle_sip_messageParser_request_lineStack->get(ctx->pbelle_sip_messageParser_request_lineStack, ctx->pbelle_sip_messageParser_request_lineStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_status_lineStack
 */
void
pbelle_sip_messageParser_status_linePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(status_line)->free != NULL)
	{
        SCOPE_TOP(status_line)->free(SCOPE_TOP(status_line));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_status_lineStack_limit--;
    SCOPE_TOP(status_line) = (pbelle_sip_messageParser_status_line_SCOPE)(ctx->pbelle_sip_messageParser_status_lineStack->get(ctx->pbelle_sip_messageParser_status_lineStack, ctx->pbelle_sip_messageParser_status_lineStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_http_request_lineStack
 */
void
pbelle_sip_messageParser_http_request_linePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(http_request_line)->free != NULL)
	{
        SCOPE_TOP(http_request_line)->free(SCOPE_TOP(http_request_line));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_http_request_lineStack_limit--;
    SCOPE_TOP(http_request_line) = (pbelle_sip_messageParser_http_request_line_SCOPE)(ctx->pbelle_sip_messageParser_http_request_lineStack->get(ctx->pbelle_sip_messageParser_http_request_lineStack, ctx->pbelle_sip_messageParser_http_request_lineStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack
 */
void
pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(generic_uri_for_from_to_contact_addr_spec)->free != NULL)
	{
        SCOPE_TOP(generic_uri_for_from_to_contact_addr_spec)->free(SCOPE_TOP(generic_uri_for_from_to_contact_addr_spec));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack_limit--;
    SCOPE_TOP(generic_uri_for_from_to_contact_addr_spec) = (pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_spec_SCOPE)(ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack->get(ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack, ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_generic_uriStack
 */
void
pbelle_sip_messageParser_generic_uriPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(generic_uri)->free != NULL)
	{
        SCOPE_TOP(generic_uri)->free(SCOPE_TOP(generic_uri));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_generic_uriStack_limit--;
    SCOPE_TOP(generic_uri) = (pbelle_sip_messageParser_generic_uri_SCOPE)(ctx->pbelle_sip_messageParser_generic_uriStack->get(ctx->pbelle_sip_messageParser_generic_uriStack, ctx->pbelle_sip_messageParser_generic_uriStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_authority_userinfoStack
 */
void
pbelle_sip_messageParser_authority_userinfoPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(authority_userinfo)->free != NULL)
	{
        SCOPE_TOP(authority_userinfo)->free(SCOPE_TOP(authority_userinfo));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_authority_userinfoStack_limit--;
    SCOPE_TOP(authority_userinfo) = (pbelle_sip_messageParser_authority_userinfo_SCOPE)(ctx->pbelle_sip_messageParser_authority_userinfoStack->get(ctx->pbelle_sip_messageParser_authority_userinfoStack, ctx->pbelle_sip_messageParser_authority_userinfoStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_authority_hostportStack
 */
void
pbelle_sip_messageParser_authority_hostportPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(authority_hostport)->free != NULL)
	{
        SCOPE_TOP(authority_hostport)->free(SCOPE_TOP(authority_hostport));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_authority_hostportStack_limit--;
    SCOPE_TOP(authority_hostport) = (pbelle_sip_messageParser_authority_hostport_SCOPE)(ctx->pbelle_sip_messageParser_authority_hostportStack->get(ctx->pbelle_sip_messageParser_authority_hostportStack, ctx->pbelle_sip_messageParser_authority_hostportStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_generic_paramStack
 */
void
pbelle_sip_messageParser_generic_paramPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(generic_param)->free != NULL)
	{
        SCOPE_TOP(generic_param)->free(SCOPE_TOP(generic_param));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_generic_paramStack_limit--;
    SCOPE_TOP(generic_param) = (pbelle_sip_messageParser_generic_param_SCOPE)(ctx->pbelle_sip_messageParser_generic_paramStack->get(ctx->pbelle_sip_messageParser_generic_paramStack, ctx->pbelle_sip_messageParser_generic_paramStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_allowStack
 */
void
pbelle_sip_messageParser_header_allowPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_allow)->free != NULL)
	{
        SCOPE_TOP(header_allow)->free(SCOPE_TOP(header_allow));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_allowStack_limit--;
    SCOPE_TOP(header_allow) = (pbelle_sip_messageParser_header_allow_SCOPE)(ctx->pbelle_sip_messageParser_header_allowStack->get(ctx->pbelle_sip_messageParser_header_allowStack, ctx->pbelle_sip_messageParser_header_allowStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_authorizationStack
 */
void
pbelle_sip_messageParser_header_authorizationPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_authorization)->free != NULL)
	{
        SCOPE_TOP(header_authorization)->free(SCOPE_TOP(header_authorization));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_authorizationStack_limit--;
    SCOPE_TOP(header_authorization) = (pbelle_sip_messageParser_header_authorization_SCOPE)(ctx->pbelle_sip_messageParser_header_authorizationStack->get(ctx->pbelle_sip_messageParser_header_authorizationStack, ctx->pbelle_sip_messageParser_header_authorizationStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_call_idStack
 */
void
pbelle_sip_messageParser_header_call_idPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_call_id)->free != NULL)
	{
        SCOPE_TOP(header_call_id)->free(SCOPE_TOP(header_call_id));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_call_idStack_limit--;
    SCOPE_TOP(header_call_id) = (pbelle_sip_messageParser_header_call_id_SCOPE)(ctx->pbelle_sip_messageParser_header_call_idStack->get(ctx->pbelle_sip_messageParser_header_call_idStack, ctx->pbelle_sip_messageParser_header_call_idStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_contactStack
 */
void
pbelle_sip_messageParser_header_contactPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_contact)->free != NULL)
	{
        SCOPE_TOP(header_contact)->free(SCOPE_TOP(header_contact));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_contactStack_limit--;
    SCOPE_TOP(header_contact) = (pbelle_sip_messageParser_header_contact_SCOPE)(ctx->pbelle_sip_messageParser_header_contactStack->get(ctx->pbelle_sip_messageParser_header_contactStack, ctx->pbelle_sip_messageParser_header_contactStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_contact_paramStack
 */
void
pbelle_sip_messageParser_contact_paramPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(contact_param)->free != NULL)
	{
        SCOPE_TOP(contact_param)->free(SCOPE_TOP(contact_param));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_contact_paramStack_limit--;
    SCOPE_TOP(contact_param) = (pbelle_sip_messageParser_contact_param_SCOPE)(ctx->pbelle_sip_messageParser_contact_paramStack->get(ctx->pbelle_sip_messageParser_contact_paramStack, ctx->pbelle_sip_messageParser_contact_paramStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_content_lengthStack
 */
void
pbelle_sip_messageParser_header_content_lengthPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_content_length)->free != NULL)
	{
        SCOPE_TOP(header_content_length)->free(SCOPE_TOP(header_content_length));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_content_lengthStack_limit--;
    SCOPE_TOP(header_content_length) = (pbelle_sip_messageParser_header_content_length_SCOPE)(ctx->pbelle_sip_messageParser_header_content_lengthStack->get(ctx->pbelle_sip_messageParser_header_content_lengthStack, ctx->pbelle_sip_messageParser_header_content_lengthStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_content_typeStack
 */
void
pbelle_sip_messageParser_header_content_typePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_content_type)->free != NULL)
	{
        SCOPE_TOP(header_content_type)->free(SCOPE_TOP(header_content_type));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_content_typeStack_limit--;
    SCOPE_TOP(header_content_type) = (pbelle_sip_messageParser_header_content_type_SCOPE)(ctx->pbelle_sip_messageParser_header_content_typeStack->get(ctx->pbelle_sip_messageParser_header_content_typeStack, ctx->pbelle_sip_messageParser_header_content_typeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_cseqStack
 */
void
pbelle_sip_messageParser_header_cseqPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_cseq)->free != NULL)
	{
        SCOPE_TOP(header_cseq)->free(SCOPE_TOP(header_cseq));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_cseqStack_limit--;
    SCOPE_TOP(header_cseq) = (pbelle_sip_messageParser_header_cseq_SCOPE)(ctx->pbelle_sip_messageParser_header_cseqStack->get(ctx->pbelle_sip_messageParser_header_cseqStack, ctx->pbelle_sip_messageParser_header_cseqStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_dateStack
 */
void
pbelle_sip_messageParser_header_datePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_date)->free != NULL)
	{
        SCOPE_TOP(header_date)->free(SCOPE_TOP(header_date));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_dateStack_limit--;
    SCOPE_TOP(header_date) = (pbelle_sip_messageParser_header_date_SCOPE)(ctx->pbelle_sip_messageParser_header_dateStack->get(ctx->pbelle_sip_messageParser_header_dateStack, ctx->pbelle_sip_messageParser_header_dateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_expiresStack
 */
void
pbelle_sip_messageParser_header_expiresPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_expires)->free != NULL)
	{
        SCOPE_TOP(header_expires)->free(SCOPE_TOP(header_expires));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_expiresStack_limit--;
    SCOPE_TOP(header_expires) = (pbelle_sip_messageParser_header_expires_SCOPE)(ctx->pbelle_sip_messageParser_header_expiresStack->get(ctx->pbelle_sip_messageParser_header_expiresStack, ctx->pbelle_sip_messageParser_header_expiresStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_fromStack
 */
void
pbelle_sip_messageParser_header_fromPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_from)->free != NULL)
	{
        SCOPE_TOP(header_from)->free(SCOPE_TOP(header_from));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_fromStack_limit--;
    SCOPE_TOP(header_from) = (pbelle_sip_messageParser_header_from_SCOPE)(ctx->pbelle_sip_messageParser_header_fromStack->get(ctx->pbelle_sip_messageParser_header_fromStack, ctx->pbelle_sip_messageParser_header_fromStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_max_forwardsStack
 */
void
pbelle_sip_messageParser_header_max_forwardsPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_max_forwards)->free != NULL)
	{
        SCOPE_TOP(header_max_forwards)->free(SCOPE_TOP(header_max_forwards));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit--;
    SCOPE_TOP(header_max_forwards) = (pbelle_sip_messageParser_header_max_forwards_SCOPE)(ctx->pbelle_sip_messageParser_header_max_forwardsStack->get(ctx->pbelle_sip_messageParser_header_max_forwardsStack, ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_proxy_authenticateStack
 */
void
pbelle_sip_messageParser_header_proxy_authenticatePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_proxy_authenticate)->free != NULL)
	{
        SCOPE_TOP(header_proxy_authenticate)->free(SCOPE_TOP(header_proxy_authenticate));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit--;
    SCOPE_TOP(header_proxy_authenticate) = (pbelle_sip_messageParser_header_proxy_authenticate_SCOPE)(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->get(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack, ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_qop_optsStack
 */
void
pbelle_sip_messageParser_qop_optsPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(qop_opts)->free != NULL)
	{
        SCOPE_TOP(qop_opts)->free(SCOPE_TOP(qop_opts));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_qop_optsStack_limit--;
    SCOPE_TOP(qop_opts) = (pbelle_sip_messageParser_qop_opts_SCOPE)(ctx->pbelle_sip_messageParser_qop_optsStack->get(ctx->pbelle_sip_messageParser_qop_optsStack, ctx->pbelle_sip_messageParser_qop_optsStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_proxy_authorizationStack
 */
void
pbelle_sip_messageParser_header_proxy_authorizationPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_proxy_authorization)->free != NULL)
	{
        SCOPE_TOP(header_proxy_authorization)->free(SCOPE_TOP(header_proxy_authorization));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit--;
    SCOPE_TOP(header_proxy_authorization) = (pbelle_sip_messageParser_header_proxy_authorization_SCOPE)(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->get(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack, ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_service_routeStack
 */
void
pbelle_sip_messageParser_header_service_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_service_route)->free != NULL)
	{
        SCOPE_TOP(header_service_route)->free(SCOPE_TOP(header_service_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_service_routeStack_limit--;
    SCOPE_TOP(header_service_route) = (pbelle_sip_messageParser_header_service_route_SCOPE)(ctx->pbelle_sip_messageParser_header_service_routeStack->get(ctx->pbelle_sip_messageParser_header_service_routeStack, ctx->pbelle_sip_messageParser_header_service_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_srv_routeStack
 */
void
pbelle_sip_messageParser_srv_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(srv_route)->free != NULL)
	{
        SCOPE_TOP(srv_route)->free(SCOPE_TOP(srv_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_srv_routeStack_limit--;
    SCOPE_TOP(srv_route) = (pbelle_sip_messageParser_srv_route_SCOPE)(ctx->pbelle_sip_messageParser_srv_routeStack->get(ctx->pbelle_sip_messageParser_srv_routeStack, ctx->pbelle_sip_messageParser_srv_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_record_routeStack
 */
void
pbelle_sip_messageParser_header_record_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_record_route)->free != NULL)
	{
        SCOPE_TOP(header_record_route)->free(SCOPE_TOP(header_record_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_record_routeStack_limit--;
    SCOPE_TOP(header_record_route) = (pbelle_sip_messageParser_header_record_route_SCOPE)(ctx->pbelle_sip_messageParser_header_record_routeStack->get(ctx->pbelle_sip_messageParser_header_record_routeStack, ctx->pbelle_sip_messageParser_header_record_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_rec_routeStack
 */
void
pbelle_sip_messageParser_rec_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(rec_route)->free != NULL)
	{
        SCOPE_TOP(rec_route)->free(SCOPE_TOP(rec_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_rec_routeStack_limit--;
    SCOPE_TOP(rec_route) = (pbelle_sip_messageParser_rec_route_SCOPE)(ctx->pbelle_sip_messageParser_rec_routeStack->get(ctx->pbelle_sip_messageParser_rec_routeStack, ctx->pbelle_sip_messageParser_rec_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_routeStack
 */
void
pbelle_sip_messageParser_header_routePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_route)->free != NULL)
	{
        SCOPE_TOP(header_route)->free(SCOPE_TOP(header_route));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_routeStack_limit--;
    SCOPE_TOP(header_route) = (pbelle_sip_messageParser_header_route_SCOPE)(ctx->pbelle_sip_messageParser_header_routeStack->get(ctx->pbelle_sip_messageParser_header_routeStack, ctx->pbelle_sip_messageParser_header_routeStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_route_paramStack
 */
void
pbelle_sip_messageParser_route_paramPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(route_param)->free != NULL)
	{
        SCOPE_TOP(route_param)->free(SCOPE_TOP(route_param));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_route_paramStack_limit--;
    SCOPE_TOP(route_param) = (pbelle_sip_messageParser_route_param_SCOPE)(ctx->pbelle_sip_messageParser_route_paramStack->get(ctx->pbelle_sip_messageParser_route_paramStack, ctx->pbelle_sip_messageParser_route_paramStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_toStack
 */
void
pbelle_sip_messageParser_header_toPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_to)->free != NULL)
	{
        SCOPE_TOP(header_to)->free(SCOPE_TOP(header_to));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_toStack_limit--;
    SCOPE_TOP(header_to) = (pbelle_sip_messageParser_header_to_SCOPE)(ctx->pbelle_sip_messageParser_header_toStack->get(ctx->pbelle_sip_messageParser_header_toStack, ctx->pbelle_sip_messageParser_header_toStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_user_agentStack
 */
void
pbelle_sip_messageParser_header_user_agentPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_user_agent)->free != NULL)
	{
        SCOPE_TOP(header_user_agent)->free(SCOPE_TOP(header_user_agent));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_user_agentStack_limit--;
    SCOPE_TOP(header_user_agent) = (pbelle_sip_messageParser_header_user_agent_SCOPE)(ctx->pbelle_sip_messageParser_header_user_agentStack->get(ctx->pbelle_sip_messageParser_header_user_agentStack, ctx->pbelle_sip_messageParser_header_user_agentStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_viaStack
 */
void
pbelle_sip_messageParser_header_viaPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_via)->free != NULL)
	{
        SCOPE_TOP(header_via)->free(SCOPE_TOP(header_via));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_viaStack_limit--;
    SCOPE_TOP(header_via) = (pbelle_sip_messageParser_header_via_SCOPE)(ctx->pbelle_sip_messageParser_header_viaStack->get(ctx->pbelle_sip_messageParser_header_viaStack, ctx->pbelle_sip_messageParser_header_viaStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_via_parmStack
 */
void
pbelle_sip_messageParser_via_parmPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(via_parm)->free != NULL)
	{
        SCOPE_TOP(via_parm)->free(SCOPE_TOP(via_parm));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_via_parmStack_limit--;
    SCOPE_TOP(via_parm) = (pbelle_sip_messageParser_via_parm_SCOPE)(ctx->pbelle_sip_messageParser_via_parmStack->get(ctx->pbelle_sip_messageParser_via_parmStack, ctx->pbelle_sip_messageParser_via_parmStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_www_authenticateStack
 */
void
pbelle_sip_messageParser_header_www_authenticatePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_www_authenticate)->free != NULL)
	{
        SCOPE_TOP(header_www_authenticate)->free(SCOPE_TOP(header_www_authenticate));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit--;
    SCOPE_TOP(header_www_authenticate) = (pbelle_sip_messageParser_header_www_authenticate_SCOPE)(ctx->pbelle_sip_messageParser_header_www_authenticateStack->get(ctx->pbelle_sip_messageParser_header_www_authenticateStack, ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_subscription_stateStack
 */
void
pbelle_sip_messageParser_header_subscription_statePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_subscription_state)->free != NULL)
	{
        SCOPE_TOP(header_subscription_state)->free(SCOPE_TOP(header_subscription_state));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit--;
    SCOPE_TOP(header_subscription_state) = (pbelle_sip_messageParser_header_subscription_state_SCOPE)(ctx->pbelle_sip_messageParser_header_subscription_stateStack->get(ctx->pbelle_sip_messageParser_header_subscription_stateStack, ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_eventStack
 */
void
pbelle_sip_messageParser_header_eventPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_event)->free != NULL)
	{
        SCOPE_TOP(header_event)->free(SCOPE_TOP(header_event));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_eventStack_limit--;
    SCOPE_TOP(header_event) = (pbelle_sip_messageParser_header_event_SCOPE)(ctx->pbelle_sip_messageParser_header_eventStack->get(ctx->pbelle_sip_messageParser_header_eventStack, ctx->pbelle_sip_messageParser_header_eventStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_replacesStack
 */
void
pbelle_sip_messageParser_header_replacesPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_replaces)->free != NULL)
	{
        SCOPE_TOP(header_replaces)->free(SCOPE_TOP(header_replaces));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_replacesStack_limit--;
    SCOPE_TOP(header_replaces) = (pbelle_sip_messageParser_header_replaces_SCOPE)(ctx->pbelle_sip_messageParser_header_replacesStack->get(ctx->pbelle_sip_messageParser_header_replacesStack, ctx->pbelle_sip_messageParser_header_replacesStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_privacyStack
 */
void
pbelle_sip_messageParser_header_privacyPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_privacy)->free != NULL)
	{
        SCOPE_TOP(header_privacy)->free(SCOPE_TOP(header_privacy));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_privacyStack_limit--;
    SCOPE_TOP(header_privacy) = (pbelle_sip_messageParser_header_privacy_SCOPE)(ctx->pbelle_sip_messageParser_header_privacyStack->get(ctx->pbelle_sip_messageParser_header_privacyStack, ctx->pbelle_sip_messageParser_header_privacyStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_header_extension_baseStack
 */
void
pbelle_sip_messageParser_header_extension_basePop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(header_extension_base)->free != NULL)
	{
        SCOPE_TOP(header_extension_base)->free(SCOPE_TOP(header_extension_base));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_header_extension_baseStack_limit--;
    SCOPE_TOP(header_extension_base) = (pbelle_sip_messageParser_header_extension_base_SCOPE)(ctx->pbelle_sip_messageParser_header_extension_baseStack->get(ctx->pbelle_sip_messageParser_header_extension_baseStack, ctx->pbelle_sip_messageParser_header_extension_baseStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_paramless_uriStack
 */
void
pbelle_sip_messageParser_paramless_uriPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(paramless_uri)->free != NULL)
	{
        SCOPE_TOP(paramless_uri)->free(SCOPE_TOP(paramless_uri));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_paramless_uriStack_limit--;
    SCOPE_TOP(paramless_uri) = (pbelle_sip_messageParser_paramless_uri_SCOPE)(ctx->pbelle_sip_messageParser_paramless_uriStack->get(ctx->pbelle_sip_messageParser_paramless_uriStack, ctx->pbelle_sip_messageParser_paramless_uriStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_uriStack
 */
void
pbelle_sip_messageParser_uriPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(uri)->free != NULL)
	{
        SCOPE_TOP(uri)->free(SCOPE_TOP(uri));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_uriStack_limit--;
    SCOPE_TOP(uri) = (pbelle_sip_messageParser_uri_SCOPE)(ctx->pbelle_sip_messageParser_uriStack->get(ctx->pbelle_sip_messageParser_uriStack, ctx->pbelle_sip_messageParser_uriStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_userinfoStack
 */
void
pbelle_sip_messageParser_userinfoPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(userinfo)->free != NULL)
	{
        SCOPE_TOP(userinfo)->free(SCOPE_TOP(userinfo));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_userinfoStack_limit--;
    SCOPE_TOP(userinfo) = (pbelle_sip_messageParser_userinfo_SCOPE)(ctx->pbelle_sip_messageParser_userinfoStack->get(ctx->pbelle_sip_messageParser_userinfoStack, ctx->pbelle_sip_messageParser_userinfoStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_hostportStack
 */
void
pbelle_sip_messageParser_hostportPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(hostport)->free != NULL)
	{
        SCOPE_TOP(hostport)->free(SCOPE_TOP(hostport));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_hostportStack_limit--;
    SCOPE_TOP(hostport) = (pbelle_sip_messageParser_hostport_SCOPE)(ctx->pbelle_sip_messageParser_hostportStack->get(ctx->pbelle_sip_messageParser_hostportStack, ctx->pbelle_sip_messageParser_hostportStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_uri_parametersStack
 */
void
pbelle_sip_messageParser_uri_parametersPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(uri_parameters)->free != NULL)
	{
        SCOPE_TOP(uri_parameters)->free(SCOPE_TOP(uri_parameters));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_uri_parametersStack_limit--;
    SCOPE_TOP(uri_parameters) = (pbelle_sip_messageParser_uri_parameters_SCOPE)(ctx->pbelle_sip_messageParser_uri_parametersStack->get(ctx->pbelle_sip_messageParser_uri_parametersStack, ctx->pbelle_sip_messageParser_uri_parametersStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_headersStack
 */
void
pbelle_sip_messageParser_headersPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(headers)->free != NULL)
	{
        SCOPE_TOP(headers)->free(SCOPE_TOP(headers));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_headersStack_limit--;
    SCOPE_TOP(headers) = (pbelle_sip_messageParser_headers_SCOPE)(ctx->pbelle_sip_messageParser_headersStack->get(ctx->pbelle_sip_messageParser_headersStack, ctx->pbelle_sip_messageParser_headersStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_uri_headerStack
 */
void
pbelle_sip_messageParser_uri_headerPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(uri_header)->free != NULL)
	{
        SCOPE_TOP(uri_header)->free(SCOPE_TOP(uri_header));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_uri_headerStack_limit--;
    SCOPE_TOP(uri_header) = (pbelle_sip_messageParser_uri_header_SCOPE)(ctx->pbelle_sip_messageParser_uri_headerStack->get(ctx->pbelle_sip_messageParser_uri_headerStack, ctx->pbelle_sip_messageParser_uri_headerStack_limit - 1));
}
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sip_messageParser_hostStack
 */
void
pbelle_sip_messageParser_hostPop(pbelle_sip_messageParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(host)->free != NULL)
	{
        SCOPE_TOP(host)->free(SCOPE_TOP(host));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sip_messageParser_hostStack_limit--;
    SCOPE_TOP(host) = (pbelle_sip_messageParser_host_SCOPE)(ctx->pbelle_sip_messageParser_hostStack->get(ctx->pbelle_sip_messageParser_hostStack, ctx->pbelle_sip_messageParser_hostStack_limit - 1));
}


// Forward declare the locally static matching functions we have generated.
//
static belle_sip_message_t*	message    (pbelle_sip_messageParser ctx);
static belle_sip_message_t*	message_raw    (pbelle_sip_messageParser ctx, size_t* length);
static belle_sip_request_t*	request    (pbelle_sip_messageParser ctx);
static belle_sip_message_t*	common_request    (pbelle_sip_messageParser ctx);
static belle_sip_request_t*	request_line    (pbelle_sip_messageParser ctx);
static void	sip_version    (pbelle_sip_messageParser ctx);
static void	generic_version    (pbelle_sip_messageParser ctx);
static void	message_header    (pbelle_sip_messageParser ctx, belle_sip_message_t* message);
static belle_sip_messageParser_method_return	method    (pbelle_sip_messageParser ctx);
static void	extension_method    (pbelle_sip_messageParser ctx);
static belle_sip_message_t*	common_response    (pbelle_sip_messageParser ctx);
static belle_sip_response_t*	response    (pbelle_sip_messageParser ctx);
static belle_sip_response_t*	status_line    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_status_code_return	status_code    (pbelle_sip_messageParser ctx);
static void	extension_code    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_reason_phrase_return	reason_phrase    (pbelle_sip_messageParser ctx);
static belle_http_request_t*	http_request    (pbelle_sip_messageParser ctx);
static belle_http_request_t *	http_request_line    (pbelle_sip_messageParser ctx);
static void	http_version    (pbelle_sip_messageParser ctx);
static belle_http_response_t*	http_response    (pbelle_sip_messageParser ctx);
static belle_http_response_t*	http_status_line    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_opaque_part_for_from_to_contact_addr_spec_return	opaque_part_for_from_to_contact_addr_spec    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_opaque_part_return	opaque_part    (pbelle_sip_messageParser ctx);
static void	uric_no_slash_for_from_to_contact_addr_spec    (pbelle_sip_messageParser ctx);
static void	uric_no_slash    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_scheme_return	scheme    (pbelle_sip_messageParser ctx);
static belle_generic_uri_t*	generic_uri_for_from_to_contact_addr_spec    (pbelle_sip_messageParser ctx);
static belle_generic_uri_t*	generic_uri    (pbelle_sip_messageParser ctx);
static belle_generic_uri_t*	hier_part    (pbelle_sip_messageParser ctx, belle_generic_uri_t* uri);
static belle_sip_messageParser_path_segments_return	path_segments    (pbelle_sip_messageParser ctx, belle_generic_uri_t* uri);
static void	segment    (pbelle_sip_messageParser ctx);
static void	param    (pbelle_sip_messageParser ctx);
static void	pchar    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_query_return	query    (pbelle_sip_messageParser ctx);
static void	uric    (pbelle_sip_messageParser ctx);
static void	uric_for_from_to_contact_addr_spec    (pbelle_sip_messageParser ctx);
static void	authority    (pbelle_sip_messageParser ctx, belle_generic_uri_t* uri);
static void	authority_userinfo    (pbelle_sip_messageParser ctx, belle_generic_uri_t* uri);
static belle_sip_messageParser_authority_user_return	authority_user    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_authority_password_return	authority_password    (pbelle_sip_messageParser ctx);
static void	authority_hostport    (pbelle_sip_messageParser ctx, belle_generic_uri_t* uri);
static belle_sip_param_pair_t*	generic_param    (pbelle_sip_messageParser ctx, belle_sip_parameters_t* object);
static belle_sip_messageParser_gen_value_return	gen_value    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_quoted_string_return	quoted_string    (pbelle_sip_messageParser ctx);
static belle_sip_header_allow_t*	header_allow    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_methods_return	methods    (pbelle_sip_messageParser ctx);
static void	authorization_token    (pbelle_sip_messageParser ctx);
static void	digest_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_authorization_t*	header_authorization    (pbelle_sip_messageParser ctx);
static void	credentials    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static void	digest_response    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static void	dig_resp    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static void	username_token    (pbelle_sip_messageParser ctx);
static char*	username    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_username_value_return	username_value    (pbelle_sip_messageParser ctx);
static void	uri_token    (pbelle_sip_messageParser ctx);
static void	digest_uri    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static const char*	message_qop    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_qop_value_return	qop_value    (pbelle_sip_messageParser ctx);
static char*	cnonce    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_cnonce_value_return	cnonce_value    (pbelle_sip_messageParser ctx);
static const char*	nonce_count    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_nc_value_return	nc_value    (pbelle_sip_messageParser ctx);
static char*	dresponse    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_request_digest_return	request_digest    (pbelle_sip_messageParser ctx);
static void	huit_lhex    (pbelle_sip_messageParser ctx);
static void	auth_param    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static belle_sip_messageParser_auth_param_value_return	auth_param_value    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_auth_param_name_return	auth_param_name    (pbelle_sip_messageParser ctx);
static void	other_response    (pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base);
static belle_sip_messageParser_auth_scheme_return	auth_scheme    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_nonce_value_return	nonce_value    (pbelle_sip_messageParser ctx);
static void	call_id_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_call_id_t*	header_call_id    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_call_id_return	call_id    (pbelle_sip_messageParser ctx);
static void	contact_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_contact_t*	header_contact    (pbelle_sip_messageParser ctx);
static void	contact_param    (pbelle_sip_messageParser ctx);
static belle_sip_header_address_t*	header_address    (pbelle_sip_messageParser ctx);
static belle_sip_header_address_t*	header_address_base    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* obj);
static void	name_addr    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	name_addr_with_generic_uri    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	addr_spec    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	addr_spec_with_generic_uri    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	paramless_addr_spec    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	paramless_addr_spec_with_generic_uri    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static belle_sip_messageParser_display_name_tokens_return	display_name_tokens    (pbelle_sip_messageParser ctx);
static void	display_name    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* object);
static void	contact_params    (pbelle_sip_messageParser ctx);
static void	contact_extension    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_delta_seconds_return	delta_seconds    (pbelle_sip_messageParser ctx);
static void	content_length_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_content_length_t*	header_content_length    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_content_length_return	content_length    (pbelle_sip_messageParser ctx);
static void	content_type_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_content_type_t*	header_content_type    (pbelle_sip_messageParser ctx);
static void	media_type    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_m_type_return	m_type    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_m_subtype_return	m_subtype    (pbelle_sip_messageParser ctx);
static void	cseq_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_cseq_t*	header_cseq    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_seq_number_return	seq_number    (pbelle_sip_messageParser ctx);
static void	date_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_date_t*	header_date    (pbelle_sip_messageParser ctx);
static void	date    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_sip_date_return	sip_date    (pbelle_sip_messageParser ctx);
static belle_sip_header_expires_t*	header_expires    (pbelle_sip_messageParser ctx);
static void	from_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_from_t*	header_from    (pbelle_sip_messageParser ctx);
static void	from_spec    (pbelle_sip_messageParser ctx);
static void	from_param    (pbelle_sip_messageParser ctx);
static belle_sip_header_max_forwards_t*	header_max_forwards    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_max_forwards_return	max_forwards    (pbelle_sip_messageParser ctx);
static belle_sip_header_proxy_authenticate_t*	header_proxy_authenticate    (pbelle_sip_messageParser ctx);
static void	challenge    (pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate);
static void	other_challenge    (pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate);
static void	digest_cln    (pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate);
static char*	realm    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_realm_value_return	realm_value    (pbelle_sip_messageParser ctx);
static char*	domain    (pbelle_sip_messageParser ctx);
static char*	nonce    (pbelle_sip_messageParser ctx);
static char*	opaque    (pbelle_sip_messageParser ctx);
static const char*	stale    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_stale_value_return	stale_value    (pbelle_sip_messageParser ctx);
static const char*	algorithm    (pbelle_sip_messageParser ctx);
static belle_sip_list_t*	qop_opts    (pbelle_sip_messageParser ctx);
static void	qop_opts_value    (pbelle_sip_messageParser ctx);
static belle_sip_header_proxy_authorization_t*	header_proxy_authorization    (pbelle_sip_messageParser ctx);
static void	service_route_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_service_route_t*	header_service_route    (pbelle_sip_messageParser ctx);
static void	srv_route    (pbelle_sip_messageParser ctx);
static void	sr_param    (pbelle_sip_messageParser ctx);
static void	record_route_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_record_route_t*	header_record_route    (pbelle_sip_messageParser ctx);
static void	rec_route    (pbelle_sip_messageParser ctx);
static void	rr_param    (pbelle_sip_messageParser ctx);
static void	comment    (pbelle_sip_messageParser ctx);
static void	route_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_route_t*	header_route    (pbelle_sip_messageParser ctx);
static void	route_param    (pbelle_sip_messageParser ctx);
static void	r_param    (pbelle_sip_messageParser ctx);
static void	to_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_to_t*	header_to    (pbelle_sip_messageParser ctx);
static void	to_spec    (pbelle_sip_messageParser ctx);
static void	to_param    (pbelle_sip_messageParser ctx);
static void	refer_to_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_refer_to_t*	header_refer_to    (pbelle_sip_messageParser ctx);
static void	referred_by_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_referred_by_t*	header_referred_by    (pbelle_sip_messageParser ctx);
static belle_sip_header_address_t*	refer_to_spec    (pbelle_sip_messageParser ctx, belle_sip_header_address_t* address);
static belle_sip_header_user_agent_t*	header_user_agent    (pbelle_sip_messageParser ctx);
static void	server_val    (pbelle_sip_messageParser ctx);
static void	via_token    (pbelle_sip_messageParser ctx);
static belle_sip_header_via_t*	header_via    (pbelle_sip_messageParser ctx);
static void	via_parm    (pbelle_sip_messageParser ctx);
static void	via_params    (pbelle_sip_messageParser ctx);
static void	via_received    (pbelle_sip_messageParser ctx, belle_sip_header_via_t* object);
static belle_sip_messageParser_via_address_return	via_address    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_sent_protocol_return	sent_protocol    (pbelle_sip_messageParser ctx);
static void	protocol_name    (pbelle_sip_messageParser ctx);
static void	protocol_version    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_transport_return	transport    (pbelle_sip_messageParser ctx);
static void	other_transport    (pbelle_sip_messageParser ctx);
static void	sent_by    (pbelle_sip_messageParser ctx);
static belle_sip_header_www_authenticate_t*	header_www_authenticate    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_state_value_return	state_value    (pbelle_sip_messageParser ctx);
static belle_sip_header_subscription_state_t*	header_subscription_state    (pbelle_sip_messageParser ctx);
static belle_sip_header_event_t*	header_event    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_event_package_return	event_package    (pbelle_sip_messageParser ctx);
static belle_sip_header_replaces_t*	header_replaces    (pbelle_sip_messageParser ctx);
static belle_sip_header_p_preferred_identity_t*	header_p_preferred_identity    (pbelle_sip_messageParser ctx);
static belle_sip_header_privacy_t*	header_privacy    (pbelle_sip_messageParser ctx);
static void	privacy_val    (pbelle_sip_messageParser ctx);
static belle_sip_header_t*	header    (pbelle_sip_messageParser ctx);
static belle_sip_header_t*	header_extension_base    (pbelle_sip_messageParser ctx, ANTLR3_BOOLEAN is_http);
static belle_sip_messageParser_header_name_return	header_name    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_header_value_return	header_value    (pbelle_sip_messageParser ctx, const char* name, ANTLR3_BOOLEAN is_http);
static void	message_body    (pbelle_sip_messageParser ctx);
static belle_sip_uri_t*	paramless_uri    (pbelle_sip_messageParser ctx);
static belle_sip_uri_t*	uri    (pbelle_sip_messageParser ctx);
static void	sip_token    (pbelle_sip_messageParser ctx);
static void	sips_token    (pbelle_sip_messageParser ctx);
static void	sip_schema    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static void	userinfo    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static belle_sip_messageParser_user_return	user    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_password_return	password    (pbelle_sip_messageParser ctx);
static void	hostport    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static void	uri_parameters    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static void	uri_parameter    (pbelle_sip_messageParser ctx);
static void	other_param    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_pname_return	pname    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_pvalue_return	pvalue    (pbelle_sip_messageParser ctx);
static void	paramchar    (pbelle_sip_messageParser ctx);
static void	param_unreserved    (pbelle_sip_messageParser ctx);
static void	headers    (pbelle_sip_messageParser ctx, belle_sip_uri_t* uri);
static void	uri_header    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_hname_return	hname    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_hvalue_return	hvalue    (pbelle_sip_messageParser ctx);
static void	hnv_unreserved    (pbelle_sip_messageParser ctx);
static void	user_unreserved    (pbelle_sip_messageParser ctx);
static const char*	host    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_hostname_return	hostname    (pbelle_sip_messageParser ctx);
static void	domainlabel    (pbelle_sip_messageParser ctx);
static void	toplabel    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_ipv4address_return	ipv4address    (pbelle_sip_messageParser ctx);
static void	ipv6reference    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_ipv6address_return	ipv6address    (pbelle_sip_messageParser ctx);
static void	hexpart    (pbelle_sip_messageParser ctx);
static void	hexseq    (pbelle_sip_messageParser ctx);
static void	hex4    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_port_return	port    (pbelle_sip_messageParser ctx);
static void	escaped    (pbelle_sip_messageParser ctx);
static void	ttl    (pbelle_sip_messageParser ctx);
static void	three_digit    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_token_return	token    (pbelle_sip_messageParser ctx);
static void	reserved_for_from_to_contact_addr_spec    (pbelle_sip_messageParser ctx);
static void	reserved    (pbelle_sip_messageParser ctx);
static void	unreserved    (pbelle_sip_messageParser ctx);
static void	alphanum    (pbelle_sip_messageParser ctx);
static void	hexdigit    (pbelle_sip_messageParser ctx);
static void	alpha    (pbelle_sip_messageParser ctx);
static belle_sip_messageParser_word_return	word    (pbelle_sip_messageParser ctx);
static void	mark    (pbelle_sip_messageParser ctx);
static void	sp_tab_colon    (pbelle_sip_messageParser ctx);
static void	hcolon    (pbelle_sip_messageParser ctx);
static void	ldquot    (pbelle_sip_messageParser ctx);
static void	rdquot    (pbelle_sip_messageParser ctx);
static void	semi    (pbelle_sip_messageParser ctx);
static void	comma    (pbelle_sip_messageParser ctx);
static void	sp_laquot    (pbelle_sip_messageParser ctx);
static void	raquot_sp    (pbelle_sip_messageParser ctx);
static void	equal    (pbelle_sip_messageParser ctx);
static void	slash    (pbelle_sip_messageParser ctx);
static void	lws    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred1_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred2_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred3_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred4_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred6_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred7_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred8_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred9_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred10_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred11_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred12_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred13_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred14_belle_sip_message    (pbelle_sip_messageParser ctx);
static ANTLR3_BOOLEAN	synpred15_belle_sip_message    (pbelle_sip_messageParser ctx);
static void	belle_sip_messageParserFree(pbelle_sip_messageParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new belle_sip_messageParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pbelle_sip_messageParser
belle_sip_messageParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return belle_sip_messageParserNewSSD(instream, NULL);
}

/** \brief Create a new belle_sip_messageParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pbelle_sip_messageParser
belle_sip_messageParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pbelle_sip_messageParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pbelle_sip_messageParser) ANTLR3_CALLOC(1, sizeof(belle_sip_messageParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in belle_sip_messageParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our belle_sip_messageParser interface
     */
    ctx->message	= message;
    ctx->message_raw	= message_raw;
    ctx->request	= request;
    ctx->common_request	= common_request;
    ctx->request_line	= request_line;
    ctx->sip_version	= sip_version;
    ctx->generic_version	= generic_version;
    ctx->message_header	= message_header;
    ctx->method	= method;
    ctx->extension_method	= extension_method;
    ctx->common_response	= common_response;
    ctx->response	= response;
    ctx->status_line	= status_line;
    ctx->status_code	= status_code;
    ctx->extension_code	= extension_code;
    ctx->reason_phrase	= reason_phrase;
    ctx->http_request	= http_request;
    ctx->http_request_line	= http_request_line;
    ctx->http_version	= http_version;
    ctx->http_response	= http_response;
    ctx->http_status_line	= http_status_line;
    ctx->opaque_part_for_from_to_contact_addr_spec	= opaque_part_for_from_to_contact_addr_spec;
    ctx->opaque_part	= opaque_part;
    ctx->uric_no_slash_for_from_to_contact_addr_spec	= uric_no_slash_for_from_to_contact_addr_spec;
    ctx->uric_no_slash	= uric_no_slash;
    ctx->scheme	= scheme;
    ctx->generic_uri_for_from_to_contact_addr_spec	= generic_uri_for_from_to_contact_addr_spec;
    ctx->generic_uri	= generic_uri;
    ctx->hier_part	= hier_part;
    ctx->path_segments	= path_segments;
    ctx->segment	= segment;
    ctx->param	= param;
    ctx->pchar	= pchar;
    ctx->query	= query;
    ctx->uric	= uric;
    ctx->uric_for_from_to_contact_addr_spec	= uric_for_from_to_contact_addr_spec;
    ctx->authority	= authority;
    ctx->authority_userinfo	= authority_userinfo;
    ctx->authority_user	= authority_user;
    ctx->authority_password	= authority_password;
    ctx->authority_hostport	= authority_hostport;
    ctx->generic_param	= generic_param;
    ctx->gen_value	= gen_value;
    ctx->quoted_string	= quoted_string;
    ctx->header_allow	= header_allow;
    ctx->methods	= methods;
    ctx->authorization_token	= authorization_token;
    ctx->digest_token	= digest_token;
    ctx->header_authorization	= header_authorization;
    ctx->credentials	= credentials;
    ctx->digest_response	= digest_response;
    ctx->dig_resp	= dig_resp;
    ctx->username_token	= username_token;
    ctx->username	= username;
    ctx->username_value	= username_value;
    ctx->uri_token	= uri_token;
    ctx->digest_uri	= digest_uri;
    ctx->message_qop	= message_qop;
    ctx->qop_value	= qop_value;
    ctx->cnonce	= cnonce;
    ctx->cnonce_value	= cnonce_value;
    ctx->nonce_count	= nonce_count;
    ctx->nc_value	= nc_value;
    ctx->dresponse	= dresponse;
    ctx->request_digest	= request_digest;
    ctx->huit_lhex	= huit_lhex;
    ctx->auth_param	= auth_param;
    ctx->auth_param_value	= auth_param_value;
    ctx->auth_param_name	= auth_param_name;
    ctx->other_response	= other_response;
    ctx->auth_scheme	= auth_scheme;
    ctx->nonce_value	= nonce_value;
    ctx->call_id_token	= call_id_token;
    ctx->header_call_id	= header_call_id;
    ctx->call_id	= call_id;
    ctx->contact_token	= contact_token;
    ctx->header_contact	= header_contact;
    ctx->contact_param	= contact_param;
    ctx->header_address	= header_address;
    ctx->header_address_base	= header_address_base;
    ctx->name_addr	= name_addr;
    ctx->name_addr_with_generic_uri	= name_addr_with_generic_uri;
    ctx->addr_spec	= addr_spec;
    ctx->addr_spec_with_generic_uri	= addr_spec_with_generic_uri;
    ctx->paramless_addr_spec	= paramless_addr_spec;
    ctx->paramless_addr_spec_with_generic_uri	= paramless_addr_spec_with_generic_uri;
    ctx->display_name_tokens	= display_name_tokens;
    ctx->display_name	= display_name;
    ctx->contact_params	= contact_params;
    ctx->contact_extension	= contact_extension;
    ctx->delta_seconds	= delta_seconds;
    ctx->content_length_token	= content_length_token;
    ctx->header_content_length	= header_content_length;
    ctx->content_length	= content_length;
    ctx->content_type_token	= content_type_token;
    ctx->header_content_type	= header_content_type;
    ctx->media_type	= media_type;
    ctx->m_type	= m_type;
    ctx->m_subtype	= m_subtype;
    ctx->cseq_token	= cseq_token;
    ctx->header_cseq	= header_cseq;
    ctx->seq_number	= seq_number;
    ctx->date_token	= date_token;
    ctx->header_date	= header_date;
    ctx->date	= date;
    ctx->sip_date	= sip_date;
    ctx->header_expires	= header_expires;
    ctx->from_token	= from_token;
    ctx->header_from	= header_from;
    ctx->from_spec	= from_spec;
    ctx->from_param	= from_param;
    ctx->header_max_forwards	= header_max_forwards;
    ctx->max_forwards	= max_forwards;
    ctx->header_proxy_authenticate	= header_proxy_authenticate;
    ctx->challenge	= challenge;
    ctx->other_challenge	= other_challenge;
    ctx->digest_cln	= digest_cln;
    ctx->realm	= realm;
    ctx->realm_value	= realm_value;
    ctx->domain	= domain;
    ctx->nonce	= nonce;
    ctx->opaque	= opaque;
    ctx->stale	= stale;
    ctx->stale_value	= stale_value;
    ctx->algorithm	= algorithm;
    ctx->qop_opts	= qop_opts;
    ctx->qop_opts_value	= qop_opts_value;
    ctx->header_proxy_authorization	= header_proxy_authorization;
    ctx->service_route_token	= service_route_token;
    ctx->header_service_route	= header_service_route;
    ctx->srv_route	= srv_route;
    ctx->sr_param	= sr_param;
    ctx->record_route_token	= record_route_token;
    ctx->header_record_route	= header_record_route;
    ctx->rec_route	= rec_route;
    ctx->rr_param	= rr_param;
    ctx->comment	= comment;
    ctx->route_token	= route_token;
    ctx->header_route	= header_route;
    ctx->route_param	= route_param;
    ctx->r_param	= r_param;
    ctx->to_token	= to_token;
    ctx->header_to	= header_to;
    ctx->to_spec	= to_spec;
    ctx->to_param	= to_param;
    ctx->refer_to_token	= refer_to_token;
    ctx->header_refer_to	= header_refer_to;
    ctx->referred_by_token	= referred_by_token;
    ctx->header_referred_by	= header_referred_by;
    ctx->refer_to_spec	= refer_to_spec;
    ctx->header_user_agent	= header_user_agent;
    ctx->server_val	= server_val;
    ctx->via_token	= via_token;
    ctx->header_via	= header_via;
    ctx->via_parm	= via_parm;
    ctx->via_params	= via_params;
    ctx->via_received	= via_received;
    ctx->via_address	= via_address;
    ctx->sent_protocol	= sent_protocol;
    ctx->protocol_name	= protocol_name;
    ctx->protocol_version	= protocol_version;
    ctx->transport	= transport;
    ctx->other_transport	= other_transport;
    ctx->sent_by	= sent_by;
    ctx->header_www_authenticate	= header_www_authenticate;
    ctx->state_value	= state_value;
    ctx->header_subscription_state	= header_subscription_state;
    ctx->header_event	= header_event;
    ctx->event_package	= event_package;
    ctx->header_replaces	= header_replaces;
    ctx->header_p_preferred_identity	= header_p_preferred_identity;
    ctx->header_privacy	= header_privacy;
    ctx->privacy_val	= privacy_val;
    ctx->header	= header;
    ctx->header_extension_base	= header_extension_base;
    ctx->header_name	= header_name;
    ctx->header_value	= header_value;
    ctx->message_body	= message_body;
    ctx->paramless_uri	= paramless_uri;
    ctx->uri	= uri;
    ctx->sip_token	= sip_token;
    ctx->sips_token	= sips_token;
    ctx->sip_schema	= sip_schema;
    ctx->userinfo	= userinfo;
    ctx->user	= user;
    ctx->password	= password;
    ctx->hostport	= hostport;
    ctx->uri_parameters	= uri_parameters;
    ctx->uri_parameter	= uri_parameter;
    ctx->other_param	= other_param;
    ctx->pname	= pname;
    ctx->pvalue	= pvalue;
    ctx->paramchar	= paramchar;
    ctx->param_unreserved	= param_unreserved;
    ctx->headers	= headers;
    ctx->uri_header	= uri_header;
    ctx->hname	= hname;
    ctx->hvalue	= hvalue;
    ctx->hnv_unreserved	= hnv_unreserved;
    ctx->user_unreserved	= user_unreserved;
    ctx->host	= host;
    ctx->hostname	= hostname;
    ctx->domainlabel	= domainlabel;
    ctx->toplabel	= toplabel;
    ctx->ipv4address	= ipv4address;
    ctx->ipv6reference	= ipv6reference;
    ctx->ipv6address	= ipv6address;
    ctx->hexpart	= hexpart;
    ctx->hexseq	= hexseq;
    ctx->hex4	= hex4;
    ctx->port	= port;
    ctx->escaped	= escaped;
    ctx->ttl	= ttl;
    ctx->three_digit	= three_digit;
    ctx->token	= token;
    ctx->reserved_for_from_to_contact_addr_spec	= reserved_for_from_to_contact_addr_spec;
    ctx->reserved	= reserved;
    ctx->unreserved	= unreserved;
    ctx->alphanum	= alphanum;
    ctx->hexdigit	= hexdigit;
    ctx->alpha	= alpha;
    ctx->word	= word;
    ctx->mark	= mark;
    ctx->sp_tab_colon	= sp_tab_colon;
    ctx->hcolon	= hcolon;
    ctx->ldquot	= ldquot;
    ctx->rdquot	= rdquot;
    ctx->semi	= semi;
    ctx->comma	= comma;
    ctx->sp_laquot	= sp_laquot;
    ctx->raquot_sp	= raquot_sp;
    ctx->equal	= equal;
    ctx->slash	= slash;
    ctx->lws	= lws;
    ctx->synpred1_belle_sip_message	= synpred1_belle_sip_message;
    ctx->synpred2_belle_sip_message	= synpred2_belle_sip_message;
    ctx->synpred3_belle_sip_message	= synpred3_belle_sip_message;
    ctx->synpred4_belle_sip_message	= synpred4_belle_sip_message;
    ctx->synpred6_belle_sip_message	= synpred6_belle_sip_message;
    ctx->synpred7_belle_sip_message	= synpred7_belle_sip_message;
    ctx->synpred8_belle_sip_message	= synpred8_belle_sip_message;
    ctx->synpred9_belle_sip_message	= synpred9_belle_sip_message;
    ctx->synpred10_belle_sip_message	= synpred10_belle_sip_message;
    ctx->synpred11_belle_sip_message	= synpred11_belle_sip_message;
    ctx->synpred12_belle_sip_message	= synpred12_belle_sip_message;
    ctx->synpred13_belle_sip_message	= synpred13_belle_sip_message;
    ctx->synpred14_belle_sip_message	= synpred14_belle_sip_message;
    ctx->synpred15_belle_sip_message	= synpred15_belle_sip_message;
    ctx->free			= belle_sip_messageParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_messagePush     = pbelle_sip_messageParser_messagePush;
    ctx->pbelle_sip_messageParser_messageStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_messageStack_limit    = 0;
    ctx->pbelle_sip_messageParser_messageTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_message_rawPush     = pbelle_sip_messageParser_message_rawPush;
    ctx->pbelle_sip_messageParser_message_rawStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_message_rawStack_limit    = 0;
    ctx->pbelle_sip_messageParser_message_rawTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_common_requestPush     = pbelle_sip_messageParser_common_requestPush;
    ctx->pbelle_sip_messageParser_common_requestStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_common_requestStack_limit    = 0;
    ctx->pbelle_sip_messageParser_common_requestTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_request_linePush     = pbelle_sip_messageParser_request_linePush;
    ctx->pbelle_sip_messageParser_request_lineStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_request_lineStack_limit    = 0;
    ctx->pbelle_sip_messageParser_request_lineTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_status_linePush     = pbelle_sip_messageParser_status_linePush;
    ctx->pbelle_sip_messageParser_status_lineStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_status_lineStack_limit    = 0;
    ctx->pbelle_sip_messageParser_status_lineTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_http_request_linePush     = pbelle_sip_messageParser_http_request_linePush;
    ctx->pbelle_sip_messageParser_http_request_lineStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_http_request_lineStack_limit    = 0;
    ctx->pbelle_sip_messageParser_http_request_lineTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPush     = pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPush;
    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack_limit    = 0;
    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_uriPush     = pbelle_sip_messageParser_generic_uriPush;
    ctx->pbelle_sip_messageParser_generic_uriStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_generic_uriStack_limit    = 0;
    ctx->pbelle_sip_messageParser_generic_uriTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_authority_userinfoPush     = pbelle_sip_messageParser_authority_userinfoPush;
    ctx->pbelle_sip_messageParser_authority_userinfoStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_authority_userinfoStack_limit    = 0;
    ctx->pbelle_sip_messageParser_authority_userinfoTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_authority_hostportPush     = pbelle_sip_messageParser_authority_hostportPush;
    ctx->pbelle_sip_messageParser_authority_hostportStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_authority_hostportStack_limit    = 0;
    ctx->pbelle_sip_messageParser_authority_hostportTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_paramPush     = pbelle_sip_messageParser_generic_paramPush;
    ctx->pbelle_sip_messageParser_generic_paramStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_generic_paramStack_limit    = 0;
    ctx->pbelle_sip_messageParser_generic_paramTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_allowPush     = pbelle_sip_messageParser_header_allowPush;
    ctx->pbelle_sip_messageParser_header_allowStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_allowStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_allowTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_authorizationPush     = pbelle_sip_messageParser_header_authorizationPush;
    ctx->pbelle_sip_messageParser_header_authorizationStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_authorizationStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_authorizationTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_call_idPush     = pbelle_sip_messageParser_header_call_idPush;
    ctx->pbelle_sip_messageParser_header_call_idStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_call_idStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_call_idTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_contactPush     = pbelle_sip_messageParser_header_contactPush;
    ctx->pbelle_sip_messageParser_header_contactStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_contactStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_contactTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_contact_paramPush     = pbelle_sip_messageParser_contact_paramPush;
    ctx->pbelle_sip_messageParser_contact_paramStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_contact_paramStack_limit    = 0;
    ctx->pbelle_sip_messageParser_contact_paramTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_lengthPush     = pbelle_sip_messageParser_header_content_lengthPush;
    ctx->pbelle_sip_messageParser_header_content_lengthStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_content_lengthStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_content_lengthTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_typePush     = pbelle_sip_messageParser_header_content_typePush;
    ctx->pbelle_sip_messageParser_header_content_typeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_content_typeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_content_typeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_cseqPush     = pbelle_sip_messageParser_header_cseqPush;
    ctx->pbelle_sip_messageParser_header_cseqStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_cseqStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_cseqTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_datePush     = pbelle_sip_messageParser_header_datePush;
    ctx->pbelle_sip_messageParser_header_dateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_dateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_dateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_expiresPush     = pbelle_sip_messageParser_header_expiresPush;
    ctx->pbelle_sip_messageParser_header_expiresStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_expiresStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_expiresTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_fromPush     = pbelle_sip_messageParser_header_fromPush;
    ctx->pbelle_sip_messageParser_header_fromStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_fromStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_fromTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_max_forwardsPush     = pbelle_sip_messageParser_header_max_forwardsPush;
    ctx->pbelle_sip_messageParser_header_max_forwardsStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_max_forwardsStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_max_forwardsTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authenticatePush     = pbelle_sip_messageParser_header_proxy_authenticatePush;
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_proxy_authenticateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_qop_optsPush     = pbelle_sip_messageParser_qop_optsPush;
    ctx->pbelle_sip_messageParser_qop_optsStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_qop_optsStack_limit    = 0;
    ctx->pbelle_sip_messageParser_qop_optsTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authorizationPush     = pbelle_sip_messageParser_header_proxy_authorizationPush;
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_proxy_authorizationTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_service_routePush     = pbelle_sip_messageParser_header_service_routePush;
    ctx->pbelle_sip_messageParser_header_service_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_service_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_service_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_srv_routePush     = pbelle_sip_messageParser_srv_routePush;
    ctx->pbelle_sip_messageParser_srv_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_srv_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_srv_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_record_routePush     = pbelle_sip_messageParser_header_record_routePush;
    ctx->pbelle_sip_messageParser_header_record_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_record_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_record_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_rec_routePush     = pbelle_sip_messageParser_rec_routePush;
    ctx->pbelle_sip_messageParser_rec_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_rec_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_rec_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_routePush     = pbelle_sip_messageParser_header_routePush;
    ctx->pbelle_sip_messageParser_header_routeStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_routeStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_routeTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_route_paramPush     = pbelle_sip_messageParser_route_paramPush;
    ctx->pbelle_sip_messageParser_route_paramStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_route_paramStack_limit    = 0;
    ctx->pbelle_sip_messageParser_route_paramTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_toPush     = pbelle_sip_messageParser_header_toPush;
    ctx->pbelle_sip_messageParser_header_toStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_toStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_toTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_user_agentPush     = pbelle_sip_messageParser_header_user_agentPush;
    ctx->pbelle_sip_messageParser_header_user_agentStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_user_agentStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_user_agentTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_viaPush     = pbelle_sip_messageParser_header_viaPush;
    ctx->pbelle_sip_messageParser_header_viaStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_viaStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_viaTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_via_parmPush     = pbelle_sip_messageParser_via_parmPush;
    ctx->pbelle_sip_messageParser_via_parmStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_via_parmStack_limit    = 0;
    ctx->pbelle_sip_messageParser_via_parmTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_www_authenticatePush     = pbelle_sip_messageParser_header_www_authenticatePush;
    ctx->pbelle_sip_messageParser_header_www_authenticateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_www_authenticateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_www_authenticateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_subscription_statePush     = pbelle_sip_messageParser_header_subscription_statePush;
    ctx->pbelle_sip_messageParser_header_subscription_stateStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_subscription_stateStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_subscription_stateTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_eventPush     = pbelle_sip_messageParser_header_eventPush;
    ctx->pbelle_sip_messageParser_header_eventStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_eventStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_eventTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_replacesPush     = pbelle_sip_messageParser_header_replacesPush;
    ctx->pbelle_sip_messageParser_header_replacesStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_replacesStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_replacesTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_privacyPush     = pbelle_sip_messageParser_header_privacyPush;
    ctx->pbelle_sip_messageParser_header_privacyStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_privacyStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_privacyTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_extension_basePush     = pbelle_sip_messageParser_header_extension_basePush;
    ctx->pbelle_sip_messageParser_header_extension_baseStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_header_extension_baseStack_limit    = 0;
    ctx->pbelle_sip_messageParser_header_extension_baseTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_paramless_uriPush     = pbelle_sip_messageParser_paramless_uriPush;
    ctx->pbelle_sip_messageParser_paramless_uriStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_paramless_uriStack_limit    = 0;
    ctx->pbelle_sip_messageParser_paramless_uriTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uriPush     = pbelle_sip_messageParser_uriPush;
    ctx->pbelle_sip_messageParser_uriStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_uriStack_limit    = 0;
    ctx->pbelle_sip_messageParser_uriTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_userinfoPush     = pbelle_sip_messageParser_userinfoPush;
    ctx->pbelle_sip_messageParser_userinfoStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_userinfoStack_limit    = 0;
    ctx->pbelle_sip_messageParser_userinfoTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostportPush     = pbelle_sip_messageParser_hostportPush;
    ctx->pbelle_sip_messageParser_hostportStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_hostportStack_limit    = 0;
    ctx->pbelle_sip_messageParser_hostportTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uri_parametersPush     = pbelle_sip_messageParser_uri_parametersPush;
    ctx->pbelle_sip_messageParser_uri_parametersStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_uri_parametersStack_limit    = 0;
    ctx->pbelle_sip_messageParser_uri_parametersTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_headersPush     = pbelle_sip_messageParser_headersPush;
    ctx->pbelle_sip_messageParser_headersStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_headersStack_limit    = 0;
    ctx->pbelle_sip_messageParser_headersTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uri_headerPush     = pbelle_sip_messageParser_uri_headerPush;
    ctx->pbelle_sip_messageParser_uri_headerStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_uri_headerStack_limit    = 0;
    ctx->pbelle_sip_messageParser_uri_headerTop      = NULL;
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostPush     = pbelle_sip_messageParser_hostPush;
    ctx->pbelle_sip_messageParser_hostStack    = antlr3StackNew(0);
    ctx->pbelle_sip_messageParser_hostStack_limit    = 0;
    ctx->pbelle_sip_messageParser_hostTop      = NULL;


        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = belle_sip_messageParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 belle_sip_messageParserFree(pbelle_sip_messageParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_messageStack->free(ctx->pbelle_sip_messageParser_messageStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_message_rawStack->free(ctx->pbelle_sip_messageParser_message_rawStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_common_requestStack->free(ctx->pbelle_sip_messageParser_common_requestStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_request_lineStack->free(ctx->pbelle_sip_messageParser_request_lineStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_status_lineStack->free(ctx->pbelle_sip_messageParser_status_lineStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_http_request_lineStack->free(ctx->pbelle_sip_messageParser_http_request_lineStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack->free(ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_uriStack->free(ctx->pbelle_sip_messageParser_generic_uriStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_authority_userinfoStack->free(ctx->pbelle_sip_messageParser_authority_userinfoStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_authority_hostportStack->free(ctx->pbelle_sip_messageParser_authority_hostportStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_generic_paramStack->free(ctx->pbelle_sip_messageParser_generic_paramStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_allowStack->free(ctx->pbelle_sip_messageParser_header_allowStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_authorizationStack->free(ctx->pbelle_sip_messageParser_header_authorizationStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_call_idStack->free(ctx->pbelle_sip_messageParser_header_call_idStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_contactStack->free(ctx->pbelle_sip_messageParser_header_contactStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_contact_paramStack->free(ctx->pbelle_sip_messageParser_contact_paramStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_lengthStack->free(ctx->pbelle_sip_messageParser_header_content_lengthStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_content_typeStack->free(ctx->pbelle_sip_messageParser_header_content_typeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_cseqStack->free(ctx->pbelle_sip_messageParser_header_cseqStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_dateStack->free(ctx->pbelle_sip_messageParser_header_dateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_expiresStack->free(ctx->pbelle_sip_messageParser_header_expiresStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_fromStack->free(ctx->pbelle_sip_messageParser_header_fromStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_max_forwardsStack->free(ctx->pbelle_sip_messageParser_header_max_forwardsStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authenticateStack->free(ctx->pbelle_sip_messageParser_header_proxy_authenticateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_qop_optsStack->free(ctx->pbelle_sip_messageParser_qop_optsStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_proxy_authorizationStack->free(ctx->pbelle_sip_messageParser_header_proxy_authorizationStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_service_routeStack->free(ctx->pbelle_sip_messageParser_header_service_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_srv_routeStack->free(ctx->pbelle_sip_messageParser_srv_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_record_routeStack->free(ctx->pbelle_sip_messageParser_header_record_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_rec_routeStack->free(ctx->pbelle_sip_messageParser_rec_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_routeStack->free(ctx->pbelle_sip_messageParser_header_routeStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_route_paramStack->free(ctx->pbelle_sip_messageParser_route_paramStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_toStack->free(ctx->pbelle_sip_messageParser_header_toStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_user_agentStack->free(ctx->pbelle_sip_messageParser_header_user_agentStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_viaStack->free(ctx->pbelle_sip_messageParser_header_viaStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_via_parmStack->free(ctx->pbelle_sip_messageParser_via_parmStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_www_authenticateStack->free(ctx->pbelle_sip_messageParser_header_www_authenticateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_subscription_stateStack->free(ctx->pbelle_sip_messageParser_header_subscription_stateStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_eventStack->free(ctx->pbelle_sip_messageParser_header_eventStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_replacesStack->free(ctx->pbelle_sip_messageParser_header_replacesStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_privacyStack->free(ctx->pbelle_sip_messageParser_header_privacyStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_header_extension_baseStack->free(ctx->pbelle_sip_messageParser_header_extension_baseStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_paramless_uriStack->free(ctx->pbelle_sip_messageParser_paramless_uriStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uriStack->free(ctx->pbelle_sip_messageParser_uriStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_userinfoStack->free(ctx->pbelle_sip_messageParser_userinfoStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostportStack->free(ctx->pbelle_sip_messageParser_hostportStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uri_parametersStack->free(ctx->pbelle_sip_messageParser_uri_parametersStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_headersStack->free(ctx->pbelle_sip_messageParser_headersStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_uri_headerStack->free(ctx->pbelle_sip_messageParser_uri_headerStack);
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sip_messageParser_hostStack->free(ctx->pbelle_sip_messageParser_hostStack);

    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return belle_sip_messageParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_raw_in_message76  */
static	ANTLR3_BITWORD FOLLOW_message_raw_in_message76_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_message_raw_in_message76	= { FOLLOW_message_raw_in_message76_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_request_in_message_raw107  */
static	ANTLR3_BITWORD FOLLOW_common_request_in_message_raw107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_common_request_in_message_raw107	= { FOLLOW_common_request_in_message_raw107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_response_in_message_raw118  */
static	ANTLR3_BITWORD FOLLOW_common_response_in_message_raw118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_common_response_in_message_raw118	= { FOLLOW_common_response_in_message_raw118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_request_in_request135  */
static	ANTLR3_BITWORD FOLLOW_common_request_in_request135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_common_request_in_request135	= { FOLLOW_common_request_in_request135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_request_line_in_common_request188  */
static	ANTLR3_BITWORD FOLLOW_request_line_in_common_request188_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_request_line_in_common_request188	= { FOLLOW_request_line_in_common_request188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_http_request_line_in_common_request216  */
static	ANTLR3_BITWORD FOLLOW_http_request_line_in_common_request216_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_http_request_line_in_common_request216	= { FOLLOW_http_request_line_in_common_request216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_header_in_common_request223  */
static	ANTLR3_BITWORD FOLLOW_message_header_in_common_request223_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42190) };
static  ANTLR3_BITSET_LIST FOLLOW_message_header_in_common_request223	= { FOLLOW_message_header_in_common_request223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_common_request229  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_common_request229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_common_request229	= { FOLLOW_CRLF_in_common_request229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_request_line261  */
static	ANTLR3_BITWORD FOLLOW_method_in_request_line261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_request_line261	= { FOLLOW_method_in_request_line261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_request_line271  */
static	ANTLR3_BITWORD FOLLOW_SP_in_request_line271_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421C0) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_request_line271	= { FOLLOW_SP_in_request_line271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_request_line281  */
static	ANTLR3_BITWORD FOLLOW_uri_in_request_line281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_request_line281	= { FOLLOW_uri_in_request_line281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_uri_in_request_line301  */
static	ANTLR3_BITWORD FOLLOW_generic_uri_in_request_line301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_uri_in_request_line301	= { FOLLOW_generic_uri_in_request_line301_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_request_line319  */
static	ANTLR3_BITWORD FOLLOW_SP_in_request_line319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_request_line319	= { FOLLOW_SP_in_request_line319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_version_in_request_line327  */
static	ANTLR3_BITWORD FOLLOW_sip_version_in_request_line327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_version_in_request_line327	= { FOLLOW_sip_version_in_request_line327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_request_line335  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_request_line335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_request_line335	= { FOLLOW_CRLF_in_request_line335_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_version_in_sip_version357  */
static	ANTLR3_BITWORD FOLLOW_generic_version_in_sip_version357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_version_in_sip_version357	= { FOLLOW_generic_version_in_sip_version357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_generic_version366  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_generic_version366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000040) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_generic_version366	= { FOLLOW_alpha_in_generic_version366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_generic_version369  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_generic_version369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_generic_version369	= { FOLLOW_SLASH_in_generic_version369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_generic_version371  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_generic_version371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_generic_version371	= { FOLLOW_DIGIT_in_generic_version371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_generic_version373  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_generic_version373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_generic_version373	= { FOLLOW_DOT_in_generic_version373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_generic_version375  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_generic_version375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_generic_version375	= { FOLLOW_DIGIT_in_generic_version375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_extension_base_in_message_header451  */
static	ANTLR3_BITWORD FOLLOW_header_extension_base_in_message_header451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_header_extension_base_in_message_header451	= { FOLLOW_header_extension_base_in_message_header451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_message_header475  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_message_header475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_message_header475	= { FOLLOW_CRLF_in_message_header475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_method_in_method522  */
static	ANTLR3_BITWORD FOLLOW_extension_method_in_method522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_method_in_method522	= { FOLLOW_extension_method_in_method522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_extension_method536  */
static	ANTLR3_BITWORD FOLLOW_token_in_extension_method536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_extension_method536	= { FOLLOW_token_in_extension_method536_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_status_line_in_common_response573  */
static	ANTLR3_BITWORD FOLLOW_status_line_in_common_response573_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42182) };
static  ANTLR3_BITSET_LIST FOLLOW_status_line_in_common_response573	= { FOLLOW_status_line_in_common_response573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_http_status_line_in_common_response604  */
static	ANTLR3_BITWORD FOLLOW_http_status_line_in_common_response604_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42182) };
static  ANTLR3_BITSET_LIST FOLLOW_http_status_line_in_common_response604	= { FOLLOW_http_status_line_in_common_response604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_header_in_common_response612  */
static	ANTLR3_BITWORD FOLLOW_message_header_in_common_response612_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42190) };
static  ANTLR3_BITSET_LIST FOLLOW_message_header_in_common_response612	= { FOLLOW_message_header_in_common_response612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_common_response618  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_common_response618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_common_response618	= { FOLLOW_CRLF_in_common_response618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_response_in_response642  */
static	ANTLR3_BITWORD FOLLOW_common_response_in_response642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_common_response_in_response642	= { FOLLOW_common_response_in_response642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_version_in_status_line673  */
static	ANTLR3_BITWORD FOLLOW_sip_version_in_status_line673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_version_in_status_line673	= { FOLLOW_sip_version_in_status_line673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_status_line680  */
static	ANTLR3_BITWORD FOLLOW_SP_in_status_line680_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_status_line680	= { FOLLOW_SP_in_status_line680_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_status_code_in_status_line682  */
static	ANTLR3_BITWORD FOLLOW_status_code_in_status_line682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_status_code_in_status_line682	= { FOLLOW_status_code_in_status_line682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_status_line690  */
static	ANTLR3_BITWORD FOLLOW_SP_in_status_line690_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_status_line690	= { FOLLOW_SP_in_status_line690_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reason_phrase_in_status_line692  */
static	ANTLR3_BITWORD FOLLOW_reason_phrase_in_status_line692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_reason_phrase_in_status_line692	= { FOLLOW_reason_phrase_in_status_line692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_status_line700  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_status_line700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_status_line700	= { FOLLOW_CRLF_in_status_line700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_code_in_status_code724  */
static	ANTLR3_BITWORD FOLLOW_extension_code_in_status_code724_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_code_in_status_code724	= { FOLLOW_extension_code_in_status_code724_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_extension_code737  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_extension_code737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_extension_code737	= { FOLLOW_DIGIT_in_extension_code737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_extension_code739  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_extension_code739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_extension_code739	= { FOLLOW_DIGIT_in_extension_code739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_extension_code741  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_extension_code741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_extension_code741	= { FOLLOW_DIGIT_in_extension_code741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_reason_phrase754  */
static	ANTLR3_BITWORD FOLLOW_set_in_reason_phrase754_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFE2) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_reason_phrase754	= { FOLLOW_set_in_reason_phrase754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_request_in_http_request777  */
static	ANTLR3_BITWORD FOLLOW_common_request_in_http_request777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_common_request_in_http_request777	= { FOLLOW_common_request_in_http_request777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_http_request_line805  */
static	ANTLR3_BITWORD FOLLOW_method_in_http_request_line805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_http_request_line805	= { FOLLOW_method_in_http_request_line805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_http_request_line814  */
static	ANTLR3_BITWORD FOLLOW_SP_in_http_request_line814_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421C0) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_http_request_line814	= { FOLLOW_SP_in_http_request_line814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_uri_in_http_request_line825  */
static	ANTLR3_BITWORD FOLLOW_generic_uri_in_http_request_line825_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_uri_in_http_request_line825	= { FOLLOW_generic_uri_in_http_request_line825_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_http_request_line833  */
static	ANTLR3_BITWORD FOLLOW_SP_in_http_request_line833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_http_request_line833	= { FOLLOW_SP_in_http_request_line833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_http_version_in_http_request_line840  */
static	ANTLR3_BITWORD FOLLOW_http_version_in_http_request_line840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_http_version_in_http_request_line840	= { FOLLOW_http_version_in_http_request_line840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_http_request_line842  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_http_request_line842_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_http_request_line842	= { FOLLOW_CRLF_in_http_request_line842_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_version_in_http_version859  */
static	ANTLR3_BITWORD FOLLOW_generic_version_in_http_version859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_version_in_http_version859	= { FOLLOW_generic_version_in_http_version859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_common_response_in_http_response876  */
static	ANTLR3_BITWORD FOLLOW_common_response_in_http_response876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_common_response_in_http_response876	= { FOLLOW_common_response_in_http_response876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_http_version_in_http_status_line906  */
static	ANTLR3_BITWORD FOLLOW_http_version_in_http_status_line906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_http_version_in_http_status_line906	= { FOLLOW_http_version_in_http_status_line906_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_http_status_line914  */
static	ANTLR3_BITWORD FOLLOW_SP_in_http_status_line914_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_http_status_line914	= { FOLLOW_SP_in_http_status_line914_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_status_code_in_http_status_line916  */
static	ANTLR3_BITWORD FOLLOW_status_code_in_http_status_line916_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_status_code_in_http_status_line916	= { FOLLOW_status_code_in_http_status_line916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_http_status_line925  */
static	ANTLR3_BITWORD FOLLOW_SP_in_http_status_line925_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_http_status_line925	= { FOLLOW_SP_in_http_status_line925_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reason_phrase_in_http_status_line927  */
static	ANTLR3_BITWORD FOLLOW_reason_phrase_in_http_status_line927_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_reason_phrase_in_http_status_line927	= { FOLLOW_reason_phrase_in_http_status_line927_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_http_status_line936  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_http_status_line936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_http_status_line936	= { FOLLOW_CRLF_in_http_status_line936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec966  */
static	ANTLR3_BITWORD FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec966_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E47FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec966	= { FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uric_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec968  */
static	ANTLR3_BITWORD FOLLOW_uric_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec968_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E47FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_uric_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec968	= { FOLLOW_uric_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uric_no_slash_in_opaque_part978  */
static	ANTLR3_BITWORD FOLLOW_uric_no_slash_in_opaque_part978_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_uric_no_slash_in_opaque_part978	= { FOLLOW_uric_no_slash_in_opaque_part978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uric_in_opaque_part980  */
static	ANTLR3_BITWORD FOLLOW_uric_in_opaque_part980_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_uric_in_opaque_part980	= { FOLLOW_uric_in_opaque_part980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_uric_no_slash_for_from_to_contact_addr_spec991  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_uric_no_slash_for_from_to_contact_addr_spec991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_uric_no_slash_for_from_to_contact_addr_spec991	= { FOLLOW_unreserved_in_uric_no_slash_for_from_to_contact_addr_spec991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_uric_no_slash_for_from_to_contact_addr_spec995  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_uric_no_slash_for_from_to_contact_addr_spec995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_uric_no_slash_for_from_to_contact_addr_spec995	= { FOLLOW_escaped_in_uric_no_slash_for_from_to_contact_addr_spec995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_uric_no_slash_for_from_to_contact_addr_spec1000  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_uric_no_slash_for_from_to_contact_addr_spec1000_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_uric_no_slash_for_from_to_contact_addr_spec1000	= { FOLLOW_COLON_in_uric_no_slash_for_from_to_contact_addr_spec1000_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_uric_no_slash_for_from_to_contact_addr_spec1004  */
static	ANTLR3_BITWORD FOLLOW_AT_in_uric_no_slash_for_from_to_contact_addr_spec1004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_uric_no_slash_for_from_to_contact_addr_spec1004	= { FOLLOW_AT_in_uric_no_slash_for_from_to_contact_addr_spec1004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_uric_no_slash_for_from_to_contact_addr_spec1007  */
static	ANTLR3_BITWORD FOLLOW_AND_in_uric_no_slash_for_from_to_contact_addr_spec1007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_uric_no_slash_for_from_to_contact_addr_spec1007	= { FOLLOW_AND_in_uric_no_slash_for_from_to_contact_addr_spec1007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_uric_no_slash_for_from_to_contact_addr_spec1011  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_uric_no_slash_for_from_to_contact_addr_spec1011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_uric_no_slash_for_from_to_contact_addr_spec1011	= { FOLLOW_EQUAL_in_uric_no_slash_for_from_to_contact_addr_spec1011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_uric_no_slash_for_from_to_contact_addr_spec1015  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_uric_no_slash_for_from_to_contact_addr_spec1015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_uric_no_slash_for_from_to_contact_addr_spec1015	= { FOLLOW_PLUS_in_uric_no_slash_for_from_to_contact_addr_spec1015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOLLARD_in_uric_no_slash_for_from_to_contact_addr_spec1019  */
static	ANTLR3_BITWORD FOLLOW_DOLLARD_in_uric_no_slash_for_from_to_contact_addr_spec1019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOLLARD_in_uric_no_slash_for_from_to_contact_addr_spec1019	= { FOLLOW_DOLLARD_in_uric_no_slash_for_from_to_contact_addr_spec1019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_uric_no_slash1027  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_uric_no_slash1027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_uric_no_slash1027	= { FOLLOW_COMMA_in_uric_no_slash1027_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_uric_no_slash1031  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_uric_no_slash1031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_uric_no_slash1031	= { FOLLOW_SEMI_in_uric_no_slash1031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QMARK_in_uric_no_slash1035  */
static	ANTLR3_BITWORD FOLLOW_QMARK_in_uric_no_slash1035_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QMARK_in_uric_no_slash1035	= { FOLLOW_QMARK_in_uric_no_slash1035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_uric_no_slash1040  */
static	ANTLR3_BITWORD FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_uric_no_slash1040_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_uric_no_slash1040	= { FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_uric_no_slash1040_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_scheme1067  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_scheme1067_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060042182) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_scheme1067	= { FOLLOW_alpha_in_scheme1067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_scheme1071  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_scheme1071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060042182) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_scheme1071	= { FOLLOW_alphanum_in_scheme1071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_scheme1075  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_scheme1075_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060042182) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_scheme1075	= { FOLLOW_PLUS_in_scheme1075_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_scheme1079  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_scheme1079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060042182) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_scheme1079	= { FOLLOW_DASH_in_scheme1079_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_scheme1083  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_scheme1083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060042182) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_scheme1083	= { FOLLOW_DOT_in_scheme1083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scheme_in_generic_uri_for_from_to_contact_addr_spec1117  */
static	ANTLR3_BITWORD FOLLOW_scheme_in_generic_uri_for_from_to_contact_addr_spec1117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_scheme_in_generic_uri_for_from_to_contact_addr_spec1117	= { FOLLOW_scheme_in_generic_uri_for_from_to_contact_addr_spec1117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_generic_uri_for_from_to_contact_addr_spec1126  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_generic_uri_for_from_to_contact_addr_spec1126_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E47FC0) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_generic_uri_for_from_to_contact_addr_spec1126	= { FOLLOW_COLON_in_generic_uri_for_from_to_contact_addr_spec1126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_opaque_part_for_from_to_contact_addr_spec_in_generic_uri_for_from_to_contact_addr_spec1129  */
static	ANTLR3_BITWORD FOLLOW_opaque_part_for_from_to_contact_addr_spec_in_generic_uri_for_from_to_contact_addr_spec1129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_opaque_part_for_from_to_contact_addr_spec_in_generic_uri_for_from_to_contact_addr_spec1129	= { FOLLOW_opaque_part_for_from_to_contact_addr_spec_in_generic_uri_for_from_to_contact_addr_spec1129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hier_part_in_generic_uri1171  */
static	ANTLR3_BITWORD FOLLOW_hier_part_in_generic_uri1171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hier_part_in_generic_uri1171	= { FOLLOW_hier_part_in_generic_uri1171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_scheme_in_generic_uri1183  */
static	ANTLR3_BITWORD FOLLOW_scheme_in_generic_uri1183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_scheme_in_generic_uri1183	= { FOLLOW_scheme_in_generic_uri1183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_generic_uri1196  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_generic_uri1196_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_generic_uri1196	= { FOLLOW_COLON_in_generic_uri1196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_opaque_part_in_generic_uri1200  */
static	ANTLR3_BITWORD FOLLOW_opaque_part_in_generic_uri1200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_opaque_part_in_generic_uri1200	= { FOLLOW_opaque_part_in_generic_uri1200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hier_part_in_generic_uri1214  */
static	ANTLR3_BITWORD FOLLOW_hier_part_in_generic_uri1214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hier_part_in_generic_uri1214	= { FOLLOW_hier_part_in_generic_uri1214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_hier_part1263  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_hier_part1263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_hier_part1263	= { FOLLOW_SLASH_in_hier_part1263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_hier_part1265  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_hier_part1265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_hier_part1265	= { FOLLOW_SLASH_in_hier_part1265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_segments_in_hier_part1267  */
static	ANTLR3_BITWORD FOLLOW_path_segments_in_hier_part1267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_segments_in_hier_part1267	= { FOLLOW_path_segments_in_hier_part1267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_hier_part1295  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_hier_part1295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_hier_part1295	= { FOLLOW_SLASH_in_hier_part1295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_hier_part1297  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_hier_part1297_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_hier_part1297	= { FOLLOW_SLASH_in_hier_part1297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authority_in_hier_part1299  */
static	ANTLR3_BITWORD FOLLOW_authority_in_hier_part1299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020042) };
static  ANTLR3_BITSET_LIST FOLLOW_authority_in_hier_part1299	= { FOLLOW_authority_in_hier_part1299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_segments_in_hier_part1303  */
static	ANTLR3_BITWORD FOLLOW_path_segments_in_hier_part1303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_segments_in_hier_part1303	= { FOLLOW_path_segments_in_hier_part1303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_segments_in_hier_part1319  */
static	ANTLR3_BITWORD FOLLOW_path_segments_in_hier_part1319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_segments_in_hier_part1319	= { FOLLOW_path_segments_in_hier_part1319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QMARK_in_hier_part1329  */
static	ANTLR3_BITWORD FOLLOW_QMARK_in_hier_part1329_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_QMARK_in_hier_part1329	= { FOLLOW_QMARK_in_hier_part1329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_hier_part1331  */
static	ANTLR3_BITWORD FOLLOW_query_in_hier_part1331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_hier_part1331	= { FOLLOW_query_in_hier_part1331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_path_segments1360  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_path_segments1360_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E5FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_path_segments1360	= { FOLLOW_SLASH_in_path_segments1360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_segment_in_path_segments1363  */
static	ANTLR3_BITWORD FOLLOW_segment_in_path_segments1363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_segment_in_path_segments1363	= { FOLLOW_segment_in_path_segments1363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_path_segments1367  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_path_segments1367_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E5FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_path_segments1367	= { FOLLOW_SLASH_in_path_segments1367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_segment_in_path_segments1369  */
static	ANTLR3_BITWORD FOLLOW_segment_in_path_segments1369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_segment_in_path_segments1369	= { FOLLOW_segment_in_path_segments1369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pchar_in_segment1383  */
static	ANTLR3_BITWORD FOLLOW_pchar_in_segment1383_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E5FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_pchar_in_segment1383	= { FOLLOW_pchar_in_segment1383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_segment1388  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_segment1388_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E5FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_segment1388	= { FOLLOW_SEMI_in_segment1388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_segment1390  */
static	ANTLR3_BITWORD FOLLOW_param_in_segment1390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_segment1390	= { FOLLOW_param_in_segment1390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pchar_in_param1399  */
static	ANTLR3_BITWORD FOLLOW_pchar_in_param1399_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_pchar_in_param1399	= { FOLLOW_pchar_in_param1399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_pchar1407  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_pchar1407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_pchar1407	= { FOLLOW_unreserved_in_pchar1407_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_pchar1411  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_pchar1411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_pchar1411	= { FOLLOW_escaped_in_pchar1411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_pchar1415  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_pchar1415_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_pchar1415	= { FOLLOW_COLON_in_pchar1415_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_pchar1419  */
static	ANTLR3_BITWORD FOLLOW_AT_in_pchar1419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_pchar1419	= { FOLLOW_AT_in_pchar1419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_pchar1423  */
static	ANTLR3_BITWORD FOLLOW_AND_in_pchar1423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_pchar1423	= { FOLLOW_AND_in_pchar1423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_pchar1427  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_pchar1427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_pchar1427	= { FOLLOW_EQUAL_in_pchar1427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_pchar1431  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_pchar1431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_pchar1431	= { FOLLOW_PLUS_in_pchar1431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOLLARD_in_pchar1435  */
static	ANTLR3_BITWORD FOLLOW_DOLLARD_in_pchar1435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOLLARD_in_pchar1435	= { FOLLOW_DOLLARD_in_pchar1435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_pchar1439  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_pchar1439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_pchar1439	= { FOLLOW_COMMA_in_pchar1439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uric_in_query1446  */
static	ANTLR3_BITWORD FOLLOW_uric_in_query1446_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_uric_in_query1446	= { FOLLOW_uric_in_query1446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reserved_in_uric1453  */
static	ANTLR3_BITWORD FOLLOW_reserved_in_uric1453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_reserved_in_uric1453	= { FOLLOW_reserved_in_uric1453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_uric1457  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_uric1457_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_uric1457	= { FOLLOW_unreserved_in_uric1457_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_uric1461  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_uric1461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_uric1461	= { FOLLOW_escaped_in_uric1461_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reserved_for_from_to_contact_addr_spec_in_uric_for_from_to_contact_addr_spec1468  */
static	ANTLR3_BITWORD FOLLOW_reserved_for_from_to_contact_addr_spec_in_uric_for_from_to_contact_addr_spec1468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_reserved_for_from_to_contact_addr_spec_in_uric_for_from_to_contact_addr_spec1468	= { FOLLOW_reserved_for_from_to_contact_addr_spec_in_uric_for_from_to_contact_addr_spec1468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_uric_for_from_to_contact_addr_spec1472  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_uric_for_from_to_contact_addr_spec1472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_uric_for_from_to_contact_addr_spec1472	= { FOLLOW_unreserved_in_uric_for_from_to_contact_addr_spec1472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_uric_for_from_to_contact_addr_spec1476  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_uric_for_from_to_contact_addr_spec1476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_uric_for_from_to_contact_addr_spec1476	= { FOLLOW_escaped_in_uric_for_from_to_contact_addr_spec1476_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authority_userinfo_in_authority1524  */
static	ANTLR3_BITWORD FOLLOW_authority_userinfo_in_authority1524_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_authority_userinfo_in_authority1524	= { FOLLOW_authority_userinfo_in_authority1524_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authority_hostport_in_authority1530  */
static	ANTLR3_BITWORD FOLLOW_authority_hostport_in_authority1530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_authority_hostport_in_authority1530	= { FOLLOW_authority_hostport_in_authority1530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authority_user_in_authority_userinfo1573  */
static	ANTLR3_BITWORD FOLLOW_authority_user_in_authority_userinfo1573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000600) };
static  ANTLR3_BITSET_LIST FOLLOW_authority_user_in_authority_userinfo1573	= { FOLLOW_authority_user_in_authority_userinfo1573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_authority_userinfo1577  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_authority_userinfo1577_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_authority_userinfo1577	= { FOLLOW_COLON_in_authority_userinfo1577_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authority_password_in_authority_userinfo1579  */
static	ANTLR3_BITWORD FOLLOW_authority_password_in_authority_userinfo1579_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_authority_password_in_authority_userinfo1579	= { FOLLOW_authority_password_in_authority_userinfo1579_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_authority_userinfo1585  */
static	ANTLR3_BITWORD FOLLOW_AT_in_authority_userinfo1585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_authority_userinfo1585	= { FOLLOW_AT_in_authority_userinfo1585_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_authority_user1608  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_authority_user1608_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_authority_user1608	= { FOLLOW_unreserved_in_authority_user1608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_authority_user1613  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_authority_user1613_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_authority_user1613	= { FOLLOW_escaped_in_authority_user1613_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_user_unreserved_in_authority_user1617  */
static	ANTLR3_BITWORD FOLLOW_user_unreserved_in_authority_user1617_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_user_unreserved_in_authority_user1617	= { FOLLOW_user_unreserved_in_authority_user1617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_authority_password1641  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_authority_password1641_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_authority_password1641	= { FOLLOW_unreserved_in_authority_password1641_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_authority_password1645  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_authority_password1645_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_authority_password1645	= { FOLLOW_escaped_in_authority_password1645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_authority_password1649  */
static	ANTLR3_BITWORD FOLLOW_AND_in_authority_password1649_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_authority_password1649	= { FOLLOW_AND_in_authority_password1649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_authority_password1653  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_authority_password1653_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_authority_password1653	= { FOLLOW_EQUAL_in_authority_password1653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_authority_password1657  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_authority_password1657_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_authority_password1657	= { FOLLOW_PLUS_in_authority_password1657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOLLARD_in_authority_password1661  */
static	ANTLR3_BITWORD FOLLOW_DOLLARD_in_authority_password1661_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_DOLLARD_in_authority_password1661	= { FOLLOW_DOLLARD_in_authority_password1661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_authority_password1665  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_authority_password1665_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_authority_password1665	= { FOLLOW_COMMA_in_authority_password1665_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_host_in_authority_hostport1698  */
static	ANTLR3_BITWORD FOLLOW_host_in_authority_hostport1698_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_host_in_authority_hostport1698	= { FOLLOW_host_in_authority_hostport1698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_authority_hostport1702  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_authority_hostport1702_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_authority_hostport1702	= { FOLLOW_COLON_in_authority_hostport1702_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_in_authority_hostport1704  */
static	ANTLR3_BITWORD FOLLOW_port_in_authority_hostport1704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_port_in_authority_hostport1704	= { FOLLOW_port_in_authority_hostport1704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_generic_param1743  */
static	ANTLR3_BITWORD FOLLOW_token_in_generic_param1743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001032) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_generic_param1743	= { FOLLOW_token_in_generic_param1743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_generic_param1748  */
static	ANTLR3_BITWORD FOLLOW_equal_in_generic_param1748_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_generic_param1748	= { FOLLOW_equal_in_generic_param1748_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gen_value_in_generic_param1750  */
static	ANTLR3_BITWORD FOLLOW_gen_value_in_generic_param1750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gen_value_in_generic_param1750	= { FOLLOW_gen_value_in_generic_param1750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_gen_value1774  */
static	ANTLR3_BITWORD FOLLOW_token_in_gen_value1774_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_gen_value1774	= { FOLLOW_token_in_gen_value1774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_gen_value1779  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_gen_value1779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_gen_value1779	= { FOLLOW_quoted_string_in_gen_value1779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_quoted_string1801  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_quoted_string1801_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_quoted_string1801	= { FOLLOW_DQUOTE_in_quoted_string1801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_quoted_string1804  */
static	ANTLR3_BITWORD FOLLOW_set_in_quoted_string1804_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_quoted_string1804	= { FOLLOW_set_in_quoted_string1804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BSLASH_in_quoted_string1816  */
static	ANTLR3_BITWORD FOLLOW_BSLASH_in_quoted_string1816_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_BSLASH_in_quoted_string1816	= { FOLLOW_BSLASH_in_quoted_string1816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_quoted_string1824  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_quoted_string1824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_quoted_string1824	= { FOLLOW_DQUOTE_in_quoted_string1824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_allow1865  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_allow1865_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_allow1865	= { FOLLOW_token_in_header_allow1865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_allow1869  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_allow1869_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_allow1869	= { FOLLOW_hcolon_in_header_allow1869_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_methods_in_header_allow1871  */
static	ANTLR3_BITWORD FOLLOW_methods_in_header_allow1871_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_methods_in_header_allow1871	= { FOLLOW_methods_in_header_allow1871_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_methods1889  */
static	ANTLR3_BITWORD FOLLOW_method_in_methods1889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_methods1889	= { FOLLOW_method_in_methods1889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_methods1892  */
static	ANTLR3_BITWORD FOLLOW_comma_in_methods1892_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_methods1892	= { FOLLOW_comma_in_methods1892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_methods1894  */
static	ANTLR3_BITWORD FOLLOW_method_in_methods1894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_methods1894	= { FOLLOW_method_in_methods1894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_authorization_token1904  */
static	ANTLR3_BITWORD FOLLOW_token_in_authorization_token1904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_authorization_token1904	= { FOLLOW_token_in_authorization_token1904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_digest_token1912  */
static	ANTLR3_BITWORD FOLLOW_token_in_digest_token1912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_digest_token1912	= { FOLLOW_token_in_digest_token1912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authorization_token_in_header_authorization1944  */
static	ANTLR3_BITWORD FOLLOW_authorization_token_in_header_authorization1944_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_authorization_token_in_header_authorization1944	= { FOLLOW_authorization_token_in_header_authorization1944_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_authorization1948  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_authorization1948_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_authorization1948	= { FOLLOW_hcolon_in_header_authorization1948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_credentials_in_header_authorization1950  */
static	ANTLR3_BITWORD FOLLOW_credentials_in_header_authorization1950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_credentials_in_header_authorization1950	= { FOLLOW_credentials_in_header_authorization1950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_token_in_credentials1978  */
static	ANTLR3_BITWORD FOLLOW_digest_token_in_credentials1978_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_token_in_credentials1978	= { FOLLOW_digest_token_in_credentials1978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_credentials1990  */
static	ANTLR3_BITWORD FOLLOW_lws_in_credentials1990_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_credentials1990	= { FOLLOW_lws_in_credentials1990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_response_in_credentials1992  */
static	ANTLR3_BITWORD FOLLOW_digest_response_in_credentials1992_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_response_in_credentials1992	= { FOLLOW_digest_response_in_credentials1992_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_response_in_credentials2019  */
static	ANTLR3_BITWORD FOLLOW_other_response_in_credentials2019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_response_in_credentials2019	= { FOLLOW_other_response_in_credentials2019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dig_resp_in_digest_response2036  */
static	ANTLR3_BITWORD FOLLOW_dig_resp_in_digest_response2036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_dig_resp_in_digest_response2036	= { FOLLOW_dig_resp_in_digest_response2036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_digest_response2040  */
static	ANTLR3_BITWORD FOLLOW_comma_in_digest_response2040_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_digest_response2040	= { FOLLOW_comma_in_digest_response2040_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dig_resp_in_digest_response2042  */
static	ANTLR3_BITWORD FOLLOW_dig_resp_in_digest_response2042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_dig_resp_in_digest_response2042	= { FOLLOW_dig_resp_in_digest_response2042_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_username_in_dig_resp2068  */
static	ANTLR3_BITWORD FOLLOW_username_in_dig_resp2068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_username_in_dig_resp2068	= { FOLLOW_username_in_dig_resp2068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_realm_in_dig_resp2076  */
static	ANTLR3_BITWORD FOLLOW_realm_in_dig_resp2076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_realm_in_dig_resp2076	= { FOLLOW_realm_in_dig_resp2076_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_in_dig_resp2085  */
static	ANTLR3_BITWORD FOLLOW_nonce_in_dig_resp2085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_in_dig_resp2085	= { FOLLOW_nonce_in_dig_resp2085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_uri_in_dig_resp2093  */
static	ANTLR3_BITWORD FOLLOW_digest_uri_in_dig_resp2093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_uri_in_dig_resp2093	= { FOLLOW_digest_uri_in_dig_resp2093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dresponse_in_dig_resp2100  */
static	ANTLR3_BITWORD FOLLOW_dresponse_in_dig_resp2100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dresponse_in_dig_resp2100	= { FOLLOW_dresponse_in_dig_resp2100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_algorithm_in_dig_resp2109  */
static	ANTLR3_BITWORD FOLLOW_algorithm_in_dig_resp2109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_algorithm_in_dig_resp2109	= { FOLLOW_algorithm_in_dig_resp2109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnonce_in_dig_resp2119  */
static	ANTLR3_BITWORD FOLLOW_cnonce_in_dig_resp2119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnonce_in_dig_resp2119	= { FOLLOW_cnonce_in_dig_resp2119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_opaque_in_dig_resp2126  */
static	ANTLR3_BITWORD FOLLOW_opaque_in_dig_resp2126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_opaque_in_dig_resp2126	= { FOLLOW_opaque_in_dig_resp2126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_message_qop_in_dig_resp2134  */
static	ANTLR3_BITWORD FOLLOW_message_qop_in_dig_resp2134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_message_qop_in_dig_resp2134	= { FOLLOW_message_qop_in_dig_resp2134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_count_in_dig_resp2141  */
static	ANTLR3_BITWORD FOLLOW_nonce_count_in_dig_resp2141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_count_in_dig_resp2141	= { FOLLOW_nonce_count_in_dig_resp2141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_dig_resp2149  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_dig_resp2149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_dig_resp2149	= { FOLLOW_auth_param_in_dig_resp2149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_username_token2162  */
static	ANTLR3_BITWORD FOLLOW_token_in_username_token2162_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_username_token2162	= { FOLLOW_token_in_username_token2162_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_username_token_in_username2187  */
static	ANTLR3_BITWORD FOLLOW_username_token_in_username2187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_username_token_in_username2187	= { FOLLOW_username_token_in_username2187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_username2191  */
static	ANTLR3_BITWORD FOLLOW_equal_in_username2191_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_username2191	= { FOLLOW_equal_in_username2191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_username_value_in_username2193  */
static	ANTLR3_BITWORD FOLLOW_username_value_in_username2193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_username_value_in_username2193	= { FOLLOW_username_value_in_username2193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_username_value2207  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_username_value2207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_username_value2207	= { FOLLOW_quoted_string_in_username_value2207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_uri_token2216  */
static	ANTLR3_BITWORD FOLLOW_token_in_uri_token2216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_uri_token2216	= { FOLLOW_token_in_uri_token2216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_token_in_digest_uri2237  */
static	ANTLR3_BITWORD FOLLOW_uri_token_in_digest_uri2237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_token_in_digest_uri2237	= { FOLLOW_uri_token_in_digest_uri2237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_digest_uri2241  */
static	ANTLR3_BITWORD FOLLOW_equal_in_digest_uri2241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_digest_uri2241	= { FOLLOW_equal_in_digest_uri2241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_digest_uri2243  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_digest_uri2243_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_digest_uri2243	= { FOLLOW_DQUOTE_in_digest_uri2243_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_digest_uri2245  */
static	ANTLR3_BITWORD FOLLOW_uri_in_digest_uri2245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_digest_uri2245	= { FOLLOW_uri_in_digest_uri2245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_digest_uri2247  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_digest_uri2247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_digest_uri2247	= { FOLLOW_DQUOTE_in_digest_uri2247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_message_qop2281  */
static	ANTLR3_BITWORD FOLLOW_token_in_message_qop2281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_message_qop2281	= { FOLLOW_token_in_message_qop2281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_message_qop2284  */
static	ANTLR3_BITWORD FOLLOW_equal_in_message_qop2284_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_message_qop2284	= { FOLLOW_equal_in_message_qop2284_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_value_in_message_qop2287  */
static	ANTLR3_BITWORD FOLLOW_qop_value_in_message_qop2287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_value_in_message_qop2287	= { FOLLOW_qop_value_in_message_qop2287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_qop_value2300  */
static	ANTLR3_BITWORD FOLLOW_token_in_qop_value2300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_qop_value2300	= { FOLLOW_token_in_qop_value2300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_cnonce2330  */
static	ANTLR3_BITWORD FOLLOW_token_in_cnonce2330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_cnonce2330	= { FOLLOW_token_in_cnonce2330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_cnonce2334  */
static	ANTLR3_BITWORD FOLLOW_equal_in_cnonce2334_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_cnonce2334	= { FOLLOW_equal_in_cnonce2334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnonce_value_in_cnonce2336  */
static	ANTLR3_BITWORD FOLLOW_cnonce_value_in_cnonce2336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cnonce_value_in_cnonce2336	= { FOLLOW_cnonce_value_in_cnonce2336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_value_in_cnonce_value2355  */
static	ANTLR3_BITWORD FOLLOW_nonce_value_in_cnonce_value2355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_value_in_cnonce_value2355	= { FOLLOW_nonce_value_in_cnonce_value2355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_nonce_count2379  */
static	ANTLR3_BITWORD FOLLOW_token_in_nonce_count2379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_nonce_count2379	= { FOLLOW_token_in_nonce_count2379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_nonce_count2383  */
static	ANTLR3_BITWORD FOLLOW_equal_in_nonce_count2383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000080) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_nonce_count2383	= { FOLLOW_equal_in_nonce_count2383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nc_value_in_nonce_count2385  */
static	ANTLR3_BITWORD FOLLOW_nc_value_in_nonce_count2385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nc_value_in_nonce_count2385	= { FOLLOW_nc_value_in_nonce_count2385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_huit_lhex_in_nc_value2408  */
static	ANTLR3_BITWORD FOLLOW_huit_lhex_in_nc_value2408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_huit_lhex_in_nc_value2408	= { FOLLOW_huit_lhex_in_nc_value2408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_dresponse2434  */
static	ANTLR3_BITWORD FOLLOW_token_in_dresponse2434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_dresponse2434	= { FOLLOW_token_in_dresponse2434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_dresponse2438  */
static	ANTLR3_BITWORD FOLLOW_equal_in_dresponse2438_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_dresponse2438	= { FOLLOW_equal_in_dresponse2438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_request_digest_in_dresponse2440  */
static	ANTLR3_BITWORD FOLLOW_request_digest_in_dresponse2440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_request_digest_in_dresponse2440	= { FOLLOW_request_digest_in_dresponse2440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_request_digest2456  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_request_digest2456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_request_digest2456	= { FOLLOW_quoted_string_in_request_digest2456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_huit_lhex2467  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_huit_lhex2467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000082) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_huit_lhex2467	= { FOLLOW_hexdigit_in_huit_lhex2467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_name_in_auth_param2490  */
static	ANTLR3_BITWORD FOLLOW_auth_param_name_in_auth_param2490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_name_in_auth_param2490	= { FOLLOW_auth_param_name_in_auth_param2490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_auth_param2492  */
static	ANTLR3_BITWORD FOLLOW_equal_in_auth_param2492_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_auth_param2492	= { FOLLOW_equal_in_auth_param2492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_value_in_auth_param2515  */
static	ANTLR3_BITWORD FOLLOW_auth_param_value_in_auth_param2515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_value_in_auth_param2515	= { FOLLOW_auth_param_value_in_auth_param2515_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_auth_param_value2535  */
static	ANTLR3_BITWORD FOLLOW_token_in_auth_param_value2535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_auth_param_value2535	= { FOLLOW_token_in_auth_param_value2535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_auth_param_value2539  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_auth_param_value2539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_auth_param_value2539	= { FOLLOW_quoted_string_in_auth_param_value2539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_auth_param_name2564  */
static	ANTLR3_BITWORD FOLLOW_token_in_auth_param_name2564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_auth_param_name2564	= { FOLLOW_token_in_auth_param_name2564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_scheme_in_other_response2581  */
static	ANTLR3_BITWORD FOLLOW_auth_scheme_in_other_response2581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_scheme_in_other_response2581	= { FOLLOW_auth_scheme_in_other_response2581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_other_response2591  */
static	ANTLR3_BITWORD FOLLOW_lws_in_other_response2591_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_other_response2591	= { FOLLOW_lws_in_other_response2591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_response2593  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_response2593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_response2593	= { FOLLOW_auth_param_in_other_response2593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_other_response2618  */
static	ANTLR3_BITWORD FOLLOW_comma_in_other_response2618_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_other_response2618	= { FOLLOW_comma_in_other_response2618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_response2620  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_response2620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_response2620	= { FOLLOW_auth_param_in_other_response2620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_auth_scheme2642  */
static	ANTLR3_BITWORD FOLLOW_token_in_auth_scheme2642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_auth_scheme2642	= { FOLLOW_token_in_auth_scheme2642_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_nonce_value2660  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_nonce_value2660_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_nonce_value2660	= { FOLLOW_quoted_string_in_nonce_value2660_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_call_id_token2672  */
static	ANTLR3_BITWORD FOLLOW_token_in_call_id_token2672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_call_id_token2672	= { FOLLOW_token_in_call_id_token2672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_id_token_in_header_call_id2702  */
static	ANTLR3_BITWORD FOLLOW_call_id_token_in_header_call_id2702_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_call_id_token_in_header_call_id2702	= { FOLLOW_call_id_token_in_header_call_id2702_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_call_id2706  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_call_id2706_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_call_id2706	= { FOLLOW_hcolon_in_header_call_id2706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_id_in_header_call_id2708  */
static	ANTLR3_BITWORD FOLLOW_call_id_in_header_call_id2708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_call_id_in_header_call_id2708	= { FOLLOW_call_id_in_header_call_id2708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_call_id2731  */
static	ANTLR3_BITWORD FOLLOW_word_in_call_id2731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_call_id2731	= { FOLLOW_word_in_call_id2731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_call_id2735  */
static	ANTLR3_BITWORD FOLLOW_AT_in_call_id2735_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C0) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_call_id2735	= { FOLLOW_AT_in_call_id2735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_call_id2737  */
static	ANTLR3_BITWORD FOLLOW_word_in_call_id2737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_call_id2737	= { FOLLOW_word_in_call_id2737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_contact_token2753  */
static	ANTLR3_BITWORD FOLLOW_token_in_contact_token2753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_contact_token2753	= { FOLLOW_token_in_contact_token2753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_token_in_header_contact2787  */
static	ANTLR3_BITWORD FOLLOW_contact_token_in_header_contact2787_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_token_in_header_contact2787	= { FOLLOW_contact_token_in_header_contact2787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_contact2795  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_contact2795_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_contact2795	= { FOLLOW_sp_tab_colon_in_header_contact2795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_header_contact2819  */
static	ANTLR3_BITWORD FOLLOW_lws_in_header_contact2819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_header_contact2819	= { FOLLOW_lws_in_header_contact2819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_in_header_contact2822  */
static	ANTLR3_BITWORD FOLLOW_STAR_in_header_contact2822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_in_header_contact2822	= { FOLLOW_STAR_in_header_contact2822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_param_in_header_contact2848  */
static	ANTLR3_BITWORD FOLLOW_contact_param_in_header_contact2848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_param_in_header_contact2848	= { FOLLOW_contact_param_in_header_contact2848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_header_contact2852  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_header_contact2852_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_header_contact2852	= { FOLLOW_COMMA_in_header_contact2852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_param_in_header_contact2854  */
static	ANTLR3_BITWORD FOLLOW_contact_param_in_header_contact2854_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_param_in_header_contact2854	= { FOLLOW_contact_param_in_header_contact2854_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_contact_param2906  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_contact_param2906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_contact_param2906	= { FOLLOW_name_addr_in_contact_param2906_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_in_contact_param2917  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_in_contact_param2917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_in_contact_param2917	= { FOLLOW_paramless_addr_spec_in_contact_param2917_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_contact_param2922  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_contact_param2922_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_contact_param2922	= { FOLLOW_SEMI_in_contact_param2922_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_contact_param2924  */
static	ANTLR3_BITWORD FOLLOW_lws_in_contact_param2924_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_contact_param2924	= { FOLLOW_lws_in_contact_param2924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_params_in_contact_param2927  */
static	ANTLR3_BITWORD FOLLOW_contact_params_in_contact_param2927_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_params_in_contact_param2927	= { FOLLOW_contact_params_in_contact_param2927_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_contact_param2929  */
static	ANTLR3_BITWORD FOLLOW_lws_in_contact_param2929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_contact_param2929	= { FOLLOW_lws_in_contact_param2929_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_address_base_in_header_address2955  */
static	ANTLR3_BITWORD FOLLOW_header_address_base_in_header_address2955_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_address_base_in_header_address2955	= { FOLLOW_header_address_base_in_header_address2955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_with_generic_uri_in_header_address_base2992  */
static	ANTLR3_BITWORD FOLLOW_name_addr_with_generic_uri_in_header_address_base2992_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_with_generic_uri_in_header_address_base2992	= { FOLLOW_name_addr_with_generic_uri_in_header_address_base2992_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addr_spec_with_generic_uri_in_header_address_base3005  */
static	ANTLR3_BITWORD FOLLOW_addr_spec_with_generic_uri_in_header_address_base3005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addr_spec_with_generic_uri_in_header_address_base3005	= { FOLLOW_addr_spec_with_generic_uri_in_header_address_base3005_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_name_addr3040  */
static	ANTLR3_BITWORD FOLLOW_lws_in_name_addr3040_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_name_addr3040	= { FOLLOW_lws_in_name_addr3040_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_display_name_in_name_addr3043  */
static	ANTLR3_BITWORD FOLLOW_display_name_in_name_addr3043_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_display_name_in_name_addr3043	= { FOLLOW_display_name_in_name_addr3043_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_laquot_in_name_addr3048  */
static	ANTLR3_BITWORD FOLLOW_sp_laquot_in_name_addr3048_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_laquot_in_name_addr3048	= { FOLLOW_sp_laquot_in_name_addr3048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addr_spec_in_name_addr3051  */
static	ANTLR3_BITWORD FOLLOW_addr_spec_in_name_addr3051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_addr_spec_in_name_addr3051	= { FOLLOW_addr_spec_in_name_addr3051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_raquot_sp_in_name_addr3054  */
static	ANTLR3_BITWORD FOLLOW_raquot_sp_in_name_addr3054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_raquot_sp_in_name_addr3054	= { FOLLOW_raquot_sp_in_name_addr3054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_name_addr_with_generic_uri3077  */
static	ANTLR3_BITWORD FOLLOW_lws_in_name_addr_with_generic_uri3077_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_name_addr_with_generic_uri3077	= { FOLLOW_lws_in_name_addr_with_generic_uri3077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_display_name_in_name_addr_with_generic_uri3080  */
static	ANTLR3_BITWORD FOLLOW_display_name_in_name_addr_with_generic_uri3080_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_display_name_in_name_addr_with_generic_uri3080	= { FOLLOW_display_name_in_name_addr_with_generic_uri3080_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_laquot_in_name_addr_with_generic_uri3085  */
static	ANTLR3_BITWORD FOLLOW_sp_laquot_in_name_addr_with_generic_uri3085_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421F0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_laquot_in_name_addr_with_generic_uri3085	= { FOLLOW_sp_laquot_in_name_addr_with_generic_uri3085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addr_spec_with_generic_uri_in_name_addr_with_generic_uri3088  */
static	ANTLR3_BITWORD FOLLOW_addr_spec_with_generic_uri_in_name_addr_with_generic_uri3088_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_addr_spec_with_generic_uri_in_name_addr_with_generic_uri3088	= { FOLLOW_addr_spec_with_generic_uri_in_name_addr_with_generic_uri3088_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_raquot_sp_in_name_addr_with_generic_uri3091  */
static	ANTLR3_BITWORD FOLLOW_raquot_sp_in_name_addr_with_generic_uri3091_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_raquot_sp_in_name_addr_with_generic_uri3091	= { FOLLOW_raquot_sp_in_name_addr_with_generic_uri3091_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_addr_spec3110  */
static	ANTLR3_BITWORD FOLLOW_lws_in_addr_spec3110_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_addr_spec3110	= { FOLLOW_lws_in_addr_spec3110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_addr_spec3113  */
static	ANTLR3_BITWORD FOLLOW_uri_in_addr_spec3113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_addr_spec3113	= { FOLLOW_uri_in_addr_spec3113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_addr_spec3117  */
static	ANTLR3_BITWORD FOLLOW_lws_in_addr_spec3117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_addr_spec3117	= { FOLLOW_lws_in_addr_spec3117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_addr_spec_with_generic_uri3136  */
static	ANTLR3_BITWORD FOLLOW_lws_in_addr_spec_with_generic_uri3136_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421C0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_addr_spec_with_generic_uri3136	= { FOLLOW_lws_in_addr_spec_with_generic_uri3136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_addr_spec_with_generic_uri3141  */
static	ANTLR3_BITWORD FOLLOW_uri_in_addr_spec_with_generic_uri3141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_addr_spec_with_generic_uri3141	= { FOLLOW_uri_in_addr_spec_with_generic_uri3141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_uri_in_addr_spec_with_generic_uri3156  */
static	ANTLR3_BITWORD FOLLOW_generic_uri_in_addr_spec_with_generic_uri3156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_uri_in_addr_spec_with_generic_uri3156	= { FOLLOW_generic_uri_in_addr_spec_with_generic_uri3156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_addr_spec_with_generic_uri3164  */
static	ANTLR3_BITWORD FOLLOW_lws_in_addr_spec_with_generic_uri3164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_addr_spec_with_generic_uri3164	= { FOLLOW_lws_in_addr_spec_with_generic_uri3164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_paramless_addr_spec3185  */
static	ANTLR3_BITWORD FOLLOW_lws_in_paramless_addr_spec3185_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_paramless_addr_spec3185	= { FOLLOW_lws_in_paramless_addr_spec3185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_uri_in_paramless_addr_spec3188  */
static	ANTLR3_BITWORD FOLLOW_paramless_uri_in_paramless_addr_spec3188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_uri_in_paramless_addr_spec3188	= { FOLLOW_paramless_uri_in_paramless_addr_spec3188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_paramless_addr_spec3192  */
static	ANTLR3_BITWORD FOLLOW_lws_in_paramless_addr_spec3192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_paramless_addr_spec3192	= { FOLLOW_lws_in_paramless_addr_spec3192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3214  */
static	ANTLR3_BITWORD FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3214_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21F0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3214	= { FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_uri_in_paramless_addr_spec_with_generic_uri3219  */
static	ANTLR3_BITWORD FOLLOW_paramless_uri_in_paramless_addr_spec_with_generic_uri3219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_uri_in_paramless_addr_spec_with_generic_uri3219	= { FOLLOW_paramless_uri_in_paramless_addr_spec_with_generic_uri3219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_uri_for_from_to_contact_addr_spec_in_paramless_addr_spec_with_generic_uri3233  */
static	ANTLR3_BITWORD FOLLOW_generic_uri_for_from_to_contact_addr_spec_in_paramless_addr_spec_with_generic_uri3233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_uri_for_from_to_contact_addr_spec_in_paramless_addr_spec_with_generic_uri3233	= { FOLLOW_generic_uri_for_from_to_contact_addr_spec_in_paramless_addr_spec_with_generic_uri3233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3241  */
static	ANTLR3_BITWORD FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3241	= { FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_display_name_tokens3256  */
static	ANTLR3_BITWORD FOLLOW_token_in_display_name_tokens3256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_display_name_tokens3256	= { FOLLOW_token_in_display_name_tokens3256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_display_name_tokens3259  */
static	ANTLR3_BITWORD FOLLOW_lws_in_display_name_tokens3259_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_display_name_tokens3259	= { FOLLOW_lws_in_display_name_tokens3259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_display_name_tokens3261  */
static	ANTLR3_BITWORD FOLLOW_token_in_display_name_tokens3261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_display_name_tokens3261	= { FOLLOW_token_in_display_name_tokens3261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_display_name_tokens_in_display_name3277  */
static	ANTLR3_BITWORD FOLLOW_display_name_tokens_in_display_name3277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_display_name_tokens_in_display_name3277	= { FOLLOW_display_name_tokens_in_display_name3277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_display_name3288  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_display_name3288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_display_name3288	= { FOLLOW_quoted_string_in_display_name3288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_contact_extension_in_contact_params3322  */
static	ANTLR3_BITWORD FOLLOW_contact_extension_in_contact_params3322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_contact_extension_in_contact_params3322	= { FOLLOW_contact_extension_in_contact_params3322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_contact_extension3337  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_contact_extension3337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_contact_extension3337	= { FOLLOW_generic_param_in_contact_extension3337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_delta_seconds3357  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_delta_seconds3357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_delta_seconds3357	= { FOLLOW_DIGIT_in_delta_seconds3357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_content_length_token3372  */
static	ANTLR3_BITWORD FOLLOW_token_in_content_length_token3372_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_content_length_token3372	= { FOLLOW_token_in_content_length_token3372_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_content_length_token_in_header_content_length3401  */
static	ANTLR3_BITWORD FOLLOW_content_length_token_in_header_content_length3401_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_content_length_token_in_header_content_length3401	= { FOLLOW_content_length_token_in_header_content_length3401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_content_length3411  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_content_length3411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_content_length3411	= { FOLLOW_hcolon_in_header_content_length3411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_content_length_in_header_content_length3419  */
static	ANTLR3_BITWORD FOLLOW_content_length_in_header_content_length3419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_content_length_in_header_content_length3419	= { FOLLOW_content_length_in_header_content_length3419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_content_length3432  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_content_length3432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_content_length3432	= { FOLLOW_DIGIT_in_content_length3432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_content_type_token3445  */
static	ANTLR3_BITWORD FOLLOW_token_in_content_type_token3445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_content_type_token3445	= { FOLLOW_token_in_content_type_token3445_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_content_type_token_in_header_content_type3472  */
static	ANTLR3_BITWORD FOLLOW_content_type_token_in_header_content_type3472_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_content_type_token_in_header_content_type3472	= { FOLLOW_content_type_token_in_header_content_type3472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_content_type3475  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_content_type3475_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_content_type3475	= { FOLLOW_hcolon_in_header_content_type3475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_type_in_header_content_type3477  */
static	ANTLR3_BITWORD FOLLOW_media_type_in_header_content_type3477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_media_type_in_header_content_type3477	= { FOLLOW_media_type_in_header_content_type3477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_m_type_in_media_type3503  */
static	ANTLR3_BITWORD FOLLOW_m_type_in_media_type3503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000070) };
static  ANTLR3_BITSET_LIST FOLLOW_m_type_in_media_type3503	= { FOLLOW_m_type_in_media_type3503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_slash_in_media_type3513  */
static	ANTLR3_BITWORD FOLLOW_slash_in_media_type3513_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_slash_in_media_type3513	= { FOLLOW_slash_in_media_type3513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_m_subtype_in_media_type3521  */
static	ANTLR3_BITWORD FOLLOW_m_subtype_in_media_type3521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_m_subtype_in_media_type3521	= { FOLLOW_m_subtype_in_media_type3521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_media_type3532  */
static	ANTLR3_BITWORD FOLLOW_semi_in_media_type3532_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_media_type3532	= { FOLLOW_semi_in_media_type3532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_media_type3535  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_media_type3535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_media_type3535	= { FOLLOW_generic_param_in_media_type3535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_m_type3559  */
static	ANTLR3_BITWORD FOLLOW_token_in_m_type3559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_m_type3559	= { FOLLOW_token_in_m_type3559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_m_subtype3575  */
static	ANTLR3_BITWORD FOLLOW_token_in_m_subtype3575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_m_subtype3575	= { FOLLOW_token_in_m_subtype3575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_cseq_token3588  */
static	ANTLR3_BITWORD FOLLOW_token_in_cseq_token3588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_cseq_token3588	= { FOLLOW_token_in_cseq_token3588_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cseq_token_in_header_cseq3614  */
static	ANTLR3_BITWORD FOLLOW_cseq_token_in_header_cseq3614_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_cseq_token_in_header_cseq3614	= { FOLLOW_cseq_token_in_header_cseq3614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_cseq3620  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_cseq3620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_cseq3620	= { FOLLOW_hcolon_in_header_cseq3620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_seq_number_in_header_cseq3627  */
static	ANTLR3_BITWORD FOLLOW_seq_number_in_header_cseq3627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_seq_number_in_header_cseq3627	= { FOLLOW_seq_number_in_header_cseq3627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_header_cseq3636  */
static	ANTLR3_BITWORD FOLLOW_lws_in_header_cseq3636_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_header_cseq3636	= { FOLLOW_lws_in_header_cseq3636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_method_in_header_cseq3643  */
static	ANTLR3_BITWORD FOLLOW_method_in_header_cseq3643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_method_in_header_cseq3643	= { FOLLOW_method_in_header_cseq3643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_seq_number3662  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_seq_number3662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_seq_number3662	= { FOLLOW_DIGIT_in_seq_number3662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_date_token3674  */
static	ANTLR3_BITWORD FOLLOW_token_in_date_token3674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_date_token3674	= { FOLLOW_token_in_date_token3674_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_date_token_in_header_date3704  */
static	ANTLR3_BITWORD FOLLOW_date_token_in_header_date3704_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_date_token_in_header_date3704	= { FOLLOW_date_token_in_header_date3704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_date3708  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_date3708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_date3708	= { FOLLOW_hcolon_in_header_date3708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_date_in_header_date3710  */
static	ANTLR3_BITWORD FOLLOW_sip_date_in_header_date3710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_date_in_header_date3710	= { FOLLOW_sip_date_in_header_date3710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_date_in_date3727  */
static	ANTLR3_BITWORD FOLLOW_sip_date_in_date3727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_date_in_date3727	= { FOLLOW_sip_date_in_date3727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3739  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3739	= { FOLLOW_alpha_in_sip_date3739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3741  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3741	= { FOLLOW_alpha_in_sip_date3741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3743  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3743	= { FOLLOW_alpha_in_sip_date3743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_sip_date3745  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_sip_date3745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_sip_date3745	= { FOLLOW_COMMA_in_sip_date3745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_sip_date3747  */
static	ANTLR3_BITWORD FOLLOW_SP_in_sip_date3747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_sip_date3747	= { FOLLOW_SP_in_sip_date3747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3750  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3750	= { FOLLOW_DIGIT_in_sip_date3750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3752  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3752	= { FOLLOW_DIGIT_in_sip_date3752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_sip_date3754  */
static	ANTLR3_BITWORD FOLLOW_SP_in_sip_date3754_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_sip_date3754	= { FOLLOW_SP_in_sip_date3754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3756  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3756	= { FOLLOW_alpha_in_sip_date3756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3758  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3758	= { FOLLOW_alpha_in_sip_date3758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3760  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3760	= { FOLLOW_alpha_in_sip_date3760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_sip_date3762  */
static	ANTLR3_BITWORD FOLLOW_SP_in_sip_date3762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_sip_date3762	= { FOLLOW_SP_in_sip_date3762_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3764  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3764	= { FOLLOW_DIGIT_in_sip_date3764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3766  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3766	= { FOLLOW_DIGIT_in_sip_date3766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3768  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3768	= { FOLLOW_DIGIT_in_sip_date3768_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3770  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3770	= { FOLLOW_DIGIT_in_sip_date3770_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_sip_date3772  */
static	ANTLR3_BITWORD FOLLOW_SP_in_sip_date3772_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_sip_date3772	= { FOLLOW_SP_in_sip_date3772_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3775  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3775	= { FOLLOW_DIGIT_in_sip_date3775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3777  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3777	= { FOLLOW_DIGIT_in_sip_date3777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_sip_date3780  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_sip_date3780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_sip_date3780	= { FOLLOW_COLON_in_sip_date3780_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3782  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3782	= { FOLLOW_DIGIT_in_sip_date3782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3784  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3784_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3784	= { FOLLOW_DIGIT_in_sip_date3784_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_sip_date3787  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_sip_date3787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_sip_date3787	= { FOLLOW_COLON_in_sip_date3787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3789  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3789	= { FOLLOW_DIGIT_in_sip_date3789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sip_date3791  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sip_date3791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sip_date3791	= { FOLLOW_DIGIT_in_sip_date3791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_sip_date3793  */
static	ANTLR3_BITWORD FOLLOW_SP_in_sip_date3793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_sip_date3793	= { FOLLOW_SP_in_sip_date3793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3796  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3796_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3796	= { FOLLOW_alpha_in_sip_date3796_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3798  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3798_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000000) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3798	= { FOLLOW_alpha_in_sip_date3798_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_sip_date3800  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_sip_date3800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_sip_date3800	= { FOLLOW_alpha_in_sip_date3800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_expires3840  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_expires3840_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_expires3840	= { FOLLOW_token_in_header_expires3840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_expires3844  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_expires3844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_expires3844	= { FOLLOW_hcolon_in_header_expires3844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_delta_seconds_in_header_expires3846  */
static	ANTLR3_BITWORD FOLLOW_delta_seconds_in_header_expires3846_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_delta_seconds_in_header_expires3846	= { FOLLOW_delta_seconds_in_header_expires3846_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_from_token3867  */
static	ANTLR3_BITWORD FOLLOW_token_in_from_token3867_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_from_token3867	= { FOLLOW_token_in_from_token3867_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_token_in_header_from3904  */
static	ANTLR3_BITWORD FOLLOW_from_token_in_header_from3904_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_from_token_in_header_from3904	= { FOLLOW_from_token_in_header_from3904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_from3907  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_from3907_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21F0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_from3907	= { FOLLOW_sp_tab_colon_in_header_from3907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_spec_in_header_from3909  */
static	ANTLR3_BITWORD FOLLOW_from_spec_in_header_from3909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_from_spec_in_header_from3909	= { FOLLOW_from_spec_in_header_from3909_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_with_generic_uri_in_from_spec3936  */
static	ANTLR3_BITWORD FOLLOW_name_addr_with_generic_uri_in_from_spec3936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_with_generic_uri_in_from_spec3936	= { FOLLOW_name_addr_with_generic_uri_in_from_spec3936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_with_generic_uri_in_from_spec3941  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_with_generic_uri_in_from_spec3941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_with_generic_uri_in_from_spec3941	= { FOLLOW_paramless_addr_spec_with_generic_uri_in_from_spec3941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_from_spec3963  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_from_spec3963_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_from_spec3963	= { FOLLOW_SEMI_in_from_spec3963_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_from_spec3965  */
static	ANTLR3_BITWORD FOLLOW_lws_in_from_spec3965_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_from_spec3965	= { FOLLOW_lws_in_from_spec3965_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_from_param_in_from_spec3968  */
static	ANTLR3_BITWORD FOLLOW_from_param_in_from_spec3968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_from_param_in_from_spec3968	= { FOLLOW_from_param_in_from_spec3968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_from_spec3970  */
static	ANTLR3_BITWORD FOLLOW_lws_in_from_spec3970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_from_spec3970	= { FOLLOW_lws_in_from_spec3970_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_from_param3988  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_from_param3988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_from_param3988	= { FOLLOW_generic_param_in_from_param3988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_max_forwards4049  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_max_forwards4049_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_max_forwards4049	= { FOLLOW_token_in_header_max_forwards4049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_max_forwards4053  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_max_forwards4053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_max_forwards4053	= { FOLLOW_hcolon_in_header_max_forwards4053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_max_forwards_in_header_max_forwards4060  */
static	ANTLR3_BITWORD FOLLOW_max_forwards_in_header_max_forwards4060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_max_forwards_in_header_max_forwards4060	= { FOLLOW_max_forwards_in_header_max_forwards4060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_max_forwards4074  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_max_forwards4074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_max_forwards4074	= { FOLLOW_DIGIT_in_max_forwards4074_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_proxy_authenticate4109  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_proxy_authenticate4109_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_proxy_authenticate4109	= { FOLLOW_token_in_header_proxy_authenticate4109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_proxy_authenticate4116  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_proxy_authenticate4116_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_proxy_authenticate4116	= { FOLLOW_hcolon_in_header_proxy_authenticate4116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_challenge_in_header_proxy_authenticate4118  */
static	ANTLR3_BITWORD FOLLOW_challenge_in_header_proxy_authenticate4118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_challenge_in_header_proxy_authenticate4118	= { FOLLOW_challenge_in_header_proxy_authenticate4118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_challenge4154  */
static	ANTLR3_BITWORD FOLLOW_token_in_challenge4154_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_challenge4154	= { FOLLOW_token_in_challenge4154_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_challenge4166  */
static	ANTLR3_BITWORD FOLLOW_lws_in_challenge4166_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_challenge4166	= { FOLLOW_lws_in_challenge4166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_cln_in_challenge4168  */
static	ANTLR3_BITWORD FOLLOW_digest_cln_in_challenge4168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_cln_in_challenge4168	= { FOLLOW_digest_cln_in_challenge4168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_challenge4172  */
static	ANTLR3_BITWORD FOLLOW_comma_in_challenge4172_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_challenge4172	= { FOLLOW_comma_in_challenge4172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_digest_cln_in_challenge4174  */
static	ANTLR3_BITWORD FOLLOW_digest_cln_in_challenge4174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_digest_cln_in_challenge4174	= { FOLLOW_digest_cln_in_challenge4174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_challenge_in_challenge4205  */
static	ANTLR3_BITWORD FOLLOW_other_challenge_in_challenge4205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_challenge_in_challenge4205	= { FOLLOW_other_challenge_in_challenge4205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_scheme_in_other_challenge4224  */
static	ANTLR3_BITWORD FOLLOW_auth_scheme_in_other_challenge4224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_scheme_in_other_challenge4224	= { FOLLOW_auth_scheme_in_other_challenge4224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_other_challenge4234  */
static	ANTLR3_BITWORD FOLLOW_lws_in_other_challenge4234_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_other_challenge4234	= { FOLLOW_lws_in_other_challenge4234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_challenge4236  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_challenge4236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_challenge4236	= { FOLLOW_auth_param_in_other_challenge4236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_other_challenge4263  */
static	ANTLR3_BITWORD FOLLOW_comma_in_other_challenge4263_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_other_challenge4263	= { FOLLOW_comma_in_other_challenge4263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_other_challenge4265  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_other_challenge4265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_other_challenge4265	= { FOLLOW_auth_param_in_other_challenge4265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_realm_in_digest_cln4292  */
static	ANTLR3_BITWORD FOLLOW_realm_in_digest_cln4292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_realm_in_digest_cln4292	= { FOLLOW_realm_in_digest_cln4292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_in_digest_cln4301  */
static	ANTLR3_BITWORD FOLLOW_nonce_in_digest_cln4301_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_in_digest_cln4301	= { FOLLOW_nonce_in_digest_cln4301_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_algorithm_in_digest_cln4309  */
static	ANTLR3_BITWORD FOLLOW_algorithm_in_digest_cln4309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_algorithm_in_digest_cln4309	= { FOLLOW_algorithm_in_digest_cln4309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_opaque_in_digest_cln4318  */
static	ANTLR3_BITWORD FOLLOW_opaque_in_digest_cln4318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_opaque_in_digest_cln4318	= { FOLLOW_opaque_in_digest_cln4318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_opts_in_digest_cln4327  */
static	ANTLR3_BITWORD FOLLOW_qop_opts_in_digest_cln4327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_opts_in_digest_cln4327	= { FOLLOW_qop_opts_in_digest_cln4327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_domain_in_digest_cln4335  */
static	ANTLR3_BITWORD FOLLOW_domain_in_digest_cln4335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_domain_in_digest_cln4335	= { FOLLOW_domain_in_digest_cln4335_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stale_in_digest_cln4344  */
static	ANTLR3_BITWORD FOLLOW_stale_in_digest_cln4344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stale_in_digest_cln4344	= { FOLLOW_stale_in_digest_cln4344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_auth_param_in_digest_cln4355  */
static	ANTLR3_BITWORD FOLLOW_auth_param_in_digest_cln4355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_auth_param_in_digest_cln4355	= { FOLLOW_auth_param_in_digest_cln4355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_realm4390  */
static	ANTLR3_BITWORD FOLLOW_token_in_realm4390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_realm4390	= { FOLLOW_token_in_realm4390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_realm4394  */
static	ANTLR3_BITWORD FOLLOW_equal_in_realm4394_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_realm4394	= { FOLLOW_equal_in_realm4394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_realm_value_in_realm4396  */
static	ANTLR3_BITWORD FOLLOW_realm_value_in_realm4396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_realm_value_in_realm4396	= { FOLLOW_realm_value_in_realm4396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_realm_value4418  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_realm_value4418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_realm_value4418	= { FOLLOW_quoted_string_in_realm_value4418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_domain4451  */
static	ANTLR3_BITWORD FOLLOW_token_in_domain4451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_domain4451	= { FOLLOW_token_in_domain4451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_domain4455  */
static	ANTLR3_BITWORD FOLLOW_equal_in_domain4455_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_domain4455	= { FOLLOW_equal_in_domain4455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_domain4457  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_domain4457_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_domain4457	= { FOLLOW_quoted_string_in_domain4457_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_nonce4494  */
static	ANTLR3_BITWORD FOLLOW_token_in_nonce4494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_nonce4494	= { FOLLOW_token_in_nonce4494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_nonce4498  */
static	ANTLR3_BITWORD FOLLOW_equal_in_nonce4498_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_nonce4498	= { FOLLOW_equal_in_nonce4498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nonce_value_in_nonce4500  */
static	ANTLR3_BITWORD FOLLOW_nonce_value_in_nonce4500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nonce_value_in_nonce4500	= { FOLLOW_nonce_value_in_nonce4500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_opaque4531  */
static	ANTLR3_BITWORD FOLLOW_token_in_opaque4531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_opaque4531	= { FOLLOW_token_in_opaque4531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_opaque4535  */
static	ANTLR3_BITWORD FOLLOW_equal_in_opaque4535_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878EC2180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_opaque4535	= { FOLLOW_equal_in_opaque4535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_quoted_string_in_opaque4537  */
static	ANTLR3_BITWORD FOLLOW_quoted_string_in_opaque4537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_quoted_string_in_opaque4537	= { FOLLOW_quoted_string_in_opaque4537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_stale4570  */
static	ANTLR3_BITWORD FOLLOW_token_in_stale4570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_stale4570	= { FOLLOW_token_in_stale4570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_stale4574  */
static	ANTLR3_BITWORD FOLLOW_equal_in_stale4574_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_stale4574	= { FOLLOW_equal_in_stale4574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stale_value_in_stale4576  */
static	ANTLR3_BITWORD FOLLOW_stale_value_in_stale4576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stale_value_in_stale4576	= { FOLLOW_stale_value_in_stale4576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_stale_value4586  */
static	ANTLR3_BITWORD FOLLOW_token_in_stale_value4586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_stale_value4586	= { FOLLOW_token_in_stale_value4586_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_algorithm4615  */
static	ANTLR3_BITWORD FOLLOW_token_in_algorithm4615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_algorithm4615	= { FOLLOW_token_in_algorithm4615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_algorithm4619  */
static	ANTLR3_BITWORD FOLLOW_equal_in_algorithm4619_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_algorithm4619	= { FOLLOW_equal_in_algorithm4619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_algorithm4625  */
static	ANTLR3_BITWORD FOLLOW_token_in_algorithm4625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_algorithm4625	= { FOLLOW_token_in_algorithm4625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_qop_opts4665  */
static	ANTLR3_BITWORD FOLLOW_token_in_qop_opts4665_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001030) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_qop_opts4665	= { FOLLOW_token_in_qop_opts4665_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_equal_in_qop_opts4669  */
static	ANTLR3_BITWORD FOLLOW_equal_in_qop_opts4669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_equal_in_qop_opts4669	= { FOLLOW_equal_in_qop_opts4669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_qop_opts4675  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_qop_opts4675_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_qop_opts4675	= { FOLLOW_DQUOTE_in_qop_opts4675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_opts_value_in_qop_opts4680  */
static	ANTLR3_BITWORD FOLLOW_qop_opts_value_in_qop_opts4680_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000088000) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_opts_value_in_qop_opts4680	= { FOLLOW_qop_opts_value_in_qop_opts4680_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_qop_opts4686  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_qop_opts4686_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_qop_opts4686	= { FOLLOW_COMMA_in_qop_opts4686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qop_opts_value_in_qop_opts4688  */
static	ANTLR3_BITWORD FOLLOW_qop_opts_value_in_qop_opts4688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000088000) };
static  ANTLR3_BITSET_LIST FOLLOW_qop_opts_value_in_qop_opts4688	= { FOLLOW_qop_opts_value_in_qop_opts4688_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_qop_opts4696  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_qop_opts4696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_qop_opts4696	= { FOLLOW_DQUOTE_in_qop_opts4696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_qop_opts_value4711  */
static	ANTLR3_BITWORD FOLLOW_lws_in_qop_opts_value4711_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_qop_opts_value4711	= { FOLLOW_lws_in_qop_opts_value4711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_qop_opts_value4714  */
static	ANTLR3_BITWORD FOLLOW_token_in_qop_opts_value4714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_qop_opts_value4714	= { FOLLOW_token_in_qop_opts_value4714_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_qop_opts_value4716  */
static	ANTLR3_BITWORD FOLLOW_lws_in_qop_opts_value4716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_qop_opts_value4716	= { FOLLOW_lws_in_qop_opts_value4716_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_proxy_authorization4747  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_proxy_authorization4747_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_proxy_authorization4747	= { FOLLOW_token_in_header_proxy_authorization4747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_proxy_authorization4751  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_proxy_authorization4751_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_proxy_authorization4751	= { FOLLOW_hcolon_in_header_proxy_authorization4751_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_credentials_in_header_proxy_authorization4753  */
static	ANTLR3_BITWORD FOLLOW_credentials_in_header_proxy_authorization4753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_credentials_in_header_proxy_authorization4753	= { FOLLOW_credentials_in_header_proxy_authorization4753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_service_route_token4774  */
static	ANTLR3_BITWORD FOLLOW_token_in_service_route_token4774_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_service_route_token4774	= { FOLLOW_token_in_service_route_token4774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_service_route_token_in_header_service_route4802  */
static	ANTLR3_BITWORD FOLLOW_service_route_token_in_header_service_route4802_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_service_route_token_in_header_service_route4802	= { FOLLOW_service_route_token_in_header_service_route4802_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_service_route4806  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_service_route4806_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_service_route4806	= { FOLLOW_sp_tab_colon_in_header_service_route4806_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_srv_route_in_header_service_route4808  */
static	ANTLR3_BITWORD FOLLOW_srv_route_in_header_service_route4808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_srv_route_in_header_service_route4808	= { FOLLOW_srv_route_in_header_service_route4808_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_header_service_route4811  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_header_service_route4811_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_header_service_route4811	= { FOLLOW_COMMA_in_header_service_route4811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_srv_route_in_header_service_route4813  */
static	ANTLR3_BITWORD FOLLOW_srv_route_in_header_service_route4813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_srv_route_in_header_service_route4813	= { FOLLOW_srv_route_in_header_service_route4813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_srv_route4849  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_srv_route4849_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_srv_route4849	= { FOLLOW_name_addr_in_srv_route4849_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_srv_route4854  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_srv_route4854_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_srv_route4854	= { FOLLOW_SEMI_in_srv_route4854_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_srv_route4856  */
static	ANTLR3_BITWORD FOLLOW_lws_in_srv_route4856_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_srv_route4856	= { FOLLOW_lws_in_srv_route4856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sr_param_in_srv_route4859  */
static	ANTLR3_BITWORD FOLLOW_sr_param_in_srv_route4859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_sr_param_in_srv_route4859	= { FOLLOW_sr_param_in_srv_route4859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_srv_route4861  */
static	ANTLR3_BITWORD FOLLOW_lws_in_srv_route4861_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_srv_route4861	= { FOLLOW_lws_in_srv_route4861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_sr_param4885  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_sr_param4885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_sr_param4885	= { FOLLOW_generic_param_in_sr_param4885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_record_route_token4898  */
static	ANTLR3_BITWORD FOLLOW_token_in_record_route_token4898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_record_route_token4898	= { FOLLOW_token_in_record_route_token4898_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_record_route_token_in_header_record_route4926  */
static	ANTLR3_BITWORD FOLLOW_record_route_token_in_header_record_route4926_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_record_route_token_in_header_record_route4926	= { FOLLOW_record_route_token_in_header_record_route4926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_record_route4930  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_record_route4930_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_record_route4930	= { FOLLOW_sp_tab_colon_in_header_record_route4930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rec_route_in_header_record_route4932  */
static	ANTLR3_BITWORD FOLLOW_rec_route_in_header_record_route4932_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_rec_route_in_header_record_route4932	= { FOLLOW_rec_route_in_header_record_route4932_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_header_record_route4936  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_header_record_route4936_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_header_record_route4936	= { FOLLOW_COMMA_in_header_record_route4936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rec_route_in_header_record_route4938  */
static	ANTLR3_BITWORD FOLLOW_rec_route_in_header_record_route4938_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_rec_route_in_header_record_route4938	= { FOLLOW_rec_route_in_header_record_route4938_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_rec_route4973  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_rec_route4973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_rec_route4973	= { FOLLOW_name_addr_in_rec_route4973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_rec_route4978  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_rec_route4978_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_rec_route4978	= { FOLLOW_SEMI_in_rec_route4978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_rec_route4980  */
static	ANTLR3_BITWORD FOLLOW_lws_in_rec_route4980_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_rec_route4980	= { FOLLOW_lws_in_rec_route4980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rr_param_in_rec_route4983  */
static	ANTLR3_BITWORD FOLLOW_rr_param_in_rec_route4983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_rr_param_in_rec_route4983	= { FOLLOW_rr_param_in_rec_route4983_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_rec_route4985  */
static	ANTLR3_BITWORD FOLLOW_lws_in_rec_route4985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_rec_route4985	= { FOLLOW_lws_in_rec_route4985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_rr_param5009  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_rr_param5009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_rr_param5009	= { FOLLOW_generic_param_in_rr_param5009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_comment5019  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_comment5019_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_comment5019	= { FOLLOW_LPAREN_in_comment5019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_comment5023  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_comment5023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_comment5023	= { FOLLOW_RPAREN_in_comment5023_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_route_token5037  */
static	ANTLR3_BITWORD FOLLOW_token_in_route_token5037_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_route_token5037	= { FOLLOW_token_in_route_token5037_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_route_token_in_header_route5065  */
static	ANTLR3_BITWORD FOLLOW_route_token_in_header_route5065_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_route_token_in_header_route5065	= { FOLLOW_route_token_in_header_route5065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_route5069  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_route5069_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_route5069	= { FOLLOW_sp_tab_colon_in_header_route5069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_route_param_in_header_route5071  */
static	ANTLR3_BITWORD FOLLOW_route_param_in_header_route5071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_route_param_in_header_route5071	= { FOLLOW_route_param_in_header_route5071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_header_route5075  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_header_route5075_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_header_route5075	= { FOLLOW_COMMA_in_header_route5075_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_route_param_in_header_route5077  */
static	ANTLR3_BITWORD FOLLOW_route_param_in_header_route5077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_route_param_in_header_route5077	= { FOLLOW_route_param_in_header_route5077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_route_param5113  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_route_param5113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_route_param5113	= { FOLLOW_name_addr_in_route_param5113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_route_param5118  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_route_param5118_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_route_param5118	= { FOLLOW_SEMI_in_route_param5118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_route_param5120  */
static	ANTLR3_BITWORD FOLLOW_lws_in_route_param5120_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_route_param5120	= { FOLLOW_lws_in_route_param5120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_r_param_in_route_param5123  */
static	ANTLR3_BITWORD FOLLOW_r_param_in_route_param5123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_r_param_in_route_param5123	= { FOLLOW_r_param_in_route_param5123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_route_param5125  */
static	ANTLR3_BITWORD FOLLOW_lws_in_route_param5125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_route_param5125	= { FOLLOW_lws_in_route_param5125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_r_param5146  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_r_param5146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_r_param5146	= { FOLLOW_generic_param_in_r_param5146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_to_token5161  */
static	ANTLR3_BITWORD FOLLOW_token_in_to_token5161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_to_token5161	= { FOLLOW_token_in_to_token5161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_token_in_header_to5198  */
static	ANTLR3_BITWORD FOLLOW_to_token_in_header_to5198_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_to_token_in_header_to5198	= { FOLLOW_to_token_in_header_to5198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_to5202  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_to5202_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21F0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_to5202	= { FOLLOW_sp_tab_colon_in_header_to5202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_spec_in_header_to5204  */
static	ANTLR3_BITWORD FOLLOW_to_spec_in_header_to5204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_to_spec_in_header_to5204	= { FOLLOW_to_spec_in_header_to5204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_with_generic_uri_in_to_spec5228  */
static	ANTLR3_BITWORD FOLLOW_name_addr_with_generic_uri_in_to_spec5228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_with_generic_uri_in_to_spec5228	= { FOLLOW_name_addr_with_generic_uri_in_to_spec5228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_with_generic_uri_in_to_spec5233  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_with_generic_uri_in_to_spec5233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_with_generic_uri_in_to_spec5233	= { FOLLOW_paramless_addr_spec_with_generic_uri_in_to_spec5233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_to_spec5255  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_to_spec5255_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_to_spec5255	= { FOLLOW_SEMI_in_to_spec5255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_to_spec5257  */
static	ANTLR3_BITWORD FOLLOW_lws_in_to_spec5257_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_to_spec5257	= { FOLLOW_lws_in_to_spec5257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_to_param_in_to_spec5260  */
static	ANTLR3_BITWORD FOLLOW_to_param_in_to_spec5260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_to_param_in_to_spec5260	= { FOLLOW_to_param_in_to_spec5260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_to_spec5262  */
static	ANTLR3_BITWORD FOLLOW_lws_in_to_spec5262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_to_spec5262	= { FOLLOW_lws_in_to_spec5262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_to_param5280  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_to_param5280_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_to_param5280	= { FOLLOW_generic_param_in_to_param5280_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_refer_to_token5292  */
static	ANTLR3_BITWORD FOLLOW_token_in_refer_to_token5292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_refer_to_token5292	= { FOLLOW_token_in_refer_to_token5292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_refer_to_token_in_header_refer_to5311  */
static	ANTLR3_BITWORD FOLLOW_refer_to_token_in_header_refer_to5311_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_refer_to_token_in_header_refer_to5311	= { FOLLOW_refer_to_token_in_header_refer_to5311_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_refer_to5322  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_refer_to5322_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_refer_to5322	= { FOLLOW_sp_tab_colon_in_header_refer_to5322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_refer_to_spec_in_header_refer_to5331  */
static	ANTLR3_BITWORD FOLLOW_refer_to_spec_in_header_refer_to5331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_refer_to_spec_in_header_refer_to5331	= { FOLLOW_refer_to_spec_in_header_refer_to5331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_referred_by_token5344  */
static	ANTLR3_BITWORD FOLLOW_token_in_referred_by_token5344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_referred_by_token5344	= { FOLLOW_token_in_referred_by_token5344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_referred_by_token_in_header_referred_by5363  */
static	ANTLR3_BITWORD FOLLOW_referred_by_token_in_header_referred_by5363_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_referred_by_token_in_header_referred_by5363	= { FOLLOW_referred_by_token_in_header_referred_by5363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_referred_by5374  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_referred_by5374_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21B0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_referred_by5374	= { FOLLOW_sp_tab_colon_in_header_referred_by5374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_refer_to_spec_in_header_referred_by5383  */
static	ANTLR3_BITWORD FOLLOW_refer_to_spec_in_header_referred_by5383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_refer_to_spec_in_header_referred_by5383	= { FOLLOW_refer_to_spec_in_header_referred_by5383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_name_addr_in_refer_to_spec5417  */
static	ANTLR3_BITWORD FOLLOW_name_addr_in_refer_to_spec5417_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_name_addr_in_refer_to_spec5417	= { FOLLOW_name_addr_in_refer_to_spec5417_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramless_addr_spec_in_refer_to_spec5422  */
static	ANTLR3_BITWORD FOLLOW_paramless_addr_spec_in_refer_to_spec5422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_paramless_addr_spec_in_refer_to_spec5422	= { FOLLOW_paramless_addr_spec_in_refer_to_spec5422_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_refer_to_spec5429  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_refer_to_spec5429_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_refer_to_spec5429	= { FOLLOW_SEMI_in_refer_to_spec5429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_refer_to_spec5431  */
static	ANTLR3_BITWORD FOLLOW_lws_in_refer_to_spec5431_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_refer_to_spec5431	= { FOLLOW_lws_in_refer_to_spec5431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_refer_to_spec5434  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_refer_to_spec5434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_refer_to_spec5434	= { FOLLOW_generic_param_in_refer_to_spec5434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_refer_to_spec5438  */
static	ANTLR3_BITWORD FOLLOW_lws_in_refer_to_spec5438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_refer_to_spec5438	= { FOLLOW_lws_in_refer_to_spec5438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_user_agent5489  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_user_agent5489_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_user_agent5489	= { FOLLOW_token_in_header_user_agent5489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_user_agent5493  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_user_agent5493_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_user_agent5493	= { FOLLOW_hcolon_in_header_user_agent5493_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_server_val_in_header_user_agent5495  */
static	ANTLR3_BITWORD FOLLOW_server_val_in_header_user_agent5495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_server_val_in_header_user_agent5495	= { FOLLOW_server_val_in_header_user_agent5495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_header_user_agent5498  */
static	ANTLR3_BITWORD FOLLOW_lws_in_header_user_agent5498_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_header_user_agent5498	= { FOLLOW_lws_in_header_user_agent5498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_server_val_in_header_user_agent5500  */
static	ANTLR3_BITWORD FOLLOW_server_val_in_header_user_agent5500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_server_val_in_header_user_agent5500	= { FOLLOW_server_val_in_header_user_agent5500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_server_val5520  */
static	ANTLR3_BITWORD FOLLOW_word_in_server_val5520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_server_val5520	= { FOLLOW_word_in_server_val5520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_via_token5533  */
static	ANTLR3_BITWORD FOLLOW_token_in_via_token5533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_via_token5533	= { FOLLOW_token_in_via_token5533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_token_in_header_via5570  */
static	ANTLR3_BITWORD FOLLOW_via_token_in_header_via5570_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_via_token_in_header_via5570	= { FOLLOW_via_token_in_header_via5570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_via5573  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_via5573_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_via5573	= { FOLLOW_hcolon_in_header_via5573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_parm_in_header_via5575  */
static	ANTLR3_BITWORD FOLLOW_via_parm_in_header_via5575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_via_parm_in_header_via5575	= { FOLLOW_via_parm_in_header_via5575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comma_in_header_via5578  */
static	ANTLR3_BITWORD FOLLOW_comma_in_header_via5578_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_comma_in_header_via5578	= { FOLLOW_comma_in_header_via5578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_parm_in_header_via5580  */
static	ANTLR3_BITWORD FOLLOW_via_parm_in_header_via5580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008032) };
static  ANTLR3_BITSET_LIST FOLLOW_via_parm_in_header_via5580	= { FOLLOW_via_parm_in_header_via5580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sent_protocol_in_via_parm5621  */
static	ANTLR3_BITWORD FOLLOW_sent_protocol_in_via_parm5621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_sent_protocol_in_via_parm5621	= { FOLLOW_sent_protocol_in_via_parm5621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_via_parm5624  */
static	ANTLR3_BITWORD FOLLOW_lws_in_via_parm5624_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_via_parm5624	= { FOLLOW_lws_in_via_parm5624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sent_by_in_via_parm5626  */
static	ANTLR3_BITWORD FOLLOW_sent_by_in_via_parm5626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_sent_by_in_via_parm5626	= { FOLLOW_sent_by_in_via_parm5626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_via_parm5630  */
static	ANTLR3_BITWORD FOLLOW_semi_in_via_parm5630_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_via_parm5630	= { FOLLOW_semi_in_via_parm5630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_params_in_via_parm5632  */
static	ANTLR3_BITWORD FOLLOW_via_params_in_via_parm5632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_via_params_in_via_parm5632	= { FOLLOW_via_params_in_via_parm5632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_received_in_via_params5659  */
static	ANTLR3_BITWORD FOLLOW_via_received_in_via_params5659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_via_received_in_via_params5659	= { FOLLOW_via_received_in_via_params5659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_via_params5664  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_via_params5664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_via_params5664	= { FOLLOW_generic_param_in_via_params5664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_via_received5682  */
static	ANTLR3_BITWORD FOLLOW_token_in_via_received5682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_via_received5682	= { FOLLOW_token_in_via_received5682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_via_received5684  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_via_received5684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000280) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_via_received5684	= { FOLLOW_EQUAL_in_via_received5684_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_via_address_in_via_received5686  */
static	ANTLR3_BITWORD FOLLOW_via_address_in_via_received5686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_via_address_in_via_received5686	= { FOLLOW_via_address_in_via_received5686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv4address_in_via_address5695  */
static	ANTLR3_BITWORD FOLLOW_ipv4address_in_via_address5695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv4address_in_via_address5695	= { FOLLOW_ipv4address_in_via_address5695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv6address_in_via_address5699  */
static	ANTLR3_BITWORD FOLLOW_ipv6address_in_via_address5699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv6address_in_via_address5699	= { FOLLOW_ipv6address_in_via_address5699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_protocol_name_in_sent_protocol5718  */
static	ANTLR3_BITWORD FOLLOW_protocol_name_in_sent_protocol5718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000070) };
static  ANTLR3_BITSET_LIST FOLLOW_protocol_name_in_sent_protocol5718	= { FOLLOW_protocol_name_in_sent_protocol5718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_slash_in_sent_protocol5720  */
static	ANTLR3_BITWORD FOLLOW_slash_in_sent_protocol5720_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_slash_in_sent_protocol5720	= { FOLLOW_slash_in_sent_protocol5720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_protocol_version_in_sent_protocol5722  */
static	ANTLR3_BITWORD FOLLOW_protocol_version_in_sent_protocol5722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000070) };
static  ANTLR3_BITSET_LIST FOLLOW_protocol_version_in_sent_protocol5722	= { FOLLOW_protocol_version_in_sent_protocol5722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_slash_in_sent_protocol5748  */
static	ANTLR3_BITWORD FOLLOW_slash_in_sent_protocol5748_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_slash_in_sent_protocol5748	= { FOLLOW_slash_in_sent_protocol5748_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_transport_in_sent_protocol5750  */
static	ANTLR3_BITWORD FOLLOW_transport_in_sent_protocol5750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_transport_in_sent_protocol5750	= { FOLLOW_transport_in_sent_protocol5750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_protocol_name5771  */
static	ANTLR3_BITWORD FOLLOW_token_in_protocol_name5771_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_protocol_name5771	= { FOLLOW_token_in_protocol_name5771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_protocol_version5784  */
static	ANTLR3_BITWORD FOLLOW_token_in_protocol_version5784_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_protocol_version5784	= { FOLLOW_token_in_protocol_version5784_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_transport_in_transport5805  */
static	ANTLR3_BITWORD FOLLOW_other_transport_in_transport5805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_transport_in_transport5805	= { FOLLOW_other_transport_in_transport5805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_other_transport5814  */
static	ANTLR3_BITWORD FOLLOW_token_in_other_transport5814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_other_transport5814	= { FOLLOW_token_in_other_transport5814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_host_in_sent_by5837  */
static	ANTLR3_BITWORD FOLLOW_host_in_sent_by5837_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_host_in_sent_by5837	= { FOLLOW_host_in_sent_by5837_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_sent_by5848  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_sent_by5848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_sent_by5848	= { FOLLOW_COLON_in_sent_by5848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_in_sent_by5850  */
static	ANTLR3_BITWORD FOLLOW_port_in_sent_by5850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_port_in_sent_by5850	= { FOLLOW_port_in_sent_by5850_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_www_authenticate5890  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_www_authenticate5890_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_www_authenticate5890	= { FOLLOW_token_in_header_www_authenticate5890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_www_authenticate5894  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_www_authenticate5894_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_www_authenticate5894	= { FOLLOW_hcolon_in_header_www_authenticate5894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_challenge_in_header_www_authenticate5896  */
static	ANTLR3_BITWORD FOLLOW_challenge_in_header_www_authenticate5896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_challenge_in_header_www_authenticate5896	= { FOLLOW_challenge_in_header_www_authenticate5896_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_state_value5909  */
static	ANTLR3_BITWORD FOLLOW_token_in_state_value5909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_state_value5909	= { FOLLOW_token_in_state_value5909_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_subscription_state5937  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_subscription_state5937_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_subscription_state5937	= { FOLLOW_token_in_header_subscription_state5937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_subscription_state5943  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_subscription_state5943_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_subscription_state5943	= { FOLLOW_hcolon_in_header_subscription_state5943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_state_value_in_header_subscription_state5945  */
static	ANTLR3_BITWORD FOLLOW_state_value_in_header_subscription_state5945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_state_value_in_header_subscription_state5945	= { FOLLOW_state_value_in_header_subscription_state5945_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_header_subscription_state5952  */
static	ANTLR3_BITWORD FOLLOW_semi_in_header_subscription_state5952_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_header_subscription_state5952	= { FOLLOW_semi_in_header_subscription_state5952_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_header_subscription_state5955  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_header_subscription_state5955_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_header_subscription_state5955	= { FOLLOW_generic_param_in_header_subscription_state5955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_event5993  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_event5993_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_event5993	= { FOLLOW_token_in_header_event5993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_event5999  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_event5999_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_event5999	= { FOLLOW_hcolon_in_header_event5999_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_event_package_in_header_event6001  */
static	ANTLR3_BITWORD FOLLOW_event_package_in_header_event6001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_event_package_in_header_event6001	= { FOLLOW_event_package_in_header_event6001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_header_event6008  */
static	ANTLR3_BITWORD FOLLOW_semi_in_header_event6008_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_header_event6008	= { FOLLOW_semi_in_header_event6008_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_header_event6011  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_header_event6011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_header_event6011	= { FOLLOW_generic_param_in_header_event6011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_event_package6031  */
static	ANTLR3_BITWORD FOLLOW_token_in_event_package6031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_event_package6031	= { FOLLOW_token_in_event_package6031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_replaces6064  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_replaces6064_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_replaces6064	= { FOLLOW_token_in_header_replaces6064_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_replaces6070  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_replaces6070_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C0) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_replaces6070	= { FOLLOW_hcolon_in_header_replaces6070_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_call_id_in_header_replaces6072  */
static	ANTLR3_BITWORD FOLLOW_call_id_in_header_replaces6072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_call_id_in_header_replaces6072	= { FOLLOW_call_id_in_header_replaces6072_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_header_replaces6080  */
static	ANTLR3_BITWORD FOLLOW_semi_in_header_replaces6080_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E421B0) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_header_replaces6080	= { FOLLOW_semi_in_header_replaces6080_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generic_param_in_header_replaces6083  */
static	ANTLR3_BITWORD FOLLOW_generic_param_in_header_replaces6083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_generic_param_in_header_replaces6083	= { FOLLOW_generic_param_in_header_replaces6083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_p_preferred_identity6122  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_p_preferred_identity6122_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_p_preferred_identity6122	= { FOLLOW_token_in_header_p_preferred_identity6122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_header_p_preferred_identity6128  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_header_p_preferred_identity6128_bits[]	= { ANTLR3_UINT64_LIT(0x00000078F8EC21F0) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_header_p_preferred_identity6128	= { FOLLOW_sp_tab_colon_in_header_p_preferred_identity6128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_address_base_in_header_p_preferred_identity6130  */
static	ANTLR3_BITWORD FOLLOW_header_address_base_in_header_p_preferred_identity6130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_address_base_in_header_p_preferred_identity6130	= { FOLLOW_header_address_base_in_header_p_preferred_identity6130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_privacy6167  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_privacy6167_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_privacy6167	= { FOLLOW_token_in_header_privacy6167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_privacy6171  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_privacy6171_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_privacy6171	= { FOLLOW_hcolon_in_header_privacy6171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_privacy_val_in_header_privacy6173  */
static	ANTLR3_BITWORD FOLLOW_privacy_val_in_header_privacy6173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_privacy_val_in_header_privacy6173	= { FOLLOW_privacy_val_in_header_privacy6173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_header_privacy6176  */
static	ANTLR3_BITWORD FOLLOW_semi_in_header_privacy6176_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42180) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_header_privacy6176	= { FOLLOW_semi_in_header_privacy6176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_privacy_val_in_header_privacy6178  */
static	ANTLR3_BITWORD FOLLOW_privacy_val_in_header_privacy6178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_privacy_val_in_header_privacy6178	= { FOLLOW_privacy_val_in_header_privacy6178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_privacy_val6193  */
static	ANTLR3_BITWORD FOLLOW_token_in_privacy_val6193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_privacy_val6193	= { FOLLOW_token_in_privacy_val6193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_extension_base_in_header6210  */
static	ANTLR3_BITWORD FOLLOW_header_extension_base_in_header6210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_extension_base_in_header6210	= { FOLLOW_header_extension_base_in_header6210_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_name_in_header_extension_base6246  */
static	ANTLR3_BITWORD FOLLOW_header_name_in_header_extension_base6246_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_header_name_in_header_extension_base6246	= { FOLLOW_header_name_in_header_extension_base6246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hcolon_in_header_extension_base6256  */
static	ANTLR3_BITWORD FOLLOW_hcolon_in_header_extension_base6256_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_hcolon_in_header_extension_base6256	= { FOLLOW_hcolon_in_header_extension_base6256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_header_value_in_header_extension_base6271  */
static	ANTLR3_BITWORD FOLLOW_header_value_in_header_extension_base6271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_header_value_in_header_extension_base6271	= { FOLLOW_header_value_in_header_extension_base6271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_header_name6342  */
static	ANTLR3_BITWORD FOLLOW_token_in_header_name6342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_header_name6342	= { FOLLOW_token_in_header_name6342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_header_value6385  */
static	ANTLR3_BITWORD FOLLOW_set_in_header_value6385_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF2) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_header_value6385	= { FOLLOW_set_in_header_value6385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_header_value6394  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_header_value6394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_header_value6394	= { FOLLOW_CRLF_in_header_value6394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_header_value6396  */
static	ANTLR3_BITWORD FOLLOW_SP_in_header_value6396_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF2) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_header_value6396	= { FOLLOW_SP_in_header_value6396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_header_value6401  */
static	ANTLR3_BITWORD FOLLOW_set_in_header_value6401_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF2) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_header_value6401	= { FOLLOW_set_in_header_value6401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OCTET_in_message_body6438  */
static	ANTLR3_BITWORD FOLLOW_OCTET_in_message_body6438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OCTET_in_message_body6438	= { FOLLOW_OCTET_in_message_body6438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_schema_in_paramless_uri6469  */
static	ANTLR3_BITWORD FOLLOW_sip_schema_in_paramless_uri6469_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_schema_in_paramless_uri6469	= { FOLLOW_sip_schema_in_paramless_uri6469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userinfo_in_paramless_uri6481  */
static	ANTLR3_BITWORD FOLLOW_userinfo_in_paramless_uri6481_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_userinfo_in_paramless_uri6481	= { FOLLOW_userinfo_in_paramless_uri6481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_paramless_uri6484  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_paramless_uri6484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_paramless_uri6484	= { FOLLOW_hostport_in_paramless_uri6484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_paramless_uri6490  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_paramless_uri6490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_paramless_uri6490	= { FOLLOW_hostport_in_paramless_uri6490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_headers_in_paramless_uri6497  */
static	ANTLR3_BITWORD FOLLOW_headers_in_paramless_uri6497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_headers_in_paramless_uri6497	= { FOLLOW_headers_in_paramless_uri6497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_schema_in_uri6538  */
static	ANTLR3_BITWORD FOLLOW_sip_schema_in_uri6538_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_schema_in_uri6538	= { FOLLOW_sip_schema_in_uri6538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userinfo_in_uri6549  */
static	ANTLR3_BITWORD FOLLOW_userinfo_in_uri6549_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_userinfo_in_uri6549	= { FOLLOW_userinfo_in_uri6549_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_uri6552  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_uri6552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030032) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_uri6552	= { FOLLOW_hostport_in_uri6552_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostport_in_uri6558  */
static	ANTLR3_BITWORD FOLLOW_hostport_in_uri6558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000030032) };
static  ANTLR3_BITSET_LIST FOLLOW_hostport_in_uri6558	= { FOLLOW_hostport_in_uri6558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_parameters_in_uri6567  */
static	ANTLR3_BITWORD FOLLOW_uri_parameters_in_uri6567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_parameters_in_uri6567	= { FOLLOW_uri_parameters_in_uri6567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_headers_in_uri6575  */
static	ANTLR3_BITWORD FOLLOW_headers_in_uri6575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_headers_in_uri6575	= { FOLLOW_headers_in_uri6575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_sip_token6596  */
static	ANTLR3_BITWORD FOLLOW_token_in_sip_token6596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_sip_token6596	= { FOLLOW_token_in_sip_token6596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_sips_token6605  */
static	ANTLR3_BITWORD FOLLOW_token_in_sips_token6605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_sips_token6605	= { FOLLOW_token_in_sips_token6605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sips_token_in_sip_schema6616  */
static	ANTLR3_BITWORD FOLLOW_sips_token_in_sip_schema6616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_sips_token_in_sip_schema6616	= { FOLLOW_sips_token_in_sip_schema6616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_token_in_sip_schema6634  */
static	ANTLR3_BITWORD FOLLOW_sip_token_in_sip_schema6634_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_token_in_sip_schema6634	= { FOLLOW_sip_token_in_sip_schema6634_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_sip_schema6637  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_sip_schema6637_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_sip_schema6637	= { FOLLOW_COLON_in_sip_schema6637_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_user_in_userinfo6664  */
static	ANTLR3_BITWORD FOLLOW_user_in_userinfo6664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000600) };
static  ANTLR3_BITSET_LIST FOLLOW_user_in_userinfo6664	= { FOLLOW_user_in_userinfo6664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_userinfo6668  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_userinfo6668_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_userinfo6668	= { FOLLOW_COLON_in_userinfo6668_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_password_in_userinfo6670  */
static	ANTLR3_BITWORD FOLLOW_password_in_userinfo6670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_password_in_userinfo6670	= { FOLLOW_password_in_userinfo6670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_userinfo6676  */
static	ANTLR3_BITWORD FOLLOW_AT_in_userinfo6676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_userinfo6676	= { FOLLOW_AT_in_userinfo6676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_user6698  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_user6698_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_user6698	= { FOLLOW_unreserved_in_user6698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_user6703  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_user6703_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_user6703	= { FOLLOW_escaped_in_user6703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_user_unreserved_in_user6707  */
static	ANTLR3_BITWORD FOLLOW_user_unreserved_in_user6707_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E7FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_user_unreserved_in_user6707	= { FOLLOW_user_unreserved_in_user6707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_password6730  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_password6730_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_password6730	= { FOLLOW_unreserved_in_password6730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_password6734  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_password6734_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_password6734	= { FOLLOW_escaped_in_password6734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_password6737  */
static	ANTLR3_BITWORD FOLLOW_AND_in_password6737_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_password6737	= { FOLLOW_AND_in_password6737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_password6741  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_password6741_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_password6741	= { FOLLOW_EQUAL_in_password6741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_password6745  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_password6745_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_password6745	= { FOLLOW_PLUS_in_password6745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOLLARD_in_password6749  */
static	ANTLR3_BITWORD FOLLOW_DOLLARD_in_password6749_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_DOLLARD_in_password6749	= { FOLLOW_DOLLARD_in_password6749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_password6753  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_password6753_bits[]	= { ANTLR3_UINT64_LIT(0x0000007868E4FFC2) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_password6753	= { FOLLOW_COMMA_in_password6753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_host_in_hostport6786  */
static	ANTLR3_BITWORD FOLLOW_host_in_hostport6786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_host_in_hostport6786	= { FOLLOW_host_in_hostport6786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hostport6790  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hostport6790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hostport6790	= { FOLLOW_COLON_in_hostport6790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_in_hostport6792  */
static	ANTLR3_BITWORD FOLLOW_port_in_hostport6792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_port_in_hostport6792	= { FOLLOW_port_in_hostport6792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_semi_in_uri_parameters6828  */
static	ANTLR3_BITWORD FOLLOW_semi_in_uri_parameters6828_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE47FC0) };
static  ANTLR3_BITSET_LIST FOLLOW_semi_in_uri_parameters6828	= { FOLLOW_semi_in_uri_parameters6828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_parameter_in_uri_parameters6830  */
static	ANTLR3_BITWORD FOLLOW_uri_parameter_in_uri_parameters6830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_parameter_in_uri_parameters6830	= { FOLLOW_uri_parameter_in_uri_parameters6830_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_uri_parameters6834  */
static	ANTLR3_BITWORD FOLLOW_lws_in_uri_parameters6834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_uri_parameters6834	= { FOLLOW_lws_in_uri_parameters6834_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_uri_parameters6837  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_uri_parameters6837_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010032) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_uri_parameters6837	= { FOLLOW_SEMI_in_uri_parameters6837_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_other_param_in_uri_parameter6857  */
static	ANTLR3_BITWORD FOLLOW_other_param_in_uri_parameter6857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_other_param_in_uri_parameter6857	= { FOLLOW_other_param_in_uri_parameter6857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pname_in_other_param6873  */
static	ANTLR3_BITWORD FOLLOW_pname_in_other_param6873_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pname_in_other_param6873	= { FOLLOW_pname_in_other_param6873_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pname_in_other_param6885  */
static	ANTLR3_BITWORD FOLLOW_pname_in_other_param6885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_pname_in_other_param6885	= { FOLLOW_pname_in_other_param6885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_other_param6887  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_other_param6887_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE47FC0) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_other_param6887	= { FOLLOW_EQUAL_in_other_param6887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pvalue_in_other_param6889  */
static	ANTLR3_BITWORD FOLLOW_pvalue_in_other_param6889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pvalue_in_other_param6889	= { FOLLOW_pvalue_in_other_param6889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramchar_in_pname6922  */
static	ANTLR3_BITWORD FOLLOW_paramchar_in_pname6922_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE47FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_paramchar_in_pname6922	= { FOLLOW_paramchar_in_pname6922_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_paramchar_in_pvalue6946  */
static	ANTLR3_BITWORD FOLLOW_paramchar_in_pvalue6946_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE47FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_paramchar_in_pvalue6946	= { FOLLOW_paramchar_in_pvalue6946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_unreserved_in_paramchar6971  */
static	ANTLR3_BITWORD FOLLOW_param_unreserved_in_paramchar6971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_param_unreserved_in_paramchar6971	= { FOLLOW_param_unreserved_in_paramchar6971_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_paramchar6975  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_paramchar6975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_paramchar6975	= { FOLLOW_unreserved_in_paramchar6975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_paramchar6979  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_paramchar6979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_paramchar6979	= { FOLLOW_escaped_in_paramchar6979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_param_unreserved0  */
static	ANTLR3_BITWORD FOLLOW_set_in_param_unreserved0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_param_unreserved0	= { FOLLOW_set_in_param_unreserved0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QMARK_in_headers7057  */
static	ANTLR3_BITWORD FOLLOW_QMARK_in_headers7057_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC0) };
static  ANTLR3_BITSET_LIST FOLLOW_QMARK_in_headers7057	= { FOLLOW_QMARK_in_headers7057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_header_in_headers7059  */
static	ANTLR3_BITWORD FOLLOW_uri_header_in_headers7059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_header_in_headers7059	= { FOLLOW_uri_header_in_headers7059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_headers7063  */
static	ANTLR3_BITWORD FOLLOW_AND_in_headers7063_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC0) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_headers7063	= { FOLLOW_AND_in_headers7063_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_header_in_headers7065  */
static	ANTLR3_BITWORD FOLLOW_uri_header_in_headers7065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_header_in_headers7065	= { FOLLOW_uri_header_in_headers7065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hname_in_uri_header7110  */
static	ANTLR3_BITWORD FOLLOW_hname_in_uri_header7110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_hname_in_uri_header7110	= { FOLLOW_hname_in_uri_header7110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_uri_header7112  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_uri_header7112_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_uri_header7112	= { FOLLOW_EQUAL_in_uri_header7112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hvalue_in_uri_header7115  */
static	ANTLR3_BITWORD FOLLOW_hvalue_in_uri_header7115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hvalue_in_uri_header7115	= { FOLLOW_hvalue_in_uri_header7115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hnv_unreserved_in_hname7140  */
static	ANTLR3_BITWORD FOLLOW_hnv_unreserved_in_hname7140_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_hnv_unreserved_in_hname7140	= { FOLLOW_hnv_unreserved_in_hname7140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_hname7144  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_hname7144_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_hname7144	= { FOLLOW_unreserved_in_hname7144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_hname7148  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_hname7148_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_hname7148	= { FOLLOW_escaped_in_hname7148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hnv_unreserved_in_hvalue7170  */
static	ANTLR3_BITWORD FOLLOW_hnv_unreserved_in_hvalue7170_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_hnv_unreserved_in_hvalue7170	= { FOLLOW_hnv_unreserved_in_hvalue7170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unreserved_in_hvalue7174  */
static	ANTLR3_BITWORD FOLLOW_unreserved_in_hvalue7174_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_unreserved_in_hvalue7174	= { FOLLOW_unreserved_in_hvalue7174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_escaped_in_hvalue7178  */
static	ANTLR3_BITWORD FOLLOW_escaped_in_hvalue7178_bits[]	= { ANTLR3_UINT64_LIT(0x000000786EE67FC2) };
static  ANTLR3_BITSET_LIST FOLLOW_escaped_in_hvalue7178	= { FOLLOW_escaped_in_hvalue7178_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_hnv_unreserved0  */
static	ANTLR3_BITWORD FOLLOW_set_in_hnv_unreserved0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_hnv_unreserved0	= { FOLLOW_set_in_hnv_unreserved0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_user_unreserved0  */
static	ANTLR3_BITWORD FOLLOW_set_in_user_unreserved0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_user_unreserved0	= { FOLLOW_set_in_user_unreserved0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hostname_in_host7300  */
static	ANTLR3_BITWORD FOLLOW_hostname_in_host7300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hostname_in_host7300	= { FOLLOW_hostname_in_host7300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv4address_in_host7326  */
static	ANTLR3_BITWORD FOLLOW_ipv4address_in_host7326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv4address_in_host7326	= { FOLLOW_ipv4address_in_host7326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv6reference_in_host7352  */
static	ANTLR3_BITWORD FOLLOW_ipv6reference_in_host7352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv6reference_in_host7352	= { FOLLOW_ipv6reference_in_host7352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_domainlabel_in_hostname7374  */
static	ANTLR3_BITWORD FOLLOW_domainlabel_in_hostname7374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_domainlabel_in_hostname7374	= { FOLLOW_domainlabel_in_hostname7374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_hostname7376  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_hostname7376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_hostname7376	= { FOLLOW_DOT_in_hostname7376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_toplabel_in_hostname7385  */
static	ANTLR3_BITWORD FOLLOW_toplabel_in_hostname7385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_toplabel_in_hostname7385	= { FOLLOW_toplabel_in_hostname7385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_hostname7387  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_hostname7387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_hostname7387	= { FOLLOW_DOT_in_hostname7387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel7405  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel7405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel7405	= { FOLLOW_alphanum_in_domainlabel7405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel7410  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel7410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060040080) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel7410	= { FOLLOW_alphanum_in_domainlabel7410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel7414  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel7414_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060040080) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel7414	= { FOLLOW_alphanum_in_domainlabel7414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_domainlabel7418  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_domainlabel7418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060040080) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_domainlabel7418	= { FOLLOW_DASH_in_domainlabel7418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_domainlabel7423  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_domainlabel7423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_domainlabel7423	= { FOLLOW_alphanum_in_domainlabel7423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_toplabel7441  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_toplabel7441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_toplabel7441	= { FOLLOW_alpha_in_toplabel7441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_toplabel7446  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_toplabel7446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060040080) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_toplabel7446	= { FOLLOW_alpha_in_toplabel7446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_toplabel7451  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_toplabel7451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_toplabel7451	= { FOLLOW_DASH_in_toplabel7451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_toplabel7455  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_toplabel7455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000060040082) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_toplabel7455	= { FOLLOW_alphanum_in_toplabel7455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address7471  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address7471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address7471	= { FOLLOW_three_digit_in_ipv4address7471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_ipv4address7473  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_ipv4address7473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_ipv4address7473	= { FOLLOW_DOT_in_ipv4address7473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address7475  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address7475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address7475	= { FOLLOW_three_digit_in_ipv4address7475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_ipv4address7477  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_ipv4address7477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_ipv4address7477	= { FOLLOW_DOT_in_ipv4address7477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address7479  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address7479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address7479	= { FOLLOW_three_digit_in_ipv4address7479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_ipv4address7481  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_ipv4address7481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_ipv4address7481	= { FOLLOW_DOT_in_ipv4address7481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ipv4address7483  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ipv4address7483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ipv4address7483	= { FOLLOW_three_digit_in_ipv4address7483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSBRAQUET_in_ipv6reference7493  */
static	ANTLR3_BITWORD FOLLOW_LSBRAQUET_in_ipv6reference7493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000280) };
static  ANTLR3_BITSET_LIST FOLLOW_LSBRAQUET_in_ipv6reference7493	= { FOLLOW_LSBRAQUET_in_ipv6reference7493_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv6address_in_ipv6reference7495  */
static	ANTLR3_BITWORD FOLLOW_ipv6address_in_ipv6reference7495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv6address_in_ipv6reference7495	= { FOLLOW_ipv6address_in_ipv6reference7495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSBRAQUET_in_ipv6reference7497  */
static	ANTLR3_BITWORD FOLLOW_RSBRAQUET_in_ipv6reference7497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RSBRAQUET_in_ipv6reference7497	= { FOLLOW_RSBRAQUET_in_ipv6reference7497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexpart_in_ipv6address7510  */
static	ANTLR3_BITWORD FOLLOW_hexpart_in_ipv6address7510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_hexpart_in_ipv6address7510	= { FOLLOW_hexpart_in_ipv6address7510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_ipv6address7514  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_ipv6address7514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_ipv6address7514	= { FOLLOW_COLON_in_ipv6address7514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv4address_in_ipv6address7516  */
static	ANTLR3_BITWORD FOLLOW_ipv4address_in_ipv6address7516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv4address_in_ipv6address7516	= { FOLLOW_ipv4address_in_ipv6address7516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart7535  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart7535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart7535	= { FOLLOW_hexseq_in_hexpart7535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart7539  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart7539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart7539	= { FOLLOW_hexseq_in_hexpart7539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart7541  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart7541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart7541	= { FOLLOW_COLON_in_hexpart7541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart7543  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart7543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000082) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart7543	= { FOLLOW_COLON_in_hexpart7543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart7547  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart7547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart7547	= { FOLLOW_hexseq_in_hexpart7547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart7554  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart7554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart7554	= { FOLLOW_COLON_in_hexpart7554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart7556  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart7556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000082) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart7556	= { FOLLOW_COLON_in_hexpart7556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart7560  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart7560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart7560	= { FOLLOW_hexseq_in_hexpart7560_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hex4_in_hexseq7579  */
static	ANTLR3_BITWORD FOLLOW_hex4_in_hexseq7579_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_hex4_in_hexseq7579	= { FOLLOW_hex4_in_hexseq7579_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexseq7583  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexseq7583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000080) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexseq7583	= { FOLLOW_COLON_in_hexseq7583_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hex4_in_hexseq7585  */
static	ANTLR3_BITWORD FOLLOW_hex4_in_hexseq7585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_hex4_in_hexseq7585	= { FOLLOW_hex4_in_hexseq7585_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_hex47605  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_hex47605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000082) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_hex47605	= { FOLLOW_hexdigit_in_hex47605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_port7627  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_port7627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000082) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_port7627	= { FOLLOW_DIGIT_in_port7627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PERCENT_in_escaped7643  */
static	ANTLR3_BITWORD FOLLOW_PERCENT_in_escaped7643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000080) };
static  ANTLR3_BITSET_LIST FOLLOW_PERCENT_in_escaped7643	= { FOLLOW_PERCENT_in_escaped7643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_escaped7645  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_escaped7645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000080) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_escaped7645	= { FOLLOW_hexdigit_in_escaped7645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_escaped7647  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_escaped7647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_escaped7647	= { FOLLOW_hexdigit_in_escaped7647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_three_digit_in_ttl7654  */
static	ANTLR3_BITWORD FOLLOW_three_digit_in_ttl7654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_three_digit_in_ttl7654	= { FOLLOW_three_digit_in_ttl7654_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit7666  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit7666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit7666	= { FOLLOW_DIGIT_in_three_digit7666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit7705  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit7705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit7705	= { FOLLOW_DIGIT_in_three_digit7705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit7707  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit7707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit7707	= { FOLLOW_DIGIT_in_three_digit7707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit7748  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit7748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit7748	= { FOLLOW_DIGIT_in_three_digit7748_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit7750  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit7750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit7750	= { FOLLOW_DIGIT_in_three_digit7750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_three_digit7752  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_three_digit7752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_three_digit7752	= { FOLLOW_DIGIT_in_three_digit7752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_token7774  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_token7774_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42182) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_token7774	= { FOLLOW_alphanum_in_token7774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mark_in_token7778  */
static	ANTLR3_BITWORD FOLLOW_mark_in_token7778_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42182) };
static  ANTLR3_BITSET_LIST FOLLOW_mark_in_token7778	= { FOLLOW_mark_in_token7778_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PERCENT_in_token7782  */
static	ANTLR3_BITWORD FOLLOW_PERCENT_in_token7782_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42182) };
static  ANTLR3_BITSET_LIST FOLLOW_PERCENT_in_token7782	= { FOLLOW_PERCENT_in_token7782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_token7786  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_token7786_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42182) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_token7786	= { FOLLOW_PLUS_in_token7786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BQUOTE_in_token7790  */
static	ANTLR3_BITWORD FOLLOW_BQUOTE_in_token7790_bits[]	= { ANTLR3_UINT64_LIT(0x0000007878E42182) };
static  ANTLR3_BITSET_LIST FOLLOW_BQUOTE_in_token7790	= { FOLLOW_BQUOTE_in_token7790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_reserved_for_from_to_contact_addr_spec0  */
static	ANTLR3_BITWORD FOLLOW_set_in_reserved_for_from_to_contact_addr_spec0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_reserved_for_from_to_contact_addr_spec0	= { FOLLOW_set_in_reserved_for_from_to_contact_addr_spec0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_reserved7845  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_reserved7845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_reserved7845	= { FOLLOW_SEMI_in_reserved7845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_reserved7849  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_reserved7849_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_reserved7849	= { FOLLOW_COMMA_in_reserved7849_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QMARK_in_reserved7854  */
static	ANTLR3_BITWORD FOLLOW_QMARK_in_reserved7854_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QMARK_in_reserved7854	= { FOLLOW_QMARK_in_reserved7854_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_reserved_for_from_to_contact_addr_spec_in_reserved7859  */
static	ANTLR3_BITWORD FOLLOW_reserved_for_from_to_contact_addr_spec_in_reserved7859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_reserved_for_from_to_contact_addr_spec_in_reserved7859	= { FOLLOW_reserved_for_from_to_contact_addr_spec_in_reserved7859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_unreserved7892  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_unreserved7892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_unreserved7892	= { FOLLOW_alphanum_in_unreserved7892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mark_in_unreserved7895  */
static	ANTLR3_BITWORD FOLLOW_mark_in_unreserved7895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_mark_in_unreserved7895	= { FOLLOW_mark_in_unreserved7895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_alphanum7908  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_alphanum7908_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_alphanum7908	= { FOLLOW_alpha_in_alphanum7908_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_alphanum7912  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_alphanum7912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_alphanum7912	= { FOLLOW_DIGIT_in_alphanum7912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_hexdigit0  */
static	ANTLR3_BITWORD FOLLOW_set_in_hexdigit0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_hexdigit0	= { FOLLOW_set_in_hexdigit0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_alpha0  */
static	ANTLR3_BITWORD FOLLOW_set_in_alpha0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_alpha0	= { FOLLOW_set_in_alpha0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alphanum_in_word7982  */
static	ANTLR3_BITWORD FOLLOW_alphanum_in_word7982_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_alphanum_in_word7982	= { FOLLOW_alphanum_in_word7982_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mark_in_word7986  */
static	ANTLR3_BITWORD FOLLOW_mark_in_word7986_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_mark_in_word7986	= { FOLLOW_mark_in_word7986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PERCENT_in_word7992  */
static	ANTLR3_BITWORD FOLLOW_PERCENT_in_word7992_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_PERCENT_in_word7992	= { FOLLOW_PERCENT_in_word7992_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_word8019  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_word8019_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_word8019	= { FOLLOW_PLUS_in_word8019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BQUOTE_in_word8023  */
static	ANTLR3_BITWORD FOLLOW_BQUOTE_in_word8023_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_BQUOTE_in_word8023	= { FOLLOW_BQUOTE_in_word8023_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LAQUOT_in_word8048  */
static	ANTLR3_BITWORD FOLLOW_LAQUOT_in_word8048_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_LAQUOT_in_word8048	= { FOLLOW_LAQUOT_in_word8048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RAQUOT_in_word8052  */
static	ANTLR3_BITWORD FOLLOW_RAQUOT_in_word8052_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_RAQUOT_in_word8052	= { FOLLOW_RAQUOT_in_word8052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_word8077  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_word8077_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_word8077	= { FOLLOW_COLON_in_word8077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BSLASH_in_word8081  */
static	ANTLR3_BITWORD FOLLOW_BSLASH_in_word8081_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_BSLASH_in_word8081	= { FOLLOW_BSLASH_in_word8081_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_word8085  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_word8085_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_word8085	= { FOLLOW_DQUOTE_in_word8085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_word8089  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_word8089_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_word8089	= { FOLLOW_SLASH_in_word8089_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSBRAQUET_in_word8093  */
static	ANTLR3_BITWORD FOLLOW_LSBRAQUET_in_word8093_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_LSBRAQUET_in_word8093	= { FOLLOW_LSBRAQUET_in_word8093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSBRAQUET_in_word8097  */
static	ANTLR3_BITWORD FOLLOW_RSBRAQUET_in_word8097_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_RSBRAQUET_in_word8097	= { FOLLOW_RSBRAQUET_in_word8097_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QMARK_in_word8101  */
static	ANTLR3_BITWORD FOLLOW_QMARK_in_word8101_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_QMARK_in_word8101	= { FOLLOW_QMARK_in_word8101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACE_in_word8105  */
static	ANTLR3_BITWORD FOLLOW_LBRACE_in_word8105_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACE_in_word8105	= { FOLLOW_LBRACE_in_word8105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RBRACE_in_word8109  */
static	ANTLR3_BITWORD FOLLOW_RBRACE_in_word8109_bits[]	= { ANTLR3_UINT64_LIT(0x0000007FFEFE23C2) };
static  ANTLR3_BITSET_LIST FOLLOW_RBRACE_in_word8109	= { FOLLOW_RBRACE_in_word8109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_mark0  */
static	ANTLR3_BITWORD FOLLOW_set_in_mark0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_mark0	= { FOLLOW_set_in_mark0_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_sp_tab_colon8172  */
static	ANTLR3_BITWORD FOLLOW_set_in_sp_tab_colon8172_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000220) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_sp_tab_colon8172	= { FOLLOW_set_in_sp_tab_colon8172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_sp_tab_colon8183  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_sp_tab_colon8183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_sp_tab_colon8183	= { FOLLOW_COLON_in_sp_tab_colon8183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sp_tab_colon_in_hcolon8193  */
static	ANTLR3_BITWORD FOLLOW_sp_tab_colon_in_hcolon8193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_sp_tab_colon_in_hcolon8193	= { FOLLOW_sp_tab_colon_in_hcolon8193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_hcolon8195  */
static	ANTLR3_BITWORD FOLLOW_lws_in_hcolon8195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_hcolon8195	= { FOLLOW_lws_in_hcolon8195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_ldquot8216  */
static	ANTLR3_BITWORD FOLLOW_lws_in_ldquot8216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_ldquot8216	= { FOLLOW_lws_in_ldquot8216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_ldquot8219  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_ldquot8219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_ldquot8219	= { FOLLOW_DQUOTE_in_ldquot8219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DQUOTE_in_rdquot8227  */
static	ANTLR3_BITWORD FOLLOW_DQUOTE_in_rdquot8227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_DQUOTE_in_rdquot8227	= { FOLLOW_DQUOTE_in_rdquot8227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_rdquot8229  */
static	ANTLR3_BITWORD FOLLOW_lws_in_rdquot8229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_rdquot8229	= { FOLLOW_lws_in_rdquot8229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_semi8236  */
static	ANTLR3_BITWORD FOLLOW_lws_in_semi8236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_semi8236	= { FOLLOW_lws_in_semi8236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEMI_in_semi8239  */
static	ANTLR3_BITWORD FOLLOW_SEMI_in_semi8239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_SEMI_in_semi8239	= { FOLLOW_SEMI_in_semi8239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_semi8241  */
static	ANTLR3_BITWORD FOLLOW_lws_in_semi8241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_semi8241	= { FOLLOW_lws_in_semi8241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_comma8249  */
static	ANTLR3_BITWORD FOLLOW_lws_in_comma8249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_comma8249	= { FOLLOW_lws_in_comma8249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_comma8252  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_comma8252_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_comma8252	= { FOLLOW_COMMA_in_comma8252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_comma8254  */
static	ANTLR3_BITWORD FOLLOW_lws_in_comma8254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_comma8254	= { FOLLOW_lws_in_comma8254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_sp_laquot8264  */
static	ANTLR3_BITWORD FOLLOW_lws_in_sp_laquot8264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_sp_laquot8264	= { FOLLOW_lws_in_sp_laquot8264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LAQUOT_in_sp_laquot8267  */
static	ANTLR3_BITWORD FOLLOW_LAQUOT_in_sp_laquot8267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LAQUOT_in_sp_laquot8267	= { FOLLOW_LAQUOT_in_sp_laquot8267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RAQUOT_in_raquot_sp8277  */
static	ANTLR3_BITWORD FOLLOW_RAQUOT_in_raquot_sp8277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_RAQUOT_in_raquot_sp8277	= { FOLLOW_RAQUOT_in_raquot_sp8277_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_raquot_sp8279  */
static	ANTLR3_BITWORD FOLLOW_lws_in_raquot_sp8279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_raquot_sp8279	= { FOLLOW_lws_in_raquot_sp8279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_equal8289  */
static	ANTLR3_BITWORD FOLLOW_lws_in_equal8289_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_equal8289	= { FOLLOW_lws_in_equal8289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_equal8292  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_equal8292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_equal8292	= { FOLLOW_EQUAL_in_equal8292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_equal8294  */
static	ANTLR3_BITWORD FOLLOW_lws_in_equal8294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_equal8294	= { FOLLOW_lws_in_equal8294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_slash8302  */
static	ANTLR3_BITWORD FOLLOW_lws_in_slash8302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_slash8302	= { FOLLOW_lws_in_slash8302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_slash8305  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_slash8305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000032) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_slash8305	= { FOLLOW_SLASH_in_slash8305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lws_in_slash8307  */
static	ANTLR3_BITWORD FOLLOW_lws_in_slash8307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lws_in_slash8307	= { FOLLOW_lws_in_slash8307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_lws8316  */
static	ANTLR3_BITWORD FOLLOW_SP_in_lws8316_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000030) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_lws8316	= { FOLLOW_SP_in_lws8316_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_lws8319  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_lws8319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_lws8319	= { FOLLOW_CRLF_in_lws8319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_lws8321  */
static	ANTLR3_BITWORD FOLLOW_SP_in_lws8321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_lws8321	= { FOLLOW_SP_in_lws8321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SP_in_lws8327  */
static	ANTLR3_BITWORD FOLLOW_SP_in_lws8327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_SP_in_lws8327	= { FOLLOW_SP_in_lws8327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred1_belle_sip_message174  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred1_belle_sip_message174_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFE0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred1_belle_sip_message174	= { FOLLOW_set_in_synpred1_belle_sip_message174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_version_in_synpred1_belle_sip_message180  */
static	ANTLR3_BITWORD FOLLOW_sip_version_in_synpred1_belle_sip_message180_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_version_in_synpred1_belle_sip_message180	= { FOLLOW_sip_version_in_synpred1_belle_sip_message180_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_synpred1_belle_sip_message182  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_synpred1_belle_sip_message182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_synpred1_belle_sip_message182	= { FOLLOW_CRLF_in_synpred1_belle_sip_message182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred2_belle_sip_message202  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred2_belle_sip_message202_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFE0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred2_belle_sip_message202	= { FOLLOW_set_in_synpred2_belle_sip_message202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_http_version_in_synpred2_belle_sip_message208  */
static	ANTLR3_BITWORD FOLLOW_http_version_in_synpred2_belle_sip_message208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_http_version_in_synpred2_belle_sip_message208	= { FOLLOW_http_version_in_synpred2_belle_sip_message208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_synpred2_belle_sip_message210  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_synpred2_belle_sip_message210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_synpred2_belle_sip_message210	= { FOLLOW_CRLF_in_synpred2_belle_sip_message210_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sip_version_in_synpred3_belle_sip_message558  */
static	ANTLR3_BITWORD FOLLOW_sip_version_in_synpred3_belle_sip_message558_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_sip_version_in_synpred3_belle_sip_message558	= { FOLLOW_sip_version_in_synpred3_belle_sip_message558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred3_belle_sip_message561  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred3_belle_sip_message561_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred3_belle_sip_message561	= { FOLLOW_set_in_synpred3_belle_sip_message561_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_synpred3_belle_sip_message567  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_synpred3_belle_sip_message567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_synpred3_belle_sip_message567	= { FOLLOW_CRLF_in_synpred3_belle_sip_message567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_http_version_in_synpred4_belle_sip_message589  */
static	ANTLR3_BITWORD FOLLOW_http_version_in_synpred4_belle_sip_message589_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_http_version_in_synpred4_belle_sip_message589	= { FOLLOW_http_version_in_synpred4_belle_sip_message589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred4_belle_sip_message591  */
static	ANTLR3_BITWORD FOLLOW_set_in_synpred4_belle_sip_message591_bits[]	= { ANTLR3_UINT64_LIT(0x000001FFFFFFFFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred4_belle_sip_message591	= { FOLLOW_set_in_synpred4_belle_sip_message591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CRLF_in_synpred4_belle_sip_message598  */
static	ANTLR3_BITWORD FOLLOW_CRLF_in_synpred4_belle_sip_message598_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CRLF_in_synpred4_belle_sip_message598	= { FOLLOW_CRLF_in_synpred4_belle_sip_message598_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_synpred6_belle_sip_message1253  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_synpred6_belle_sip_message1253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_synpred6_belle_sip_message1253	= { FOLLOW_SLASH_in_synpred6_belle_sip_message1253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_synpred6_belle_sip_message1255  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_synpred6_belle_sip_message1255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_synpred6_belle_sip_message1255	= { FOLLOW_SLASH_in_synpred6_belle_sip_message1255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_segments_in_synpred6_belle_sip_message1257  */
static	ANTLR3_BITWORD FOLLOW_path_segments_in_synpred6_belle_sip_message1257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_segments_in_synpred6_belle_sip_message1257	= { FOLLOW_path_segments_in_synpred6_belle_sip_message1257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_synpred7_belle_sip_message1279  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_synpred7_belle_sip_message1279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_synpred7_belle_sip_message1279	= { FOLLOW_SLASH_in_synpred7_belle_sip_message1279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_synpred7_belle_sip_message1281  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_synpred7_belle_sip_message1281_bits[]	= { ANTLR3_UINT64_LIT(0x000000786AE7FFC0) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_synpred7_belle_sip_message1281	= { FOLLOW_SLASH_in_synpred7_belle_sip_message1281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authority_in_synpred7_belle_sip_message1283  */
static	ANTLR3_BITWORD FOLLOW_authority_in_synpred7_belle_sip_message1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000042) };
static  ANTLR3_BITSET_LIST FOLLOW_authority_in_synpred7_belle_sip_message1283	= { FOLLOW_authority_in_synpred7_belle_sip_message1283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_path_segments_in_synpred7_belle_sip_message1287  */
static	ANTLR3_BITWORD FOLLOW_path_segments_in_synpred7_belle_sip_message1287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_path_segments_in_synpred7_belle_sip_message1287	= { FOLLOW_path_segments_in_synpred7_belle_sip_message1287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authority_userinfo_in_synpred8_belle_sip_message1519  */
static	ANTLR3_BITWORD FOLLOW_authority_userinfo_in_synpred8_belle_sip_message1519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_authority_userinfo_in_synpred8_belle_sip_message1519	= { FOLLOW_authority_userinfo_in_synpred8_belle_sip_message1519_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userinfo_in_synpred9_belle_sip_message6475  */
static	ANTLR3_BITWORD FOLLOW_userinfo_in_synpred9_belle_sip_message6475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_userinfo_in_synpred9_belle_sip_message6475	= { FOLLOW_userinfo_in_synpred9_belle_sip_message6475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userinfo_in_synpred10_belle_sip_message6545  */
static	ANTLR3_BITWORD FOLLOW_userinfo_in_synpred10_belle_sip_message6545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_userinfo_in_synpred10_belle_sip_message6545	= { FOLLOW_userinfo_in_synpred10_belle_sip_message6545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_unreserved_in_synpred11_belle_sip_message6968  */
static	ANTLR3_BITWORD FOLLOW_param_unreserved_in_synpred11_belle_sip_message6968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_param_unreserved_in_synpred11_belle_sip_message6968	= { FOLLOW_param_unreserved_in_synpred11_belle_sip_message6968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_toplabel_in_synpred12_belle_sip_message7382  */
static	ANTLR3_BITWORD FOLLOW_toplabel_in_synpred12_belle_sip_message7382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_toplabel_in_synpred12_belle_sip_message7382	= { FOLLOW_toplabel_in_synpred12_belle_sip_message7382_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_synpred13_belle_sip_message7661  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_synpred13_belle_sip_message7661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_synpred13_belle_sip_message7661	= { FOLLOW_DIGIT_in_synpred13_belle_sip_message7661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_synpred14_belle_sip_message7697  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_synpred14_belle_sip_message7697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_synpred14_belle_sip_message7697	= { FOLLOW_DIGIT_in_synpred14_belle_sip_message7697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_synpred14_belle_sip_message7699  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_synpred14_belle_sip_message7699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_synpred14_belle_sip_message7699	= { FOLLOW_DIGIT_in_synpred14_belle_sip_message7699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_synpred15_belle_sip_message7739  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_synpred15_belle_sip_message7739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_synpred15_belle_sip_message7739	= { FOLLOW_DIGIT_in_synpred15_belle_sip_message7739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_synpred15_belle_sip_message7741  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_synpred15_belle_sip_message7741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_synpred15_belle_sip_message7741	= { FOLLOW_DIGIT_in_synpred15_belle_sip_message7741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_synpred15_belle_sip_message7743  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_synpred15_belle_sip_message7743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_synpred15_belle_sip_message7743	= { FOLLOW_DIGIT_in_synpred15_belle_sip_message7743_bits, 1	};
     


/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    104:1: message_raw[size_t* length] returns [belle_sip_message_t* ret] : ( common_request | common_response );
 */
static const ANTLR3_INT32 dfa1_eot[4] =
    {
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_eof[4] =
    {
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_min[4] =
    {
	7, 5, -1, -1
    };
static const ANTLR3_INT32 dfa1_max[4] =
    {
	38, 38, -1, -1
    };
static const ANTLR3_INT32 dfa1_accept[4] =
    {
	-1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa1_special[4] =
    {	
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa1_T_empty	    NULL

static const ANTLR3_INT32 dfa1_T0[] =
    {
	2, 2, -1, -1, -1, -1, 2, -1, -1, -1, -1, 2, -1, -1, 2, 2, 2, -1, -1, -1, 
	2, 2, 1, 1, -1, -1, -1, -1, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa1_T1[] =
    {
	2, 3, 2, 2, -1, -1, -1, -1, 2, -1, -1, -1, -1, 2, -1, -1, 2, 2, 2, -1, 
	-1, -1, 2, 2, 1, 1, -1, -1, -1, -1, 2, 2, 2, 2
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa1_transitions[] =
{
    dfa1_T0, dfa1_T1, dfa1_T_empty, dfa1_T_empty	
};


/* Declare tracking structure for Cyclic DFA 1
 */
static
ANTLR3_CYCLIC_DFA cdfa1
    =	{
	    1,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"104:1: message_raw[size_t* length] returns [belle_sip_message_t* ret] : ( common_request | common_response );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa1_eot,	    /* EOT table			    */
	    dfa1_eof,	    /* EOF table			    */
	    dfa1_min,	    /* Minimum tokens for each state    */
	    dfa1_max,	    /* Maximum tokens for each state    */
	    dfa1_accept,	/* Accept table			    */
	    dfa1_special,	/* Special transition states	    */
	    dfa1_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 1
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    220:7: ( ( sip_version (~ ( CRLF ) )* CRLF )=> status_line | ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line )
 */
static const ANTLR3_INT32 dfa6_eot[15] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa6_eof[15] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa6_min[15] =
    {
	29, 6, 7, 8, 7, 5, 7, 7, 7, 5, 4, 4, 0, -1, -1
    };
static const ANTLR3_INT32 dfa6_max[15] =
    {
	30, 30, 7, 8, 7, 5, 7, 7, 7, 5, 40, 40, 0, -1, -1
    };
static const ANTLR3_INT32 dfa6_accept[15] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa6_special[15] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa6_T_empty	    NULL

static const ANTLR3_INT32 dfa6_T0[] =
    {
	7
    };static const ANTLR3_INT32 dfa6_T1[] =
    {
	12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 
	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 
	11
    };static const ANTLR3_INT32 dfa6_T2[] =
    {
	8
    };static const ANTLR3_INT32 dfa6_T3[] =
    {
	3
    };static const ANTLR3_INT32 dfa6_T4[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1, 1
    };static const ANTLR3_INT32 dfa6_T5[] =
    {
	9
    };static const ANTLR3_INT32 dfa6_T6[] =
    {
	-1
    };static const ANTLR3_INT32 dfa6_T7[] =
    {
	4
    };static const ANTLR3_INT32 dfa6_T8[] =
    {
	6
    };static const ANTLR3_INT32 dfa6_T9[] =
    {
	5
    };static const ANTLR3_INT32 dfa6_T10[] =
    {
	10
    };static const ANTLR3_INT32 dfa6_T11[] =
    {
	1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa6_transitions[] =
{
    dfa6_T11, dfa6_T4, dfa6_T3, dfa6_T7, dfa6_T9, dfa6_T8, dfa6_T0, dfa6_T2, 
    dfa6_T5, dfa6_T10, dfa6_T1, dfa6_T1, dfa6_T6, dfa6_T_empty, dfa6_T_empty	
};

static ANTLR3_INT32 dfa6_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA6_12;

    	    ANTLR3_MARKER index6_12;


    		LA6_12 = LA(1);

    	 
    	    index6_12 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (( (synpred3_belle_sip_message(ctx)) && ((IS_TOKEN(SIP/))) )) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (( (synpred4_belle_sip_message(ctx)) && ((IS_TOKEN(HTTP/))) )) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index6_12);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"220:7: ( ( sip_version (~ ( CRLF ) )* CRLF )=> status_line | ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line )";
    EXCEPTION->decisionNum  = 6;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 6
 */
static
ANTLR3_CYCLIC_DFA cdfa6
    =	{
	    6,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"220:7: ( ( sip_version (~ ( CRLF ) )* CRLF )=> status_line | ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line )",	
	    (CDFA_SPECIAL_FUNC) dfa6_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa6_eot,	    /* EOT table			    */
	    dfa6_eof,	    /* EOF table			    */
	    dfa6_min,	    /* Minimum tokens for each state    */
	    dfa6_max,	    /* Maximum tokens for each state    */
	    dfa6_accept,	/* Accept table			    */
	    dfa6_special,	/* Special transition states	    */
	    dfa6_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 6
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    344:5: ( ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] ) | ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? ) | ( path_segments[uri] ) )
 */
static const ANTLR3_INT32 dfa18_eot[164] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR3_INT32 dfa18_eof[164] =
    {
	-1, 3, 3, -1, -1, -1, 3, 3, -1, 3, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, 3, 3, 
	3, 3, 3, -1, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, -1, 
	3, 3, 3, 3, 3, -1, -1, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, -1, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	-1, 3, -1, 3, -1
    };
static const ANTLR3_INT32 dfa18_min[164] =
    {
	6, 4, 4, -1, 6, 0, 4, 4, 7, 4, 4, 4, 4, 4, 4, 6, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 
	0, 4, 4, 7, 4, 4, 4, 7, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 
	7, 0, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0
    };
static const ANTLR3_INT32 dfa18_max[164] =
    {
	6, 38, 38, -1, 38, 0, 38, 38, 29, 38, 38, 38, 38, 38, 38, 38, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 38, 38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 
	38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 0, 38, 38, 29, 
	38, 38, 38, 29, 38, 38, 38, 38, 38, 0, 38, 38, 38, 38, 29, 38, 38, 38, 
	38, 38, 29, 0, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 29, 38, 38, 38, 
	38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	0, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 0, 38, 0, 38, 0
    };
static const ANTLR3_INT32 dfa18_accept[164] =
    {
	-1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 2, 2, 
	2, 2, 2, 2, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa18_special[164] =
    {	
	-1, -1, 11, -1, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, 9, -1, 1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa18_T_empty	    NULL

static const ANTLR3_INT32 dfa18_T0[] =
    {
	3, 3, 26, 56, 28, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T1[] =
    {
	3, 3, 3, 129, 114, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T2[] =
    {
	3, 3, 3, 120, 102, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T3[] =
    {
	3, 3, 3, 85, 86, 3, 54, 88, 89, 90, 91, 92, 3, 3, 86, -1, -1, 86, 86, 86, 
	-1, -1, -1, 87, -1, 84, 84, -1, 3, -1, -1, 86, 86, 86, 86
    };static const ANTLR3_INT32 dfa18_T4[] =
    {
	3, 3, 3, 162, 157, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T5[] =
    {
	3, 3, 26, 25, 28, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T6[] =
    {
	3, 3, 3, 112, 114, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T7[] =
    {
	3, 3, 3, 126, 125, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T8[] =
    {
	3, 3, 26, 144, 134, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T9[] =
    {
	3, 3, 26, 116, 98, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T10[] =
    {
	3, 3, 3, 150, 143, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T11[] =
    {
	3, 3, 3, 120, 137, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T12[] =
    {
	-1
    };static const ANTLR3_INT32 dfa18_T13[] =
    {
	3, 3, 3, 141, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 94, 94, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T14[] =
    {
	3, 3, 3, 156, 157, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T15[] =
    {
	3, 3, 3, 120, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T16[] =
    {
	3, 3, 3, 120, 153, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T17[] =
    {
	3, 3, 26, 36, 37, 39, 40, 41, 42, 43, 44, 45, 14, 15, 37, -1, -1, 37, 37, 
	37, -1, -1, -1, 38, -1, 35, 35, -1, 3, -1, -1, 37, 37, 37, 37
    };static const ANTLR3_INT32 dfa18_T18[] =
    {
	3, 3, 26, 97, 98, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T19[] =
    {
	3, 3, 3, 142, 143, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T20[] =
    {
	3, 3, 26, 133, 134, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T21[] =
    {
	3, 3, 26, 33, 7, 29, 30, 9, 10, 11, 12, 13, 14, 15, 7, -1, -1, 7, 7, 7, 
	-1, -1, -1, 8, -1, 32, 32, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T22[] =
    {
	3, 3, 3, 120, 121, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T23[] =
    {
	3, 3, 3, 74, 75, 3, 40, 77, 78, 79, 80, 81, 3, 3, 75, -1, -1, 75, 75, 75, 
	-1, -1, -1, 76, -1, 73, 73, -1, 3, -1, -1, 75, 75, 75, 75
    };static const ANTLR3_INT32 dfa18_T24[] =
    {
	3, 3, 26, 57, 98, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T25[] =
    {
	3, 3, 3, 130, 143, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T26[] =
    {
	3, 3, 26, 57, 28, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T27[] =
    {
	3, 3, 3, 130, 114, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T28[] =
    {
	3, 3, 26, 57, 134, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T29[] =
    {
	3, 3, 3, 83, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, 16, 
	-1, 3, -1, 82, 82, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T30[] =
    {
	3, 3, 3, 130, 157, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T31[] =
    {
	3, 3, 3, 61, 62, 3, 30, 64, 65, 66, 67, 68, 3, 3, 62, -1, -1, 62, 62, 62, 
	-1, -1, -1, 63, -1, 60, 60, -1, 3, -1, -1, 62, 62, 62, 62
    };static const ANTLR3_INT32 dfa18_T32[] =
    {
	3, 3, 3, 130, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T33[] =
    {
	3, 3, 26, 96, 7, 29, 30, 9, 10, 11, 12, 13, 14, 15, 7, -1, -1, 7, 7, 7, 
	-1, -1, -1, 8, -1, 5, 5, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T34[] =
    {
	71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 71
    };static const ANTLR3_INT32 dfa18_T35[] =
    {
	104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 104
    };static const ANTLR3_INT32 dfa18_T36[] =
    {
	111, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 111
    };static const ANTLR3_INT32 dfa18_T37[] =
    {
	118, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 118
    };static const ANTLR3_INT32 dfa18_T38[] =
    {
	123, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 123
    };static const ANTLR3_INT32 dfa18_T39[] =
    {
	128, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 128
    };static const ANTLR3_INT32 dfa18_T40[] =
    {
	3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	3, -1, 3, 3, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T41[] =
    {
	3, 3, 55, 51, 52, 49, 54, 55, 55, 55, 55, 47, 46, 48, 52, -1, -1, 52, 52, 
	52, -1, -1, -1, 53, -1, 50, 50, -1, 3, -1, -1, 52, 52, 52, 52
    };static const ANTLR3_INT32 dfa18_T42[] =
    {
	3, 3, 3, 70, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, 16, 
	-1, 3, -1, 69, 69, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T43[] =
    {
	3, 3, 3, 130, 131, 3, 3, 3, 3, 3, 3, 3, 3, 3, 115, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 113, 113, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T44[] =
    {
	3, 3, 26, 57, 58, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 
	7, -1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T45[] =
    {
	3, 3, 26, 57, 7, 29, 30, 9, 10, 11, 12, 13, 14, 15, 31, -1, -1, 7, 7, 7, 
	-1, -1, -1, 8, -1, 27, 27, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T46[] =
    {
	3, 3, 3, 127, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 82, 82, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T47[] =
    {
	3, 3, 3, 149, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 82, 82, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T48[] =
    {
	3, 3, 3, 161, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 82, 82, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T49[] =
    {
	55, 51, 52, 49, 54, 55, 55, 55, 55, 47, 46, 48, 52, -1, -1, 52, 52, 52, 
	-1, -1, -1, 53, -1, 50, 50, -1, -1, -1, -1, 52, 52, 52, 52
    };static const ANTLR3_INT32 dfa18_T50[] =
    {
	34, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 34
    };static const ANTLR3_INT32 dfa18_T51[] =
    {
	72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 72
    };static const ANTLR3_INT32 dfa18_T52[] =
    {
	93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 93
    };static const ANTLR3_INT32 dfa18_T53[] =
    {
	99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 99
    };static const ANTLR3_INT32 dfa18_T54[] =
    {
	105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 105
    };static const ANTLR3_INT32 dfa18_T55[] =
    {
	110, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 110
    };static const ANTLR3_INT32 dfa18_T56[] =
    {
	3, 3, 3, 122, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 69, 69, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T57[] =
    {
	3, 3, 3, 147, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 69, 69, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T58[] =
    {
	1
    };static const ANTLR3_INT32 dfa18_T59[] =
    {
	3, 3, 3, 159, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 69, 69, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T60[] =
    {
	3, 3, 3, 151, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 94, 94, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T61[] =
    {
	3, 3, 3, 132, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 94, 94, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T62[] =
    {
	3, 3, 3, 163, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 94, 94, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T63[] =
    {
	23, 18, 19, 21, 22, 23, 23, 23, 23, 23, 23, 23, 19, -1, -1, 19, 19, 19, 
	-1, -1, -1, 20, -1, 17, 17, -1, -1, -1, -1, 19, 19, 19, 19
    };static const ANTLR3_INT32 dfa18_T64[] =
    {
	3, 3, 3, 148, 140, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T65[] =
    {
	3, 3, 3, 124, 108, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T66[] =
    {
	3, 3, 3, 139, 140, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T67[] =
    {
	3, 3, 3, 160, 155, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T68[] =
    {
	3, 3, 3, 106, 108, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T69[] =
    {
	3, 3, 3, 154, 155, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T70[] =
    {
	3, 3, 3, 138, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 82, 82, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T71[] =
    {
	3, 3, 26, 117, 7, 29, 30, 9, 10, 11, 12, 13, 14, 15, 7, -1, -1, 7, 7, 7, 
	-1, -1, -1, 8, -1, 5, 5, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T72[] =
    {
	3, 3, 3, 95, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, 16, 
	-1, 3, -1, 94, 94, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T73[] =
    {
	3, 3, 3, 146, 137, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T74[] =
    {
	3, 3, 3, 119, 102, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T75[] =
    {
	3, 3, 26, 59, 7, 29, 30, 9, 10, 11, 12, 13, 14, 15, 7, -1, -1, 7, 7, 7, 
	-1, -1, -1, 8, -1, 5, 5, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T76[] =
    {
	3, 3, 3, 136, 137, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T77[] =
    {
	3, 3, 3, 126, 108, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T78[] =
    {
	3, 3, 26, 145, 7, 29, 30, 9, 10, 11, 12, 13, 14, 15, 7, -1, -1, 7, 7, 7, 
	-1, -1, -1, 8, -1, 5, 5, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T79[] =
    {
	3, 3, 3, 158, 153, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T80[] =
    {
	3, 3, 3, 100, 102, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T81[] =
    {
	3, 3, 3, 152, 153, 3, 3, 3, 3, 3, 3, 3, 3, 3, 103, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 101, 101, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T82[] =
    {
	3, 3, 4, 6, 7, 3, 3, 9, 10, 11, 12, 13, 14, 15, 7, -1, -1, 7, 7, 7, -1, 
	16, -1, 8, -1, 5, 5, -1, 3, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa18_T83[] =
    {
	3, 3, 3, 135, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 69, 69, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T84[] =
    {
	3, 3, 3, 126, 140, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T85[] =
    {
	3, 3, 3, 126, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa18_T86[] =
    {
	3, 3, 3, 126, 155, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, -1, -1, 3, 3, 3, -1, 
	-1, -1, 3, -1, 107, 107, -1, 3, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa18_transitions[] =
{
    dfa18_T58, dfa18_T40, dfa18_T82, dfa18_T_empty, dfa18_T63, dfa18_T12, 
    dfa18_T5, dfa18_T21, dfa18_T50, dfa18_T21, dfa18_T21, dfa18_T21, dfa18_T21, 
    dfa18_T21, dfa18_T17, dfa18_T49, dfa18_T_empty, dfa18_T_empty, dfa18_T_empty, 
    dfa18_T_empty, dfa18_T_empty, dfa18_T_empty, dfa18_T_empty, dfa18_T_empty, 
    dfa18_T_empty, dfa18_T0, dfa18_T21, dfa18_T44, dfa18_T75, dfa18_T31, 
    dfa18_T42, dfa18_T45, dfa18_T21, dfa18_T21, dfa18_T34, dfa18_T17, dfa18_T17, 
    dfa18_T17, dfa18_T51, dfa18_T23, dfa18_T29, dfa18_T17, dfa18_T17, dfa18_T17, 
    dfa18_T17, dfa18_T17, dfa18_T41, dfa18_T41, dfa18_T41, dfa18_T3, dfa18_T41, 
    dfa18_T41, dfa18_T41, dfa18_T52, dfa18_T72, dfa18_T41, dfa18_T26, dfa18_T44, 
    dfa18_T33, dfa18_T18, dfa18_T31, dfa18_T31, dfa18_T31, dfa18_T53, dfa18_T31, 
    dfa18_T31, dfa18_T31, dfa18_T31, dfa18_T31, dfa18_T12, dfa18_T80, dfa18_T21, 
    dfa18_T35, dfa18_T23, dfa18_T23, dfa18_T23, dfa18_T54, dfa18_T23, dfa18_T23, 
    dfa18_T23, dfa18_T23, dfa18_T23, dfa18_T12, dfa18_T68, dfa18_T3, dfa18_T3, 
    dfa18_T3, dfa18_T55, dfa18_T3, dfa18_T3, dfa18_T3, dfa18_T3, dfa18_T3, 
    dfa18_T36, dfa18_T12, dfa18_T6, dfa18_T44, dfa18_T9, dfa18_T71, dfa18_T37, 
    dfa18_T74, dfa18_T22, dfa18_T56, dfa18_T15, dfa18_T17, dfa18_T38, dfa18_T65, 
    dfa18_T7, dfa18_T46, dfa18_T85, dfa18_T39, dfa18_T41, dfa18_T1, dfa18_T43, 
    dfa18_T61, dfa18_T32, dfa18_T24, dfa18_T20, dfa18_T31, dfa18_T2, dfa18_T22, 
    dfa18_T83, dfa18_T76, dfa18_T23, dfa18_T77, dfa18_T70, dfa18_T7, dfa18_T66, 
    dfa18_T3, dfa18_T27, dfa18_T43, dfa18_T13, dfa18_T19, dfa18_T8, dfa18_T78, 
    dfa18_T22, dfa18_T73, dfa18_T57, dfa18_T7, dfa18_T64, dfa18_T47, dfa18_T43, 
    dfa18_T10, dfa18_T60, dfa18_T28, dfa18_T12, dfa18_T11, dfa18_T81, dfa18_T84, 
    dfa18_T69, dfa18_T25, dfa18_T14, dfa18_T79, dfa18_T59, dfa18_T67, dfa18_T48, 
    dfa18_T4, dfa18_T62, dfa18_T16, dfa18_T12, dfa18_T86, dfa18_T12, dfa18_T30, 
    dfa18_T12	
};

static ANTLR3_INT32 dfa18_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA18_145;

    	    ANTLR3_MARKER index18_145;


    		LA18_145 = LA(1);

    	 
    	    index18_145 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_145);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA18_163;

    	    ANTLR3_MARKER index18_163;


    		LA18_163 = LA(1);

    	 
    	    index18_163 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_163);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA18_40;

    	    ANTLR3_MARKER index18_40;


    		LA18_40 = LA(1);

    	 
    	    index18_40 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA18_40 == EOF || ((LA18_40 >= CRLF) && (LA18_40 <= SLASH)) || ((LA18_40 >= DOT) && (LA18_40 <= DASH)) || ((LA18_40 >= STAR) && (LA18_40 <= RPAREN)) || LA18_40 == PERCENT || LA18_40 == RAQUOT || ((LA18_40 >= USCORE) && (LA18_40 <= SQUOTE))) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (((LA18_40 >= HEX_CHAR) && (LA18_40 <= COMMON_CHAR))) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA18_40 == DIGIT) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA18_40 == LSBRAQUET) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	 
    		SEEK(index18_40);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA18_82;

    	    ANTLR3_MARKER index18_82;


    		LA18_82 = LA(1);

    	 
    	    index18_82 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_82);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA18_5;

    	    ANTLR3_MARKER index18_5;


    		LA18_5 = LA(1);

    	 
    	    index18_5 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_5);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA18_30;

    	    ANTLR3_MARKER index18_30;


    		LA18_30 = LA(1);

    	 
    	    index18_30 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA18_30 == EOF || ((LA18_30 >= CRLF) && (LA18_30 <= SLASH)) || ((LA18_30 >= DOT) && (LA18_30 <= DASH)) || ((LA18_30 >= STAR) && (LA18_30 <= RPAREN)) || LA18_30 == PERCENT || LA18_30 == RAQUOT || ((LA18_30 >= USCORE) && (LA18_30 <= SQUOTE))) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (((LA18_30 >= HEX_CHAR) && (LA18_30 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA18_30 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA18_30 == LSBRAQUET) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	 
    		SEEK(index18_30);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA18_69;

    	    ANTLR3_MARKER index18_69;


    		LA18_69 = LA(1);

    	 
    	    index18_69 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_69);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA18_94;

    	    ANTLR3_MARKER index18_94;


    		LA18_94 = LA(1);

    	 
    	    index18_94 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_94);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 8:
        
    	{
    	    ANTLR3_UINT32 LA18_4;

    	    ANTLR3_MARKER index18_4;


    		LA18_4 = LA(1);

    	 
    	    index18_4 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA18_4 >= HEX_CHAR) && (LA18_4 <= COMMON_CHAR))) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA18_4 == DIGIT) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA18_4 == DOT || LA18_4 == DASH || ((LA18_4 >= STAR) && (LA18_4 <= RPAREN)) || ((LA18_4 >= USCORE) && (LA18_4 <= SQUOTE))) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA18_4 == PERCENT) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA18_4 == COLON) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA18_4 == AT) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 22;
    	    }

    	    else if ( (LA18_4 == SLASH || ((LA18_4 >= AND) && (LA18_4 <= QMARK))) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 23;
    	    }

    	    else if ( (synpred6_belle_sip_message(ctx)) )
    	    {
    	        s = 24;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_4);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 9:
        
    	{
    	    ANTLR3_UINT32 LA18_161;

    	    ANTLR3_MARKER index18_161;


    		LA18_161 = LA(1);

    	 
    	    index18_161 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_161);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 10:
        
    	{
    	    ANTLR3_UINT32 LA18_54;

    	    ANTLR3_MARKER index18_54;


    		LA18_54 = LA(1);

    	 
    	    index18_54 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA18_54 == EOF || ((LA18_54 >= CRLF) && (LA18_54 <= SLASH)) || ((LA18_54 >= DOT) && (LA18_54 <= DASH)) || ((LA18_54 >= STAR) && (LA18_54 <= RPAREN)) || LA18_54 == PERCENT || LA18_54 == RAQUOT || ((LA18_54 >= USCORE) && (LA18_54 <= SQUOTE))) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (((LA18_54 >= HEX_CHAR) && (LA18_54 <= COMMON_CHAR))) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA18_54 == DIGIT) )
    	    {
    	        s = 95;
    	    }

    	    else if ( (LA18_54 == LSBRAQUET) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	 
    		SEEK(index18_54);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 11:
        
    	{
    	    ANTLR3_UINT32 LA18_2;

    	    ANTLR3_MARKER index18_2;


    		LA18_2 = LA(1);

    	 
    	    index18_2 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA18_2 == SLASH) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (((LA18_2 >= HEX_CHAR) && (LA18_2 <= COMMON_CHAR))) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA18_2 == DIGIT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA18_2 == DOT || LA18_2 == DASH || ((LA18_2 >= STAR) && (LA18_2 <= RPAREN)) || ((LA18_2 >= USCORE) && (LA18_2 <= SQUOTE))) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA18_2 == PERCENT) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA18_2 == EOF || ((LA18_2 >= CRLF) && (LA18_2 <= SP)) || ((LA18_2 >= COLON) && (LA18_2 <= AT)) || LA18_2 == RAQUOT) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA18_2 == AND) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA18_2 == EQUAL) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA18_2 == PLUS) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA18_2 == DOLLARD) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA18_2 == COMMA) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA18_2 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA18_2 == QMARK) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA18_2 == LSBRAQUET) && (synpred7_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	 
    		SEEK(index18_2);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 12:
        
    	{
    	    ANTLR3_UINT32 LA18_159;

    	    ANTLR3_MARKER index18_159;


    		LA18_159 = LA(1);

    	 
    	    index18_159 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred7_belle_sip_message(ctx)) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index18_159);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"344:5: ( ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] ) | ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? ) | ( path_segments[uri] ) )";
    EXCEPTION->decisionNum  = 18;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 18
 */
static
ANTLR3_CYCLIC_DFA cdfa18
    =	{
	    18,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"344:5: ( ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] ) | ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? ) | ( path_segments[uri] ) )",	
	    (CDFA_SPECIAL_FUNC) dfa18_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa18_eot,	    /* EOT table			    */
	    dfa18_eof,	    /* EOF table			    */
	    dfa18_min,	    /* Minimum tokens for each state    */
	    dfa18_max,	    /* Maximum tokens for each state    */
	    dfa18_accept,	/* Accept table			    */
	    dfa18_special,	/* Special transition states	    */
	    dfa18_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 18
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    377:3: ( ( authority_userinfo[NULL] )=> authority_userinfo[uri] )?
 */
static const ANTLR3_INT32 dfa28_eot[262] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa28_eof[262] =
    {
	-1, 6, -1, -1, -1, -1, -1, 6, 6, -1, 6, -1, 6, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, 6, 6, 6, -1, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, -1, -1, -1, -1, -1, 6, 6, 6, 
	-1, 6, 6, 6, 6, 6, -1, 6, -1, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	-1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, 6, 6, 6, -1, 6, -1, -1, 
	-1, 6, -1, 6, 6, 6, 6, -1, 6, 6, 6, -1, 6, 6, 6, 6, 6, -1, 6, -1, 6, 6, 
	6, -1, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, -1, 6, 6, 
	6, 6, 6, -1, -1, 6, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, -1, 
	6, 6, 6, -1, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, 6, 
	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, -1, 6, 6, 6, 6, 6, 6, 6, -1, 6, -1, 6, -1, 6, 6, 6, -1
    };
static const ANTLR3_INT32 dfa28_min[262] =
    {
	6, 4, 6, -1, -1, -1, -1, 4, 4, 6, 4, 7, 4, 6, -1, 6, 6, 6, 6, -1, 6, -1, 
	4, -1, -1, -1, -1, -1, -1, -1, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 7, 4, 4, 4, 4, 6, 6, 6, 6, 7, 4, 4, 4, 7, 4, 4, 4, 4, 4, 0, 
	4, -1, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 0, 4, 7, 6, 6, 4, 7, 4, 4, 4, 4, 7, 4, 4, 
	4, 7, 4, 4, 4, 4, 4, 0, 4, 7, 4, 4, 4, 7, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 
	7, 4, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 7, 4, 
	4, 4, 4, 4, 7, 4, 4, 4, 4, 7, 4, 4, 4, 7, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 
	4, 4, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 
	4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 
	4, 0
    };
static const ANTLR3_INT32 dfa28_max[262] =
    {
	38, 38, 38, -1, -1, -1, -1, 38, 38, 38, 38, 38, 38, 38, -1, 38, 38, 38, 
	38, -1, 38, -1, 38, -1, -1, -1, -1, -1, -1, -1, 38, 38, 38, 29, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 
	38, 38, 38, 29, 38, 38, 38, 29, 38, 38, 38, 38, 38, 0, 38, -1, 38, 38, 
	38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 0, 38, 29, 38, 38, 38, 
	29, 38, 38, 38, 38, 29, 38, 38, 38, 29, 38, 38, 38, 38, 38, 0, 38, 29, 
	38, 38, 38, 29, 38, 38, 38, 38, 38, 0, 38, 38, 38, 38, 29, 38, 38, 38, 
	38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	29, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 29, 38, 38, 38, 29, 38, 38, 
	38, 38, 38, 0, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 0, 38, 38, 38, 38, 38, 38, 
	38, 0, 38, 0, 38, 0, 38, 38, 38, 0
    };
static const ANTLR3_INT32 dfa28_accept[262] =
    {
	-1, -1, -1, 1, 1, 1, 2, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, 
	1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa28_special[262] =
    {	
	38, 39, 23, -1, -1, -1, -1, 17, 32, 27, 42, 10, -1, -1, -1, 3, 15, 0, 9, 
	-1, 35, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, 
	-1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 28, 24, 
	31, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, 
	-1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, 4, 16, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, 8, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 26, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19, -1, -1, -1, -1, -1, -1, 6, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, 34, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 36, -1, 2, -1, -1, -1, -1, -1, -1, -1, 
	33, -1, 41, -1, 1, -1, -1, -1, 40
    };

/** Used when there is no transition table entry for a particular state */
#define dfa28_T_empty	    NULL

static const ANTLR3_INT32 dfa28_T0[] =
    {
	6, 6, 6, 197, 220, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T1[] =
    {
	6, 6, 6, 226, 240, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T2[] =
    {
	6, 6, 6, 197, 166, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T3[] =
    {
	6, 6, 6, 226, 210, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T4[] =
    {
	5, 55, 56, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T5[] =
    {
	6, 6, 6, 197, 247, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T6[] =
    {
	6, 6, 6, 226, 259, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T7[] =
    {
	6, 6, 6, 222, 223, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T8[] =
    {
	6, 6, 6, 109, 112, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T9[] =
    {
	6, 6, 6, 169, 172, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T10[] =
    {
	6, 6, 52, 46, 47, 43, 44, 52, 52, 52, 52, 50, 49, 51, 47, -1, -1, 47, 47, 
	47, -1, -1, -1, 48, -1, 45, 45, -1, 6, -1, -1, 47, 47, 47, 47
    };static const ANTLR3_INT32 dfa28_T11[] =
    {
	6, 6, 6, 232, 233, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T12[] =
    {
	6, 6, 6, 248, 249, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T13[] =
    {
	6, 6, 6, 193, 194, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T14[] =
    {
	6, 6, 6, 226, 227, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T15[] =
    {
	6, 6, 6, 197, 198, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T16[] =
    {
	6, 6, 6, 127, 128, 6, 86, 130, 131, 132, 133, 134, 6, 6, 128, -1, -1, 128, 
	128, 128, -1, -1, -1, 129, -1, 126, 126, -1, 6, -1, -1, 128, 128, 128, 
	128
    };static const ANTLR3_INT32 dfa28_T17[] =
    {
	6, 6, 6, 96, 97, 6, 44, 94, 99, 100, 101, 93, 6, 6, 97, -1, -1, 97, 97, 
	97, -1, -1, -1, 98, -1, 95, 95, -1, 6, -1, -1, 97, 97, 97, 97
    };static const ANTLR3_INT32 dfa28_T18[] =
    {
	6, 6, 6, 59, 60, 6, 35, 62, 63, 64, 65, 66, 6, 6, 60, -1, -1, 60, 60, 60, 
	-1, -1, -1, 61, -1, 58, 58, -1, 6, -1, -1, 60, 60, 60, 60
    };static const ANTLR3_INT32 dfa28_T19[] =
    {
	-1
    };static const ANTLR3_INT32 dfa28_T20[] =
    {
	5, 53, 16, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T21[] =
    {
	5, 154, 106, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T22[] =
    {
	6, 6, 6, 158, 194, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T23[] =
    {
	52, 46, 47, 43, 44, 52, 52, 52, 52, 50, 49, 51, 47, -1, -1, 47, 47, 47, 
	-1, -1, -1, 48, -1, 45, 45, -1, -1, -1, -1, 47, 47, 47, 47
    };static const ANTLR3_INT32 dfa28_T24[] =
    {
	6, 6, 6, 202, 223, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T25[] =
    {
	6, 6, 6, 103, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, 69, 
	-1, 6, -1, 102, 102, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T26[] =
    {
	6, 6, 6, 158, 112, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T27[] =
    {
	5, 214, 191, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T28[] =
    {
	6, 6, 6, 202, 172, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T29[] =
    {
	6, 6, 6, 158, 233, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T30[] =
    {
	6, 6, 6, 202, 249, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T31[] =
    {
	57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 57
    };static const ANTLR3_INT32 dfa28_T32[] =
    {
	108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 108
    };static const ANTLR3_INT32 dfa28_T33[] =
    {
	113, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 113
    };static const ANTLR3_INT32 dfa28_T34[] =
    {
	125, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 125
    };static const ANTLR3_INT32 dfa28_T35[] =
    {
	162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 162
    };static const ANTLR3_INT32 dfa28_T36[] =
    {
	168, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 168
    };static const ANTLR3_INT32 dfa28_T37[] =
    {
	173, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 173
    };static const ANTLR3_INT32 dfa28_T38[] =
    {
	206, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 206
    };static const ANTLR3_INT32 dfa28_T39[] =
    {
	6, 6, 42, 138, 139, 141, 142, 143, 144, 145, 146, 147, 92, 13, 139, -1, 
	-1, 139, 139, 139, -1, -1, -1, 140, -1, 137, 137, -1, 6, -1, -1, 139, 139, 
	139, 139
    };static const ANTLR3_INT32 dfa28_T40[] =
    {
	6, 6, 42, 71, 72, 74, 75, 76, 77, 78, 79, 80, 41, 13, 72, -1, -1, 72, 72, 
	72, -1, -1, -1, 73, -1, 70, 70, -1, 6, -1, -1, 72, 72, 72, 72
    };static const ANTLR3_INT32 dfa28_T41[] =
    {
	6, 6, 6, 226, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T42[] =
    {
	6, 6, 6, 202, 203, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T43[] =
    {
	6, 6, 6, 158, 159, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T44[] =
    {
	6, 6, 6, 187, 188, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T45[] =
    {
	6, 6, 6, 197, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T46[] =
    {
	6, 6, 6, 115, 116, 6, 75, 118, 119, 120, 121, 122, 6, 6, 116, -1, -1, 116, 
	116, 116, -1, -1, -1, 117, -1, 114, 114, -1, 6, -1, -1, 116, 116, 116, 
	116
    };static const ANTLR3_INT32 dfa28_T47[] =
    {
	6, 6, 6, 175, 176, 6, 142, 178, 179, 180, 181, 182, 6, 6, 176, -1, -1, 
	176, 176, 176, -1, -1, -1, 177, -1, 174, 174, -1, 6, -1, -1, 176, 176, 
	176, 176
    };static const ANTLR3_INT32 dfa28_T48[] =
    {
	6, 6, 6, 124, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, 69, 
	-1, 6, -1, 123, 123, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T49[] =
    {
	6, 6, 6, 184, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, 69, 
	-1, 6, -1, 183, 183, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T50[] =
    {
	5, 55, 3, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T51[] =
    {
	6, 6, 6, 229, 213, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T52[] =
    {
	6, 6, 6, 186, 152, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T53[] =
    {
	6, 6, 42, 82, 83, 85, 86, 87, 88, 89, 90, 91, 92, 13, 83, -1, -1, 83, 83, 
	83, -1, -1, -1, 84, -1, 81, 81, -1, 6, -1, -1, 83, 83, 83, 83
    };static const ANTLR3_INT32 dfa28_T54[] =
    {
	6, 6, 6, 252, 242, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T55[] =
    {
	6, 6, 42, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 13, 32, -1, -1, 32, 32, 
	32, -1, -1, -1, 33, -1, 30, 30, -1, 6, -1, -1, 32, 32, 32, 32
    };static const ANTLR3_INT32 dfa28_T56[] =
    {
	6, 6, 6, 202, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T57[] =
    {
	22, 23, -1, 14, 25, 26, 27, 28, 29, -1, -1, 23, -1, -1, 23, 23, 23, -1, 
	-1, -1, 24, -1, 21, 21, -1, -1, -1, -1, 23, 23, 23, 23
    };static const ANTLR3_INT32 dfa28_T58[] =
    {
	6, 6, 6, 158, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T59[] =
    {
	6, 6, 6, 68, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, 69, 
	-1, 6, -1, 67, 67, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T60[] =
    {
	6, 6, 6, 136, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, 69, 
	-1, 6, -1, 135, 135, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T61[] =
    {
	6, 6, 12, 243, 56, 11, 14, 5, 5, 5, 5, 5, 5, 13, 18, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 17, 17, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T62[] =
    {
	6, 6, 6, 199, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 123, 123, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T63[] =
    {
	6, 6, 6, 228, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 183, 183, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T64[] =
    {
	6, 6, 6, 255, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 123, 123, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T65[] =
    {
	6, 6, 6, 261, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 183, 183, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T66[] =
    {
	6, 6, 6, 235, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 123, 123, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T67[] =
    {
	6, 6, 6, 251, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 183, 183, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T68[] =
    {
	6, 6, 6, 187, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T69[] =
    {
	6, 6, 6, 22, 23, -1, 14, 25, 26, 27, 28, 29, -1, 6, 23, -1, -1, 23, 23, 
	23, -1, -1, -1, 24, -1, 21, 21, -1, 6, -1, -1, 23, 23, 23, 23
    };static const ANTLR3_INT32 dfa28_T70[] =
    {
	6, 6, 6, 250, 240, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T71[] =
    {
	107, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 107
    };static const ANTLR3_INT32 dfa28_T72[] =
    {
	156, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 156
    };static const ANTLR3_INT32 dfa28_T73[] =
    {
	161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 161
    };static const ANTLR3_INT32 dfa28_T74[] =
    {
	167, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 167
    };static const ANTLR3_INT32 dfa28_T75[] =
    {
	195, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 195
    };static const ANTLR3_INT32 dfa28_T76[] =
    {
	6, 6, 6, 196, 166, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T77[] =
    {
	200, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 200
    };static const ANTLR3_INT32 dfa28_T78[] =
    {
	224, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 224
    };static const ANTLR3_INT32 dfa28_T79[] =
    {
	205, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 205
    };static const ANTLR3_INT32 dfa28_T80[] =
    {
	6, 6, 6, 160, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 67, 67, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T81[] =
    {
	6, 6, 6, 225, 210, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T82[] =
    {
	5, 54, 3, 19, 14, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T83[] =
    {
	6, 6, 6, 204, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 135, 135, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T84[] =
    {
	5, 155, 3, 19, 14, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T85[] =
    {
	6, 6, 6, 245, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 67, 67, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T86[] =
    {
	6, 6, 6, 254, 247, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T87[] =
    {
	6, 6, 6, 257, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 135, 135, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T88[] =
    {
	6, 6, 12, 8, 10, 11, 14, 5, 5, 5, 5, 5, 5, 13, 9, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 7, 7, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T89[] =
    {
	6, 6, 6, 217, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 67, 67, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T90[] =
    {
	6, 6, 6, 260, 259, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T91[] =
    {
	6, 6, 6, 234, 220, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T92[] =
    {
	6, 6, 6, 237, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 135, 135, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T93[] =
    {
	5, 215, 3, 19, 14, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T94[] =
    {
	6, 6, 6, 236, 223, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T95[] =
    {
	6, 6, 6, 157, 112, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T96[] =
    {
	6, 6, 6, 201, 172, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T97[] =
    {
	6, 6, 6, 189, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 102, 102, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T98[] =
    {
	6, 6, 6, 244, 233, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T99[] =
    {
	6, 6, 6, 256, 249, 6, 6, 6, 6, 6, 6, 6, 6, 6, 171, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 170, 170, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T100[] =
    {
	6, 6, 6, 216, 194, 6, 6, 6, 6, 6, 6, 6, 6, 6, 111, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 110, 110, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T101[] =
    {
	6, 6, 6, 218, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 123, 123, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T102[] =
    {
	6, 6, 6, 230, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 102, 102, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T103[] =
    {
	6, 6, 6, 238, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 183, 183, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T104[] =
    {
	6, 6, 6, 253, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 102, 102, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T105[] =
    {
	5, 15, 16, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T106[] =
    {
	153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 153
    };static const ANTLR3_INT32 dfa28_T107[] =
    {
	185, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 185
    };static const ANTLR3_INT32 dfa28_T108[] =
    {
	5, 105, 106, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T109[] =
    {
	5, 20, 3, 19, 14, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T110[] =
    {
	5, 190, 191, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T111[] =
    {
	6, 6, 6, 192, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 67, 67, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T112[] =
    {
	5, 8, 3, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 7, 7, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T113[] =
    {
	6, 6, 6, 221, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 135, 135, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T114[] =
    {
	5, 55, 16, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T115[] =
    {
	5, 55, 106, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T116[] =
    {
	5, 55, 191, 19, 14, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T117[] =
    {
	6, 6, 6, 212, 213, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T118[] =
    {
	6, 6, 6, 149, 152, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T119[] =
    {
	6, 6, 6, 241, 242, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T120[] =
    {
	104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 104
    };static const ANTLR3_INT32 dfa28_T121[] =
    {
	148, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148
    };static const ANTLR3_INT32 dfa28_T122[] =
    {
	6, 6, 6, 211, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, -1, -1, 6, 6, 6, -1, -1, 
	-1, 6, -1, 102, 102, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T123[] =
    {
	6, 6, 6, 187, 213, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T124[] =
    {
	6, 6, 6, 187, 152, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T125[] =
    {
	6, 6, 12, 231, 56, 11, 14, 5, 5, 5, 5, 5, 5, 13, 18, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 17, 17, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T126[] =
    {
	6, 6, 6, 187, 242, 6, 6, 6, 6, 6, 6, 6, 6, 6, 151, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 150, 150, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T127[] =
    {
	6, 6, 12, 55, 56, 11, 14, 5, 5, 5, 5, 5, 5, 13, 18, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 17, 17, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T128[] =
    {
	5, 2, 3, -1, -1, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, 6, -1, 4, 
	-1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa28_T129[] =
    {
	6, 6, 6, 239, 240, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T130[] =
    {
	6, 6, 6, 163, 166, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T131[] =
    {
	6, 6, 6, 207, 210, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T132[] =
    {
	6, 6, 6, 246, 247, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T133[] =
    {
	6, 6, 6, 258, 259, 6, 6, 6, 6, 6, 6, 6, 6, 6, 209, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 208, 208, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T134[] =
    {
	6, 6, 6, 219, 220, 6, 6, 6, 6, 6, 6, 6, 6, 6, 165, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, -1, 164, 164, -1, 6, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa28_T135[] =
    {
	6, 6, 12, 20, 3, 11, 14, 5, 5, 5, 5, 5, 5, 13, 3, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 1, 1, -1, 6, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa28_transitions[] =
{
    dfa28_T128, dfa28_T88, dfa28_T105, dfa28_T_empty, dfa28_T_empty, dfa28_T_empty, 
    dfa28_T_empty, dfa28_T88, dfa28_T88, dfa28_T112, dfa28_T135, dfa28_T57, 
    dfa28_T55, dfa28_T23, dfa28_T_empty, dfa28_T20, dfa28_T82, dfa28_T4, 
    dfa28_T50, dfa28_T_empty, dfa28_T4, dfa28_T_empty, dfa28_T69, dfa28_T_empty, 
    dfa28_T_empty, dfa28_T_empty, dfa28_T_empty, dfa28_T_empty, dfa28_T_empty, 
    dfa28_T_empty, dfa28_T55, dfa28_T55, dfa28_T55, dfa28_T31, dfa28_T18, 
    dfa28_T59, dfa28_T55, dfa28_T55, dfa28_T55, dfa28_T55, dfa28_T55, dfa28_T40, 
    dfa28_T53, dfa28_T17, dfa28_T25, dfa28_T10, dfa28_T10, dfa28_T10, dfa28_T120, 
    dfa28_T10, dfa28_T10, dfa28_T10, dfa28_T10, dfa28_T114, dfa28_T108, 
    dfa28_T4, dfa28_T109, dfa28_T71, dfa28_T18, dfa28_T18, dfa28_T18, dfa28_T32, 
    dfa28_T18, dfa28_T18, dfa28_T18, dfa28_T18, dfa28_T18, dfa28_T19, dfa28_T8, 
    dfa28_T_empty, dfa28_T40, dfa28_T40, dfa28_T40, dfa28_T33, dfa28_T46, 
    dfa28_T48, dfa28_T40, dfa28_T40, dfa28_T40, dfa28_T40, dfa28_T40, dfa28_T53, 
    dfa28_T53, dfa28_T53, dfa28_T34, dfa28_T16, dfa28_T60, dfa28_T53, dfa28_T53, 
    dfa28_T53, dfa28_T53, dfa28_T53, dfa28_T39, dfa28_T17, dfa28_T17, dfa28_T17, 
    dfa28_T17, dfa28_T17, dfa28_T121, dfa28_T17, dfa28_T17, dfa28_T17, dfa28_T19, 
    dfa28_T118, dfa28_T106, dfa28_T21, dfa28_T84, dfa28_T55, dfa28_T72, 
    dfa28_T95, dfa28_T43, dfa28_T58, dfa28_T80, dfa28_T73, dfa28_T46, dfa28_T46, 
    dfa28_T46, dfa28_T35, dfa28_T46, dfa28_T46, dfa28_T46, dfa28_T46, dfa28_T46, 
    dfa28_T19, dfa28_T130, dfa28_T74, dfa28_T16, dfa28_T16, dfa28_T16, dfa28_T36, 
    dfa28_T16, dfa28_T16, dfa28_T16, dfa28_T16, dfa28_T16, dfa28_T19, dfa28_T9, 
    dfa28_T39, dfa28_T39, dfa28_T39, dfa28_T37, dfa28_T47, dfa28_T49, dfa28_T39, 
    dfa28_T39, dfa28_T39, dfa28_T39, dfa28_T39, dfa28_T107, dfa28_T52, dfa28_T44, 
    dfa28_T68, dfa28_T97, dfa28_T10, dfa28_T115, dfa28_T110, dfa28_T18, 
    dfa28_T26, dfa28_T43, dfa28_T111, dfa28_T13, dfa28_T40, dfa28_T75, dfa28_T76, 
    dfa28_T15, dfa28_T45, dfa28_T62, dfa28_T53, dfa28_T77, dfa28_T96, dfa28_T42, 
    dfa28_T56, dfa28_T83, dfa28_T79, dfa28_T47, dfa28_T47, dfa28_T47, dfa28_T38, 
    dfa28_T47, dfa28_T47, dfa28_T47, dfa28_T47, dfa28_T47, dfa28_T19, dfa28_T131, 
    dfa28_T17, dfa28_T124, dfa28_T44, dfa28_T122, dfa28_T117, dfa28_T27, 
    dfa28_T93, dfa28_T43, dfa28_T100, dfa28_T89, dfa28_T46, dfa28_T2, dfa28_T15, 
    dfa28_T101, dfa28_T134, dfa28_T16, dfa28_T28, dfa28_T42, dfa28_T113, 
    dfa28_T7, dfa28_T39, dfa28_T78, dfa28_T81, dfa28_T14, dfa28_T41, dfa28_T63, 
    dfa28_T44, dfa28_T51, dfa28_T102, dfa28_T116, dfa28_T125, dfa28_T22, 
    dfa28_T11, dfa28_T15, dfa28_T91, dfa28_T66, dfa28_T42, dfa28_T94, dfa28_T92, 
    dfa28_T47, dfa28_T3, dfa28_T14, dfa28_T103, dfa28_T129, dfa28_T123, 
    dfa28_T119, dfa28_T61, dfa28_T98, dfa28_T85, dfa28_T0, dfa28_T132, dfa28_T24, 
    dfa28_T12, dfa28_T14, dfa28_T70, dfa28_T67, dfa28_T54, dfa28_T104, dfa28_T127, 
    dfa28_T29, dfa28_T19, dfa28_T86, dfa28_T64, dfa28_T99, dfa28_T87, dfa28_T1, 
    dfa28_T133, dfa28_T126, dfa28_T19, dfa28_T5, dfa28_T19, dfa28_T30, dfa28_T19, 
    dfa28_T90, dfa28_T65, dfa28_T6, dfa28_T19	
};

static ANTLR3_INT32 dfa28_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA28_17;

    	    ANTLR3_MARKER index28_17;


    		LA28_17 = LA(1);

    	 
    	    index28_17 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_17 >= HEX_CHAR) && (LA28_17 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_17 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_17 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_17 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_17 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA28_17 == DOT) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA28_17 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_17 == SLASH || ((LA28_17 >= AND) && (LA28_17 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA28_17 >= STAR) && (LA28_17 <= RPAREN)) || ((LA28_17 >= USCORE) && (LA28_17 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index28_17);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA28_257;

    	    ANTLR3_MARKER index28_257;


    		LA28_257 = LA(1);

    	 
    	    index28_257 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_257);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA28_245;

    	    ANTLR3_MARKER index28_245;


    		LA28_245 = LA(1);

    	 
    	    index28_245 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_245);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA28_15;

    	    ANTLR3_MARKER index28_15;


    		LA28_15 = LA(1);

    	 
    	    index28_15 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_15 == DIGIT) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA28_15 == DOT) )
    	    {
    	        s = 16;
    	    }

    	    else if ( (((LA28_15 >= HEX_CHAR) && (LA28_15 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_15 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_15 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_15 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_15 >= STAR) && (LA28_15 <= RPAREN)) || ((LA28_15 >= USCORE) && (LA28_15 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_15 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_15 == SLASH || ((LA28_15 >= AND) && (LA28_15 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_15);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA28_105;

    	    ANTLR3_MARKER index28_105;


    		LA28_105 = LA(1);

    	 
    	    index28_105 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_105 == DIGIT) )
    	    {
    	        s = 154;
    	    }

    	    else if ( (LA28_105 == DOT) )
    	    {
    	        s = 106;
    	    }

    	    else if ( (((LA28_105 >= HEX_CHAR) && (LA28_105 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_105 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_105 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_105 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_105 >= STAR) && (LA28_105 <= RPAREN)) || ((LA28_105 >= USCORE) && (LA28_105 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_105 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_105 == SLASH || ((LA28_105 >= AND) && (LA28_105 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_105);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA28_44;

    	    ANTLR3_MARKER index28_44;


    		LA28_44 = LA(1);

    	 
    	    index28_44 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_44 == EOF || ((LA28_44 >= CRLF) && (LA28_44 <= SLASH)) || ((LA28_44 >= DOT) && (LA28_44 <= DASH)) || ((LA28_44 >= STAR) && (LA28_44 <= RPAREN)) || LA28_44 == PERCENT || LA28_44 == RAQUOT || ((LA28_44 >= USCORE) && (LA28_44 <= SQUOTE))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA28_44 >= HEX_CHAR) && (LA28_44 <= COMMON_CHAR))) )
    	    {
    	        s = 102;
    	    }

    	    else if ( (LA28_44 == DIGIT) )
    	    {
    	        s = 103;
    	    }

    	    else if ( (LA28_44 == LSBRAQUET) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 69;
    	    }

    	 
    		SEEK(index28_44);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA28_190;

    	    ANTLR3_MARKER index28_190;


    		LA28_190 = LA(1);

    	 
    	    index28_190 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_190 == DIGIT) )
    	    {
    	        s = 214;
    	    }

    	    else if ( (LA28_190 == DOT) )
    	    {
    	        s = 191;
    	    }

    	    else if ( (((LA28_190 >= HEX_CHAR) && (LA28_190 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_190 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_190 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_190 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_190 >= STAR) && (LA28_190 <= RPAREN)) || ((LA28_190 >= USCORE) && (LA28_190 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_190 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_190 == SLASH || ((LA28_190 >= AND) && (LA28_190 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_190);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA28_75;

    	    ANTLR3_MARKER index28_75;


    		LA28_75 = LA(1);

    	 
    	    index28_75 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_75 == EOF || ((LA28_75 >= CRLF) && (LA28_75 <= SLASH)) || ((LA28_75 >= DOT) && (LA28_75 <= DASH)) || ((LA28_75 >= STAR) && (LA28_75 <= RPAREN)) || LA28_75 == PERCENT || LA28_75 == RAQUOT || ((LA28_75 >= USCORE) && (LA28_75 <= SQUOTE))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA28_75 >= HEX_CHAR) && (LA28_75 <= COMMON_CHAR))) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA28_75 == DIGIT) )
    	    {
    	        s = 124;
    	    }

    	    else if ( (LA28_75 == LSBRAQUET) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 69;
    	    }

    	 
    		SEEK(index28_75);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 8:
        
    	{
    	    ANTLR3_UINT32 LA28_142;

    	    ANTLR3_MARKER index28_142;


    		LA28_142 = LA(1);

    	 
    	    index28_142 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_142 == EOF || ((LA28_142 >= CRLF) && (LA28_142 <= SLASH)) || ((LA28_142 >= DOT) && (LA28_142 <= DASH)) || ((LA28_142 >= STAR) && (LA28_142 <= RPAREN)) || LA28_142 == PERCENT || LA28_142 == RAQUOT || ((LA28_142 >= USCORE) && (LA28_142 <= SQUOTE))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA28_142 >= HEX_CHAR) && (LA28_142 <= COMMON_CHAR))) )
    	    {
    	        s = 183;
    	    }

    	    else if ( (LA28_142 == DIGIT) )
    	    {
    	        s = 184;
    	    }

    	    else if ( (LA28_142 == LSBRAQUET) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 69;
    	    }

    	 
    		SEEK(index28_142);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 9:
        
    	{
    	    ANTLR3_UINT32 LA28_18;

    	    ANTLR3_MARKER index28_18;


    		LA28_18 = LA(1);

    	 
    	    index28_18 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_18 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_18 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_18 >= HEX_CHAR) && (LA28_18 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_18 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_18 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_18 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_18 == SLASH || ((LA28_18 >= AND) && (LA28_18 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA28_18 == DOT || ((LA28_18 >= STAR) && (LA28_18 <= RPAREN)) || ((LA28_18 >= USCORE) && (LA28_18 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index28_18);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 10:
        
    	{
    	    ANTLR3_UINT32 LA28_11;

    	    ANTLR3_MARKER index28_11;


    		LA28_11 = LA(1);

    	 
    	    index28_11 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_11 >= HEX_CHAR) && (LA28_11 <= COMMON_CHAR))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA28_11 == DIGIT) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (LA28_11 == DOT || LA28_11 == DASH || ((LA28_11 >= STAR) && (LA28_11 <= RPAREN)) || ((LA28_11 >= USCORE) && (LA28_11 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 23;
    	    }

    	    else if ( (LA28_11 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA28_11 == AND) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA28_11 == EQUAL) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA28_11 == PLUS) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA28_11 == DOLLARD) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA28_11 == COMMA) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA28_11 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index28_11);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 11:
        
    	{
    	    ANTLR3_UINT32 LA28_35;

    	    ANTLR3_MARKER index28_35;


    		LA28_35 = LA(1);

    	 
    	    index28_35 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_35 == EOF || ((LA28_35 >= CRLF) && (LA28_35 <= SLASH)) || ((LA28_35 >= DOT) && (LA28_35 <= DASH)) || ((LA28_35 >= STAR) && (LA28_35 <= RPAREN)) || LA28_35 == PERCENT || LA28_35 == RAQUOT || ((LA28_35 >= USCORE) && (LA28_35 <= SQUOTE))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA28_35 >= HEX_CHAR) && (LA28_35 <= COMMON_CHAR))) )
    	    {
    	        s = 67;
    	    }

    	    else if ( (LA28_35 == DIGIT) )
    	    {
    	        s = 68;
    	    }

    	    else if ( (LA28_35 == LSBRAQUET) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 69;
    	    }

    	 
    		SEEK(index28_35);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 12:
        
    	{
    	    ANTLR3_UINT32 LA28_86;

    	    ANTLR3_MARKER index28_86;


    		LA28_86 = LA(1);

    	 
    	    index28_86 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_86 == EOF || ((LA28_86 >= CRLF) && (LA28_86 <= SLASH)) || ((LA28_86 >= DOT) && (LA28_86 <= DASH)) || ((LA28_86 >= STAR) && (LA28_86 <= RPAREN)) || LA28_86 == PERCENT || LA28_86 == RAQUOT || ((LA28_86 >= USCORE) && (LA28_86 <= SQUOTE))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA28_86 >= HEX_CHAR) && (LA28_86 <= COMMON_CHAR))) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA28_86 == DIGIT) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA28_86 == LSBRAQUET) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 69;
    	    }

    	 
    		SEEK(index28_86);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 13:
        
    	{
    	    ANTLR3_UINT32 LA28_231;

    	    ANTLR3_MARKER index28_231;


    		LA28_231 = LA(1);

    	 
    	    index28_231 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_231 == DIGIT) )
    	    {
    	        s = 243;
    	    }

    	    else if ( (LA28_231 == DOT) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (((LA28_231 >= HEX_CHAR) && (LA28_231 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_231 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_231 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA28_231 == SLASH) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA28_231 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA28_231 == EOF || ((LA28_231 >= CRLF) && (LA28_231 <= SP)) || LA28_231 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA28_231 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_231 >= STAR) && (LA28_231 <= RPAREN)) || ((LA28_231 >= USCORE) && (LA28_231 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_231 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (((LA28_231 >= AND) && (LA28_231 <= SEMI))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_231);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 14:
        
    	{
    	    ANTLR3_UINT32 LA28_22;

    	    ANTLR3_MARKER index28_22;


    		LA28_22 = LA(1);

    	 
    	    index28_22 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_22 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_22 >= HEX_CHAR) && (LA28_22 <= COMMON_CHAR))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA28_22 == DIGIT) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (LA28_22 == DOT || LA28_22 == DASH || ((LA28_22 >= STAR) && (LA28_22 <= RPAREN)) || ((LA28_22 >= USCORE) && (LA28_22 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 23;
    	    }

    	    else if ( (LA28_22 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA28_22 == AND) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA28_22 == EQUAL) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA28_22 == PLUS) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA28_22 == DOLLARD) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA28_22 == COMMA) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA28_22 == EOF || ((LA28_22 >= CRLF) && (LA28_22 <= SLASH)) || LA28_22 == QMARK || LA28_22 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_22);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 15:
        
    	{
    	    ANTLR3_UINT32 LA28_16;

    	    ANTLR3_MARKER index28_16;


    		LA28_16 = LA(1);

    	 
    	    index28_16 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_16 >= HEX_CHAR) && (LA28_16 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA28_16 == DIGIT) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA28_16 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_16 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA28_16 == DOT || LA28_16 == DASH || ((LA28_16 >= STAR) && (LA28_16 <= RPAREN)) || ((LA28_16 >= USCORE) && (LA28_16 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_16 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_16 == SLASH || ((LA28_16 >= AND) && (LA28_16 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_16);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 16:
        
    	{
    	    ANTLR3_UINT32 LA28_106;

    	    ANTLR3_MARKER index28_106;


    		LA28_106 = LA(1);

    	 
    	    index28_106 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_106 >= HEX_CHAR) && (LA28_106 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA28_106 == DIGIT) )
    	    {
    	        s = 155;
    	    }

    	    else if ( (LA28_106 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_106 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA28_106 == DOT || LA28_106 == DASH || ((LA28_106 >= STAR) && (LA28_106 <= RPAREN)) || ((LA28_106 >= USCORE) && (LA28_106 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_106 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_106 == SLASH || ((LA28_106 >= AND) && (LA28_106 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_106);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 17:
        
    	{
    	    ANTLR3_UINT32 LA28_7;

    	    ANTLR3_MARKER index28_7;


    		LA28_7 = LA(1);

    	 
    	    index28_7 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_7 >= HEX_CHAR) && (LA28_7 <= COMMON_CHAR))) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA28_7 == DIGIT) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA28_7 == DASH) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA28_7 == DOT) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA28_7 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA28_7 == SLASH) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA28_7 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA28_7 == EOF || ((LA28_7 >= CRLF) && (LA28_7 <= SP)) || LA28_7 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA28_7 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_7 >= STAR) && (LA28_7 <= RPAREN)) || ((LA28_7 >= USCORE) && (LA28_7 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_7 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (((LA28_7 >= AND) && (LA28_7 <= SEMI))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_7);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 18:
        
    	{
    	    ANTLR3_UINT32 LA28_191;

    	    ANTLR3_MARKER index28_191;


    		LA28_191 = LA(1);

    	 
    	    index28_191 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_191 >= HEX_CHAR) && (LA28_191 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA28_191 == DIGIT) )
    	    {
    	        s = 215;
    	    }

    	    else if ( (LA28_191 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_191 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA28_191 == DOT || LA28_191 == DASH || ((LA28_191 >= STAR) && (LA28_191 <= RPAREN)) || ((LA28_191 >= USCORE) && (LA28_191 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_191 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_191 == SLASH || ((LA28_191 >= AND) && (LA28_191 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_191);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 19:
        
    	{
    	    ANTLR3_UINT32 LA28_183;

    	    ANTLR3_MARKER index28_183;


    		LA28_183 = LA(1);

    	 
    	    index28_183 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_183);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 20:
        
    	{
    	    ANTLR3_UINT32 LA28_123;

    	    ANTLR3_MARKER index28_123;


    		LA28_123 = LA(1);

    	 
    	    index28_123 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_123);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 21:
        
    	{
    	    ANTLR3_UINT32 LA28_135;

    	    ANTLR3_MARKER index28_135;


    		LA28_135 = LA(1);

    	 
    	    index28_135 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_135);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 22:
        
    	{
    	    ANTLR3_UINT32 LA28_67;

    	    ANTLR3_MARKER index28_67;


    		LA28_67 = LA(1);

    	 
    	    index28_67 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_67);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 23:
        
    	{
    	    ANTLR3_UINT32 LA28_2;

    	    ANTLR3_MARKER index28_2;


    		LA28_2 = LA(1);

    	 
    	    index28_2 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_2 == DIGIT) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA28_2 == DOT) )
    	    {
    	        s = 16;
    	    }

    	    else if ( (((LA28_2 >= HEX_CHAR) && (LA28_2 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_2 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_2 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_2 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_2 >= STAR) && (LA28_2 <= RPAREN)) || ((LA28_2 >= USCORE) && (LA28_2 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_2 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_2 == SLASH || ((LA28_2 >= AND) && (LA28_2 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_2);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 24:
        
    	{
    	    ANTLR3_UINT32 LA28_54;

    	    ANTLR3_MARKER index28_54;


    		LA28_54 = LA(1);

    	 
    	    index28_54 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_54 == DIGIT) )
    	    {
    	        s = 105;
    	    }

    	    else if ( (LA28_54 == DOT) )
    	    {
    	        s = 106;
    	    }

    	    else if ( (((LA28_54 >= HEX_CHAR) && (LA28_54 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_54 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_54 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_54 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_54 >= STAR) && (LA28_54 <= RPAREN)) || ((LA28_54 >= USCORE) && (LA28_54 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_54 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_54 == SLASH || ((LA28_54 >= AND) && (LA28_54 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_54);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 25:
        
    	{
    	    ANTLR3_UINT32 LA28_56;

    	    ANTLR3_MARKER index28_56;


    		LA28_56 = LA(1);

    	 
    	    index28_56 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_56 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_56 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_56 >= HEX_CHAR) && (LA28_56 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA28_56 == DIGIT) )
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA28_56 == DOT || LA28_56 == DASH || ((LA28_56 >= STAR) && (LA28_56 <= RPAREN)) || ((LA28_56 >= USCORE) && (LA28_56 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_56 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_56 == SLASH || ((LA28_56 >= AND) && (LA28_56 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_56);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 26:
        
    	{
    	    ANTLR3_UINT32 LA28_155;

    	    ANTLR3_MARKER index28_155;


    		LA28_155 = LA(1);

    	 
    	    index28_155 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_155 == DIGIT) )
    	    {
    	        s = 190;
    	    }

    	    else if ( (LA28_155 == DOT) )
    	    {
    	        s = 191;
    	    }

    	    else if ( (((LA28_155 >= HEX_CHAR) && (LA28_155 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_155 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_155 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_155 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_155 >= STAR) && (LA28_155 <= RPAREN)) || ((LA28_155 >= USCORE) && (LA28_155 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_155 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_155 == SLASH || ((LA28_155 >= AND) && (LA28_155 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_155);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 27:
        
    	{
    	    ANTLR3_UINT32 LA28_9;

    	    ANTLR3_MARKER index28_9;


    		LA28_9 = LA(1);

    	 
    	    index28_9 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_9 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_9 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_9 >= HEX_CHAR) && (LA28_9 <= COMMON_CHAR))) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA28_9 == DIGIT) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA28_9 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_9 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_9 == SLASH || ((LA28_9 >= AND) && (LA28_9 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA28_9 == DOT || ((LA28_9 >= STAR) && (LA28_9 <= RPAREN)) || ((LA28_9 >= USCORE) && (LA28_9 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index28_9);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 28:
        
    	{
    	    ANTLR3_UINT32 LA28_53;

    	    ANTLR3_MARKER index28_53;


    		LA28_53 = LA(1);

    	 
    	    index28_53 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_53 == DOT) )
    	    {
    	        s = 16;
    	    }

    	    else if ( (((LA28_53 >= HEX_CHAR) && (LA28_53 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_53 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_53 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_53 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_53 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_53 >= STAR) && (LA28_53 <= RPAREN)) || ((LA28_53 >= USCORE) && (LA28_53 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_53 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_53 == SLASH || ((LA28_53 >= AND) && (LA28_53 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_53);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 29:
        
    	{
    	    ANTLR3_UINT32 LA28_154;

    	    ANTLR3_MARKER index28_154;


    		LA28_154 = LA(1);

    	 
    	    index28_154 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_154 == DOT) )
    	    {
    	        s = 106;
    	    }

    	    else if ( (((LA28_154 >= HEX_CHAR) && (LA28_154 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_154 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_154 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_154 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_154 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_154 >= STAR) && (LA28_154 <= RPAREN)) || ((LA28_154 >= USCORE) && (LA28_154 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_154 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_154 == SLASH || ((LA28_154 >= AND) && (LA28_154 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_154);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 30:
        
    	{
    	    ANTLR3_UINT32 LA28_214;

    	    ANTLR3_MARKER index28_214;


    		LA28_214 = LA(1);

    	 
    	    index28_214 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_214 == DOT) )
    	    {
    	        s = 191;
    	    }

    	    else if ( (((LA28_214 >= HEX_CHAR) && (LA28_214 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_214 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_214 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_214 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_214 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_214 >= STAR) && (LA28_214 <= RPAREN)) || ((LA28_214 >= USCORE) && (LA28_214 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_214 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_214 == SLASH || ((LA28_214 >= AND) && (LA28_214 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_214);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 31:
        
    	{
    	    ANTLR3_UINT32 LA28_55;

    	    ANTLR3_MARKER index28_55;


    		LA28_55 = LA(1);

    	 
    	    index28_55 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_55 == DOT) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (((LA28_55 >= HEX_CHAR) && (LA28_55 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_55 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_55 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_55 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_55 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_55 >= STAR) && (LA28_55 <= RPAREN)) || ((LA28_55 >= USCORE) && (LA28_55 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_55 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_55 == SLASH || ((LA28_55 >= AND) && (LA28_55 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_55);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 32:
        
    	{
    	    ANTLR3_UINT32 LA28_8;

    	    ANTLR3_MARKER index28_8;


    		LA28_8 = LA(1);

    	 
    	    index28_8 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_8 == DOT) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (((LA28_8 >= HEX_CHAR) && (LA28_8 <= COMMON_CHAR))) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA28_8 == DIGIT) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA28_8 == DASH) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA28_8 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA28_8 == SLASH) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA28_8 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA28_8 == EOF || ((LA28_8 >= CRLF) && (LA28_8 <= SP)) || LA28_8 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA28_8 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_8 >= STAR) && (LA28_8 <= RPAREN)) || ((LA28_8 >= USCORE) && (LA28_8 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_8 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (((LA28_8 >= AND) && (LA28_8 <= SEMI))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_8);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 33:
        
    	{
    	    ANTLR3_UINT32 LA28_253;

    	    ANTLR3_MARKER index28_253;


    		LA28_253 = LA(1);

    	 
    	    index28_253 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_253);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 34:
        
    	{
    	    ANTLR3_UINT32 LA28_215;

    	    ANTLR3_MARKER index28_215;


    		LA28_215 = LA(1);

    	 
    	    index28_215 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_215 == DIGIT) )
    	    {
    	        s = 231;
    	    }

    	    else if ( (LA28_215 == DOT) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA28_215 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA28_215 == SLASH) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA28_215 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA28_215 == EOF || ((LA28_215 >= CRLF) && (LA28_215 <= SP)) || LA28_215 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA28_215 >= HEX_CHAR) && (LA28_215 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_215 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_215 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_215 >= STAR) && (LA28_215 <= RPAREN)) || ((LA28_215 >= USCORE) && (LA28_215 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_215 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (((LA28_215 >= AND) && (LA28_215 <= SEMI))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_215);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 35:
        
    	{
    	    ANTLR3_UINT32 LA28_20;

    	    ANTLR3_MARKER index28_20;


    		LA28_20 = LA(1);

    	 
    	    index28_20 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_20 == DOT) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (((LA28_20 >= HEX_CHAR) && (LA28_20 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_20 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_20 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_20 == COLON) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA28_20 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_20 >= STAR) && (LA28_20 <= RPAREN)) || ((LA28_20 >= USCORE) && (LA28_20 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_20 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_20 == SLASH || ((LA28_20 >= AND) && (LA28_20 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_20);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 36:
        
    	{
    	    ANTLR3_UINT32 LA28_243;

    	    ANTLR3_MARKER index28_243;


    		LA28_243 = LA(1);

    	 
    	    index28_243 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_243 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA28_243 == SLASH) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA28_243 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA28_243 == EOF || ((LA28_243 >= CRLF) && (LA28_243 <= SP)) || LA28_243 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA28_243 == DOT) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (((LA28_243 >= HEX_CHAR) && (LA28_243 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA28_243 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA28_243 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA28_243 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_243 >= STAR) && (LA28_243 <= RPAREN)) || ((LA28_243 >= USCORE) && (LA28_243 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_243 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (((LA28_243 >= AND) && (LA28_243 <= SEMI))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_243);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 37:
        
    	{
    	    ANTLR3_UINT32 LA28_102;

    	    ANTLR3_MARKER index28_102;


    		LA28_102 = LA(1);

    	 
    	    index28_102 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_102);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 38:
        
    	{
    	    ANTLR3_UINT32 LA28_0;

    	    ANTLR3_MARKER index28_0;


    		LA28_0 = LA(1);

    	 
    	    index28_0 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_0 >= HEX_CHAR) && (LA28_0 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA28_0 == DIGIT) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (LA28_0 == DOT || LA28_0 == DASH || ((LA28_0 >= STAR) && (LA28_0 <= RPAREN)) || ((LA28_0 >= USCORE) && (LA28_0 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_0 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_0 == SLASH || ((LA28_0 >= AND) && (LA28_0 <= QMARK))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA28_0 == LSBRAQUET) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_0);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 39:
        
    	{
    	    ANTLR3_UINT32 LA28_1;

    	    ANTLR3_MARKER index28_1;


    		LA28_1 = LA(1);

    	 
    	    index28_1 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA28_1 >= HEX_CHAR) && (LA28_1 <= COMMON_CHAR))) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA28_1 == DIGIT) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA28_1 == DASH) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA28_1 == DOT) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA28_1 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA28_1 == SLASH) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA28_1 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA28_1 == EOF || ((LA28_1 >= CRLF) && (LA28_1 <= SP)) || LA28_1 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA28_1 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_1 >= STAR) && (LA28_1 <= RPAREN)) || ((LA28_1 >= USCORE) && (LA28_1 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_1 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (((LA28_1 >= AND) && (LA28_1 <= SEMI))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index28_1);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 40:
        
    	{
    	    ANTLR3_UINT32 LA28_261;

    	    ANTLR3_MARKER index28_261;


    		LA28_261 = LA(1);

    	 
    	    index28_261 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_261);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 41:
        
    	{
    	    ANTLR3_UINT32 LA28_255;

    	    ANTLR3_MARKER index28_255;


    		LA28_255 = LA(1);

    	 
    	    index28_255 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred8_belle_sip_message(ctx)) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_255);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 42:
        
    	{
    	    ANTLR3_UINT32 LA28_10;

    	    ANTLR3_MARKER index28_10;


    		LA28_10 = LA(1);

    	 
    	    index28_10 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA28_10 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA28_10 == AT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA28_10 >= HEX_CHAR) && (LA28_10 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA28_10 == DIGIT) )
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA28_10 == DOT || LA28_10 == DASH || ((LA28_10 >= STAR) && (LA28_10 <= RPAREN)) || ((LA28_10 >= USCORE) && (LA28_10 <= SQUOTE))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA28_10 == PERCENT) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA28_10 == SLASH) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA28_10 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (((LA28_10 >= AND) && (LA28_10 <= SEMI))) && (synpred8_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA28_10 == EOF || ((LA28_10 >= CRLF) && (LA28_10 <= SP)) || LA28_10 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index28_10);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"377:3: ( ( authority_userinfo[NULL] )=> authority_userinfo[uri] )?";
    EXCEPTION->decisionNum  = 28;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 28
 */
static
ANTLR3_CYCLIC_DFA cdfa28
    =	{
	    28,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"377:3: ( ( authority_userinfo[NULL] )=> authority_userinfo[uri] )?",	
	    (CDFA_SPECIAL_FUNC) dfa28_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa28_eot,	    /* EOT table			    */
	    dfa28_eof,	    /* EOF table			    */
	    dfa28_min,	    /* Minimum tokens for each state    */
	    dfa28_max,	    /* Maximum tokens for each state    */
	    dfa28_accept,	/* Accept table			    */
	    dfa28_special,	/* Special transition states	    */
	    dfa28_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 28
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    413:14: ( equal gen_value )?
 */
static const ANTLR3_INT32 dfa33_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa33_eof[6] =
    {
	4, 4, -1, -1, -1, 4
    };
static const ANTLR3_INT32 dfa33_min[6] =
    {
	4, 4, 5, -1, -1, 5
    };
static const ANTLR3_INT32 dfa33_max[6] =
    {
	16, 16, 5, -1, -1, 16
    };
static const ANTLR3_INT32 dfa33_accept[6] =
    {
	-1, -1, -1, 1, 2, -1
    };
static const ANTLR3_INT32 dfa33_special[6] =
    {	
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa33_T_empty	    NULL

static const ANTLR3_INT32 dfa33_T0[] =
    {
	2, 1, -1, -1, -1, -1, -1, -1, 3, -1, -1, 4, 4
    };static const ANTLR3_INT32 dfa33_T1[] =
    {
	5
    };static const ANTLR3_INT32 dfa33_T2[] =
    {
	5, -1, -1, -1, -1, -1, -1, 3, -1, -1, 4, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa33_transitions[] =
{
    dfa33_T0, dfa33_T0, dfa33_T1, dfa33_T_empty, dfa33_T_empty, dfa33_T2	
};


/* Declare tracking structure for Cyclic DFA 33
 */
static
ANTLR3_CYCLIC_DFA cdfa33
    =	{
	    33,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"413:14: ( equal gen_value )?",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa33_eot,	    /* EOT table			    */
	    dfa33_eof,	    /* EOF table			    */
	    dfa33_min,	    /* Minimum tokens for each state    */
	    dfa33_max,	    /* Maximum tokens for each state    */
	    dfa33_accept,	/* Accept table			    */
	    dfa33_special,	/* Special transition states	    */
	    dfa33_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 33
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    633:19: ( ( ( lws )? STAR ) | ( contact_param ( COMMA contact_param )* ) )
 */
static const ANTLR3_INT32 dfa46_eot[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa46_eof[8] =
    {
	-1, -1, -1, 7, -1, 7, -1, -1
    };
static const ANTLR3_INT32 dfa46_min[8] =
    {
	4, 4, 5, 4, -1, 4, 5, -1
    };
static const ANTLR3_INT32 dfa46_max[8] =
    {
	38, 38, 5, 38, -1, 38, 38, -1
    };
static const ANTLR3_INT32 dfa46_accept[8] =
    {
	-1, -1, -1, -1, 2, -1, -1, 1
    };
static const ANTLR3_INT32 dfa46_special[8] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa46_T_empty	    NULL

static const ANTLR3_INT32 dfa46_T0[] =
    {
	4, 4, -1, 4, 4, 4, -1, -1, -1, 4, -1, -1, -1, -1, 4, -1, -1, 4, 4, 4, -1, 
	-1, -1, 4, 4, 4, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa46_T1[] =
    {
	6
    };static const ANTLR3_INT32 dfa46_T2[] =
    {
	6, -1, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 4, 4, -1, 5, 4, 4, -1, 
	-1, -1, 4, 4, 4, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa46_T3[] =
    {
	2, 1, -1, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 4, 4, -1, 5, 4, 4, -1, 
	-1, -1, 4, 4, 4, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa46_T4[] =
    {
	2, 1, -1, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 4, 4, -1, 3, 4, 4, -1, 
	-1, -1, 4, 4, 4, 4, 4, -1, -1, -1, 4, 4, 4, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa46_transitions[] =
{
    dfa46_T4, dfa46_T3, dfa46_T1, dfa46_T0, dfa46_T_empty, dfa46_T0, dfa46_T2, 
    dfa46_T_empty	
};


/* Declare tracking structure for Cyclic DFA 46
 */
static
ANTLR3_CYCLIC_DFA cdfa46
    =	{
	    46,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"633:19: ( ( ( lws )? STAR ) | ( contact_param ( COMMA contact_param )* ) )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa46_eot,	    /* EOT table			    */
	    dfa46_eof,	    /* EOF table			    */
	    dfa46_min,	    /* Minimum tokens for each state    */
	    dfa46_max,	    /* Maximum tokens for each state    */
	    dfa46_accept,	/* Accept table			    */
	    dfa46_special,	/* Special transition states	    */
	    dfa46_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 46
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    655:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] )
 */
static const ANTLR3_INT32 dfa47_eot[18] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa47_eof[18] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa47_min[18] =
    {
	4, 4, 5, 4, 4, 4, 4, 4, 4, -1, 4, 4, 4, 4, 4, 4, 5, -1
    };
static const ANTLR3_INT32 dfa47_max[18] =
    {
	38, 38, 5, 38, 38, 38, 38, 38, 38, -1, 38, 38, 38, 38, 38, 38, 38, -1
    };
static const ANTLR3_INT32 dfa47_accept[18] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 2
    };
static const ANTLR3_INT32 dfa47_special[18] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa47_T_empty	    NULL

static const ANTLR3_INT32 dfa47_T0[] =
    {
	9, 9, -1, 11, 12, 17, -1, -1, -1, 14, -1, -1, -1, -1, 12, -1, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa47_T1[] =
    {
	9, 9, -1, 4, 5, 17, -1, -1, -1, 7, -1, -1, -1, -1, 5, -1, -1, 5, 5, 5, 
	-1, -1, -1, 6, 8, 3, 3, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa47_T2[] =
    {
	2, 1, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa47_T3[] =
    {
	16
    };static const ANTLR3_INT32 dfa47_T4[] =
    {
	16, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa47_T5[] =
    {
	2, 1, -1, 4, 5, -1, -1, -1, -1, 7, -1, -1, -1, -1, 5, 9, -1, 5, 5, 5, -1, 
	-1, -1, 6, 8, 3, 3, 9, -1, -1, -1, 5, 5, 5, 5
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa47_transitions[] =
{
    dfa47_T5, dfa47_T2, dfa47_T3, dfa47_T1, dfa47_T1, dfa47_T1, dfa47_T1, 
    dfa47_T1, dfa47_T1, dfa47_T_empty, dfa47_T0, dfa47_T0, dfa47_T0, dfa47_T0, 
    dfa47_T0, dfa47_T0, dfa47_T4, dfa47_T_empty	
};


/* Declare tracking structure for Cyclic DFA 47
 */
static
ANTLR3_CYCLIC_DFA cdfa47
    =	{
	    47,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"655:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa47_eot,	    /* EOT table			    */
	    dfa47_eof,	    /* EOF table			    */
	    dfa47_min,	    /* Minimum tokens for each state    */
	    dfa47_max,	    /* Maximum tokens for each state    */
	    dfa47_accept,	/* Accept table			    */
	    dfa47_special,	/* Special transition states	    */
	    dfa47_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 47
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    663:1: header_address_base[belle_sip_header_address_t* obj] returns [belle_sip_header_address_t* ret] : ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] );
 */
static const ANTLR3_INT32 dfa51_eot[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa51_eof[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa51_min[30] =
    {
	4, 4, 5, 4, 4, 4, 4, 4, 4, -1, -1, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa51_max[30] =
    {
	38, 38, 5, 38, 38, 38, 38, 38, 38, -1, -1, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38
    };
static const ANTLR3_INT32 dfa51_accept[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa51_special[30] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa51_T_empty	    NULL

static const ANTLR3_INT32 dfa51_T0[] =
    {
	9, 9, -1, 25, 28, 10, -1, -1, -1, 27, -1, -1, -1, -1, 26, -1, -1, 13, 13, 
	13, -1, -1, -1, 14, 16, 24, 24, 9, -1, -1, -1, 13, 13, 13, 13
    };static const ANTLR3_INT32 dfa51_T1[] =
    {
	9, 9, -1, 19, 22, 10, -1, -1, -1, 21, -1, -1, -1, -1, 20, -1, -1, 5, 5, 
	5, -1, -1, -1, 6, 8, 18, 18, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa51_T2[] =
    {
	9, 9, -1, 4, 5, 10, -1, -1, -1, 7, -1, -1, -1, -1, 5, -1, -1, 5, 5, 5, 
	-1, -1, -1, 6, 8, 23, 23, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa51_T3[] =
    {
	2, 1, 10, 12, 13, -1, -1, -1, -1, 15, -1, -1, -1, -1, 13, 9, -1, 13, 13, 
	13, -1, -1, -1, 14, 16, 11, 11, 9, -1, -1, -1, 13, 13, 13, 13
    };static const ANTLR3_INT32 dfa51_T4[] =
    {
	9, 9, -1, 12, 13, 10, -1, -1, -1, 15, -1, -1, -1, -1, 13, -1, -1, 13, 13, 
	13, -1, -1, -1, 14, 16, 29, 29, 9, -1, -1, -1, 13, 13, 13, 13
    };static const ANTLR3_INT32 dfa51_T5[] =
    {
	17, 10, 12, 13, -1, -1, -1, -1, 15, -1, -1, -1, -1, 13, 9, -1, 13, 13, 
	13, -1, -1, -1, 14, 16, 11, 11, 9, -1, -1, -1, 13, 13, 13, 13
    };static const ANTLR3_INT32 dfa51_T6[] =
    {
	2, 1, 10, 4, 5, -1, -1, -1, -1, 7, -1, -1, -1, -1, 5, 9, -1, 5, 5, 5, -1, 
	-1, -1, 6, 8, 3, 3, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa51_T7[] =
    {
	17
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa51_transitions[] =
{
    dfa51_T6, dfa51_T3, dfa51_T7, dfa51_T1, dfa51_T2, dfa51_T2, dfa51_T2, 
    dfa51_T2, dfa51_T2, dfa51_T_empty, dfa51_T_empty, dfa51_T0, dfa51_T4, 
    dfa51_T4, dfa51_T4, dfa51_T4, dfa51_T4, dfa51_T5, dfa51_T1, dfa51_T1, 
    dfa51_T1, dfa51_T1, dfa51_T1, dfa51_T2, dfa51_T0, dfa51_T0, dfa51_T0, 
    dfa51_T0, dfa51_T0, dfa51_T4	
};


/* Declare tracking structure for Cyclic DFA 51
 */
static
ANTLR3_CYCLIC_DFA cdfa51
    =	{
	    51,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"663:1: header_address_base[belle_sip_header_address_t* obj] returns [belle_sip_header_address_t* ret] : ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa51_eot,	    /* EOT table			    */
	    dfa51_eof,	    /* EOF table			    */
	    dfa51_min,	    /* Minimum tokens for each state    */
	    dfa51_max,	    /* Maximum tokens for each state    */
	    dfa51_accept,	/* Accept table			    */
	    dfa51_special,	/* Special transition states	    */
	    dfa51_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 51
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    673:10: ( ( lws )? display_name[object] )?
 */
static const ANTLR3_INT32 dfa53_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa53_eof[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa53_min[6] =
    {
	4, 4, 5, -1, -1, 5
    };
static const ANTLR3_INT32 dfa53_max[6] =
    {
	38, 38, 5, -1, -1, 38
    };
static const ANTLR3_INT32 dfa53_accept[6] =
    {
	-1, -1, -1, 1, 2, -1
    };
static const ANTLR3_INT32 dfa53_special[6] =
    {	
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa53_T_empty	    NULL

static const ANTLR3_INT32 dfa53_T0[] =
    {
	5
    };static const ANTLR3_INT32 dfa53_T1[] =
    {
	5, -1, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, -1, 3, 3, 3, -1, 
	-1, -1, 3, 3, 3, 3, 4, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa53_T2[] =
    {
	2, 1, -1, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, -1, 3, 3, 3, -1, 
	-1, -1, 3, 3, 3, 3, 4, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa53_transitions[] =
{
    dfa53_T2, dfa53_T2, dfa53_T0, dfa53_T_empty, dfa53_T_empty, dfa53_T1	
};


/* Declare tracking structure for Cyclic DFA 53
 */
static
ANTLR3_CYCLIC_DFA cdfa53
    =	{
	    53,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"673:10: ( ( lws )? display_name[object] )?",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa53_eot,	    /* EOT table			    */
	    dfa53_eof,	    /* EOF table			    */
	    dfa53_min,	    /* Minimum tokens for each state    */
	    dfa53_max,	    /* Maximum tokens for each state    */
	    dfa53_accept,	/* Accept table			    */
	    dfa53_special,	/* Special transition states	    */
	    dfa53_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 53
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    676:10: ( ( lws )? display_name[object] )?
 */
static const ANTLR3_INT32 dfa55_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa55_eof[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa55_min[6] =
    {
	4, 4, 5, -1, -1, 5
    };
static const ANTLR3_INT32 dfa55_max[6] =
    {
	38, 38, 5, -1, -1, 38
    };
static const ANTLR3_INT32 dfa55_accept[6] =
    {
	-1, -1, -1, 1, 2, -1
    };
static const ANTLR3_INT32 dfa55_special[6] =
    {	
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa55_T_empty	    NULL

static const ANTLR3_INT32 dfa55_T0[] =
    {
	5
    };static const ANTLR3_INT32 dfa55_T1[] =
    {
	2, 1, -1, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, -1, 3, 3, 3, -1, 
	-1, -1, 3, 3, 3, 3, 4, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa55_T2[] =
    {
	5, -1, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, -1, 3, 3, 3, -1, 
	-1, -1, 3, 3, 3, 3, 4, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa55_transitions[] =
{
    dfa55_T1, dfa55_T1, dfa55_T0, dfa55_T_empty, dfa55_T_empty, dfa55_T2	
};


/* Declare tracking structure for Cyclic DFA 55
 */
static
ANTLR3_CYCLIC_DFA cdfa55
    =	{
	    55,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"676:10: ( ( lws )? display_name[object] )?",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa55_eot,	    /* EOT table			    */
	    dfa55_eof,	    /* EOF table			    */
	    dfa55_min,	    /* Minimum tokens for each state    */
	    dfa55_max,	    /* Maximum tokens for each state    */
	    dfa55_accept,	/* Accept table			    */
	    dfa55_special,	/* Special transition states	    */
	    dfa55_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 55
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    692:11: ( paramless_uri | generic_uri_for_from_to_contact_addr_spec )
 */
static const ANTLR3_INT32 dfa64_eot[103] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa64_eof[103] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, 14, -1, 14, -1, 14, 14, 14, 
	14, 14, 14, 14, 14, 14, 14, -1, 14, -1, 14, 14, -1, 14, 14, 14, -1, 14, 
	14, 14, 14, 14, -1, 14, 14, 14, -1, 14, -1, 14, 14, 14, 14, 14, 14, -1, 
	14, 14, 14, -1, 14, 14, 14, 14, 14, -1, 14, 14, 14, -1, 14, 14, 14, 14, 
	14, -1, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, -1, 14, 14, 14, 14, 14, 
	14, -1, -1, 14, -1, 14, 14, 14, 14, 14, 14, -1, -1
    };
static const ANTLR3_INT32 dfa64_min[103] =
    {
	7, 7, -1, 6, 7, 7, 7, 7, 7, 0, 4, 4, 7, 4, -1, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 7, 4, 4, 4, 4, 7, 4, 4, 4, 0, 4, 4, 4, 4, 4, 7, 4, 4, 4, 0, 4, 7, 
	4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 
	4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 
	4, 4, 4, 4, 4, 4, 0, 0
    };
static const ANTLR3_INT32 dfa64_max[103] =
    {
	38, 38, -1, 38, 38, 38, 38, 38, 38, 0, 38, 38, 29, 38, -1, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 29, 38, 38, 38, 0, 38, 
	38, 38, 38, 38, 29, 38, 38, 38, 0, 38, 29, 38, 38, 38, 38, 38, 38, 0, 38, 
	38, 38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 38, 0, 38, 38, 38, 38, 38, 
	0, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 0, 38, 38, 38, 38, 38, 38, 0, 
	0, 38, 0, 38, 38, 38, 38, 38, 38, 0, 0
    };
static const ANTLR3_INT32 dfa64_accept[103] =
    {
	-1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa64_special[103] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, 
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, 6, 
	0, -1, 10, -1, -1, -1, -1, -1, -1, 11, 1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa64_T_empty	    NULL

static const ANTLR3_INT32 dfa64_T0[] =
    {
	14, 14, 14, 93, 87, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T1[] =
    {
	14, 14, 2, 48, 49, 2, 2, 2, 2, 51, 2, 2, 2, 2, 49, -1, -1, 49, 49, 49, 
	-1, -1, -1, 50, 14, 47, 47, -1, -1, -1, -1, 49, 49, 49, 49
    };static const ANTLR3_INT32 dfa64_T2[] =
    {
	14, 14, 14, 72, 71, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T3[] =
    {
	14, 14, 26, 82, 83, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T4[] =
    {
	14, 14, 14, 58, 60, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T5[] =
    {
	14, 14, 26, 55, 56, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T6[] =
    {
	14, 14, 14, 74, 14, 14, 14, 14, 14, 14, 14, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 73, 73, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T7[] =
    {
	14, 14, 14, 86, 87, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T8[] =
    {
	14, 14, 14, 100, 99, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T9[] =
    {
	5, 8, 3, -1, -1, -1, 7, -1, -1, -1, -1, 6, -1, -1, 2, 2, 2, -1, -1, -1, 
	2, 2, 4, 4, -1, -1, -1, -1, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa64_T10[] =
    {
	14, 14, -1, 97, 14, -1, -1, -1, -1, 14, -1, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, 14, 96, 14, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T11[] =
    {
	14, 14, 14, 38, 39, 14, 23, 36, 41, 42, 43, 2, 14, -1, 39, -1, -1, 39, 
	39, 39, -1, -1, -1, 40, -1, 37, 37, -1, -1, -1, -1, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa64_T12[] =
    {
	2, 2, -1, -1, -1, -1, 2, -1, -1, -1, -1, 2, -1, -1, 2, 2, 2, -1, -1, -1, 
	2, 2, 1, 1, -1, -1, -1, -1, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa64_T13[] =
    {
	14, 14, 14, 98, 99, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T14[] =
    {
	14, 14, 14, 95, 14, 14, 14, 14, 14, 14, 14, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 94, 94, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T15[] =
    {
	14, 14, 14, 102, 14, 14, 14, 14, 14, 14, 14, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 101, 101, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T16[] =
    {
	14, 14, 26, 33, 21, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T17[] =
    {
	14, 14, 2, 48, 49, 2, 2, 2, 63, 51, 2, 2, 27, 2, 49, -1, -1, 49, 49, 49, 
	-1, -1, -1, 50, 14, 47, 47, -1, -1, -1, -1, 49, 49, 49, 49
    };static const ANTLR3_INT32 dfa64_T18[] =
    {
	-1
    };static const ANTLR3_INT32 dfa64_T19[] =
    {
	14, 14, 14, 45, 14, 14, 14, 14, 14, 14, 14, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, 2, -1, 14, -1, 44, 44, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T20[] =
    {
	14, 14, -1, 65, 14, -1, -1, -1, 14, 14, -1, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, 14, 64, 14, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T21[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 30
    };static const ANTLR3_INT32 dfa64_T22[] =
    {
	46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 46
    };static const ANTLR3_INT32 dfa64_T23[] =
    {
	57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 57
    };static const ANTLR3_INT32 dfa64_T24[] =
    {
	14, 14, 26, 33, 83, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T25[] =
    {
	14, 14, 14, 72, 60, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T26[] =
    {
	14, 14, 26, 33, 56, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T27[] =
    {
	14, 14, 26, 29, 24, 22, 23, 26, 26, 26, 26, 2, 27, 2, 24, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 28, 28, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T28[] =
    {
	14, 14, 26, 54, 24, 22, 23, 26, 26, 26, 26, 2, 27, 2, 24, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 53, 53, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T29[] =
    {
	14, 14, 2, 76, 77, 2, 2, 2, 2, 79, 2, 2, 27, 2, 77, -1, -1, 77, 77, 77, 
	-1, -1, -1, 78, 14, 75, 75, -1, -1, -1, -1, 77, 77, 77, 77
    };static const ANTLR3_INT32 dfa64_T30[] =
    {
	14, 14, 14, 72, 87, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T31[] =
    {
	14, 14, 2, 76, 77, 2, 2, 2, 2, 79, 2, 2, 2, 2, 77, 14, -1, 77, 77, 77, 
	-1, -1, -1, 78, 14, 75, 75, -1, -1, -1, -1, 77, 77, 77, 77
    };static const ANTLR3_INT32 dfa64_T32[] =
    {
	14, 14, 14, 72, 14, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T33[] =
    {
	14, 14, 14, 72, 99, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T34[] =
    {
	14, 14, 26, 68, 24, 22, 23, 26, 26, 26, 26, 2, 27, 2, 24, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 67, 67, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T35[] =
    {
	14, 14, 26, 35, 24, 22, 23, 26, 26, 26, 26, 2, 27, 2, 24, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 34, 34, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T36[] =
    {
	2, 10, 11, 14, 14, 13, 15, 16, 17, 2, 2, 2, 11, -1, -1, 11, 11, 11, -1, 
	2, -1, 12, -1, 9, 9, -1, -1, -1, -1, 11, 11, 11, 11
    };static const ANTLR3_INT32 dfa64_T37[] =
    {
	14, 14, 26, 92, 24, 22, 23, 26, 26, 26, 26, 2, 27, 2, 24, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 91, 91, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T38[] =
    {
	14, 14, -1, 81, 14, -1, -1, -1, 14, 14, -1, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, 14, 80, 14, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T39[] =
    {
	14, 14, 26, 33, 32, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T40[] =
    {
	14, 14, -1, 89, 14, -1, -1, -1, -1, 14, -1, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, 14, 88, 14, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T41[] =
    {
	14, 14, 26, 33, 24, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T42[] =
    {
	52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 52
    };static const ANTLR3_INT32 dfa64_T43[] =
    {
	62, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 62
    };static const ANTLR3_INT32 dfa64_T44[] =
    {
	69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 69
    };static const ANTLR3_INT32 dfa64_T45[] =
    {
	14, 14, 26, 31, 21, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T46[] =
    {
	14, 14, 14, 85, 14, 14, 14, 14, 14, 14, 14, -1, 14, -1, 14, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 84, 84, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T47[] =
    {
	14, 14, 26, 90, 83, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T48[] =
    {
	14, 14, 14, 70, 60, 14, 14, 14, 14, 14, 14, -1, 14, -1, 61, -1, -1, 14, 
	14, 14, -1, -1, -1, 14, -1, 59, 59, -1, -1, -1, -1, 14, 14, 14, 14
    };static const ANTLR3_INT32 dfa64_T49[] =
    {
	14, 14, 26, 18, 21, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa64_T50[] =
    {
	14, 14, 26, 66, 56, 22, 23, 26, 26, 26, 26, 2, 27, 2, 20, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 19, 19, -1, -1, -1, -1, 24, 24, 24, 24
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa64_transitions[] =
{
    dfa64_T12, dfa64_T9, dfa64_T_empty, dfa64_T36, dfa64_T9, dfa64_T9, dfa64_T9, 
    dfa64_T9, dfa64_T9, dfa64_T18, dfa64_T49, dfa64_T27, dfa64_T21, dfa64_T27, 
    dfa64_T_empty, dfa64_T27, dfa64_T27, dfa64_T27, dfa64_T45, dfa64_T39, 
    dfa64_T41, dfa64_T35, dfa64_T11, dfa64_T19, dfa64_T27, dfa64_T22, dfa64_T27, 
    dfa64_T1, dfa64_T27, dfa64_T27, dfa64_T42, dfa64_T16, dfa64_T28, dfa64_T39, 
    dfa64_T18, dfa64_T5, dfa64_T11, dfa64_T11, dfa64_T11, dfa64_T11, dfa64_T23, 
    dfa64_T11, dfa64_T11, dfa64_T11, dfa64_T18, dfa64_T4, dfa64_T43, dfa64_T17, 
    dfa64_T17, dfa64_T17, dfa64_T20, dfa64_T17, dfa64_T27, dfa64_T18, dfa64_T39, 
    dfa64_T50, dfa64_T34, dfa64_T44, dfa64_T48, dfa64_T2, dfa64_T6, dfa64_T32, 
    dfa64_T27, dfa64_T31, dfa64_T38, dfa64_T38, dfa64_T26, dfa64_T18, dfa64_T3, 
    dfa64_T11, dfa64_T25, dfa64_T46, dfa64_T2, dfa64_T18, dfa64_T7, dfa64_T29, 
    dfa64_T29, dfa64_T29, dfa64_T40, dfa64_T29, dfa64_T17, dfa64_T17, dfa64_T47, 
    dfa64_T37, dfa64_T18, dfa64_T2, dfa64_T0, dfa64_T14, dfa64_T10, dfa64_T10, 
    dfa64_T24, dfa64_T18, dfa64_T18, dfa64_T30, dfa64_T18, dfa64_T13, dfa64_T29, 
    dfa64_T29, dfa64_T8, dfa64_T15, dfa64_T33, dfa64_T18, dfa64_T18	
};

static ANTLR3_INT32 dfa64_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA64_92;

    	    ANTLR3_MARKER index64_92;


    		LA64_92 = LA(1);

    	 
    	    index64_92 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_92);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA64_102;

    	    ANTLR3_MARKER index64_102;


    		LA64_102 = LA(1);

    	 
    	    index64_102 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_102);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA64_9;

    	    ANTLR3_MARKER index64_9;


    		LA64_9 = LA(1);

    	 
    	    index64_9 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_9);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA64_34;

    	    ANTLR3_MARKER index64_34;


    		LA64_34 = LA(1);

    	 
    	    index64_34 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_34);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA64_53;

    	    ANTLR3_MARKER index64_53;


    		LA64_53 = LA(1);

    	 
    	    index64_53 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_53);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA64_67;

    	    ANTLR3_MARKER index64_67;


    		LA64_67 = LA(1);

    	 
    	    index64_67 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_67);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA64_91;

    	    ANTLR3_MARKER index64_91;


    		LA64_91 = LA(1);

    	 
    	    index64_91 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_91);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA64_44;

    	    ANTLR3_MARKER index64_44;


    		LA64_44 = LA(1);

    	 
    	    index64_44 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_44);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 8:
        
    	{
    	    ANTLR3_UINT32 LA64_73;

    	    ANTLR3_MARKER index64_73;


    		LA64_73 = LA(1);

    	 
    	    index64_73 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_73);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 9:
        
    	{
    	    ANTLR3_UINT32 LA64_84;

    	    ANTLR3_MARKER index64_84;


    		LA64_84 = LA(1);

    	 
    	    index64_84 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_84);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 10:
        
    	{
    	    ANTLR3_UINT32 LA64_94;

    	    ANTLR3_MARKER index64_94;


    		LA64_94 = LA(1);

    	 
    	    index64_94 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_94);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 11:
        
    	{
    	    ANTLR3_UINT32 LA64_101;

    	    ANTLR3_MARKER index64_101;


    		LA64_101 = LA(1);

    	 
    	    index64_101 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 14;
    	    }

    	 
    		SEEK(index64_101);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"692:11: ( paramless_uri | generic_uri_for_from_to_contact_addr_spec )";
    EXCEPTION->decisionNum  = 64;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 64
 */
static
ANTLR3_CYCLIC_DFA cdfa64
    =	{
	    64,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"692:11: ( paramless_uri | generic_uri_for_from_to_contact_addr_spec )",	
	    (CDFA_SPECIAL_FUNC) dfa64_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa64_eot,	    /* EOT table			    */
	    dfa64_eof,	    /* EOF table			    */
	    dfa64_min,	    /* Minimum tokens for each state    */
	    dfa64_max,	    /* Maximum tokens for each state    */
	    dfa64_accept,	/* Accept table			    */
	    dfa64_special,	/* Special transition states	    */
	    dfa64_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 64
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 698:9: ( lws token )*
 */
static const ANTLR3_INT32 dfa66_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa66_eof[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa66_min[6] =
    {
	4, 4, 5, -1, -1, 5
    };
static const ANTLR3_INT32 dfa66_max[6] =
    {
	31, 38, 5, -1, -1, 38
    };
static const ANTLR3_INT32 dfa66_accept[6] =
    {
	-1, -1, -1, 2, 1, -1
    };
static const ANTLR3_INT32 dfa66_special[6] =
    {	
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa66_T_empty	    NULL

static const ANTLR3_INT32 dfa66_T0[] =
    {
	5
    };static const ANTLR3_INT32 dfa66_T1[] =
    {
	2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 3
    };static const ANTLR3_INT32 dfa66_T2[] =
    {
	2, 1, -1, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 4, -1, -1, 4, 4, 4, 
	-1, -1, -1, 4, 4, 4, 4, 3, -1, -1, -1, 4, 4, 4, 4
    };static const ANTLR3_INT32 dfa66_T3[] =
    {
	5, -1, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 4, -1, -1, 4, 4, 4, -1, 
	-1, -1, 4, 4, 4, 4, 3, -1, -1, -1, 4, 4, 4, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa66_transitions[] =
{
    dfa66_T1, dfa66_T2, dfa66_T0, dfa66_T_empty, dfa66_T_empty, dfa66_T3	
};


/* Declare tracking structure for Cyclic DFA 66
 */
static
ANTLR3_CYCLIC_DFA cdfa66
    =	{
	    66,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 698:9: ( lws token )*",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa66_eot,	    /* EOT table			    */
	    dfa66_eof,	    /* EOF table			    */
	    dfa66_min,	    /* Minimum tokens for each state    */
	    dfa66_max,	    /* Maximum tokens for each state    */
	    dfa66_accept,	/* Accept table			    */
	    dfa66_special,	/* Special transition states	    */
	    dfa66_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 66
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    898:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] )
 */
static const ANTLR3_INT32 dfa72_eot[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa72_eof[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa72_min[30] =
    {
	4, 4, 5, 4, 4, 4, 4, 4, 4, -1, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, -1, 4, 
	4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa72_max[30] =
    {
	38, 38, 5, 38, 38, 38, 38, 38, 38, -1, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, -1, 38, 38, 38, 38, 38, 38, 38, 38
    };
static const ANTLR3_INT32 dfa72_accept[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa72_special[30] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa72_T_empty	    NULL

static const ANTLR3_INT32 dfa72_T0[] =
    {
	9, 9, -1, 4, 5, 21, -1, -1, -1, 7, -1, -1, -1, -1, 5, -1, -1, 5, 5, 5, 
	-1, -1, -1, 6, 8, 23, 23, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa72_T1[] =
    {
	16, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa72_T2[] =
    {
	9, 9, -1, 25, 28, 21, -1, -1, -1, 27, -1, -1, -1, -1, 26, -1, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 24, 24, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa72_T3[] =
    {
	2, 1, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa72_T4[] =
    {
	9, 9, -1, 18, 22, 21, -1, -1, -1, 20, -1, -1, -1, -1, 19, -1, -1, 5, 5, 
	5, -1, -1, -1, 6, 8, 17, 17, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa72_T5[] =
    {
	9, 9, -1, 11, 12, 21, -1, -1, -1, 14, -1, -1, -1, -1, 12, -1, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 29, 29, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa72_T6[] =
    {
	2, 1, -1, 4, 5, -1, -1, -1, -1, 7, -1, -1, -1, -1, 5, 9, -1, 5, 5, 5, -1, 
	-1, -1, 6, 8, 3, 3, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa72_T7[] =
    {
	16
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa72_transitions[] =
{
    dfa72_T6, dfa72_T3, dfa72_T7, dfa72_T4, dfa72_T0, dfa72_T0, dfa72_T0, 
    dfa72_T0, dfa72_T0, dfa72_T_empty, dfa72_T2, dfa72_T5, dfa72_T5, dfa72_T5, 
    dfa72_T5, dfa72_T5, dfa72_T1, dfa72_T4, dfa72_T4, dfa72_T4, dfa72_T4, 
    dfa72_T_empty, dfa72_T4, dfa72_T0, dfa72_T2, dfa72_T2, dfa72_T2, dfa72_T2, 
    dfa72_T2, dfa72_T5	
};


/* Declare tracking structure for Cyclic DFA 72
 */
static
ANTLR3_CYCLIC_DFA cdfa72
    =	{
	    72,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"898:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa72_eot,	    /* EOT table			    */
	    dfa72_eof,	    /* EOF table			    */
	    dfa72_min,	    /* Minimum tokens for each state    */
	    dfa72_max,	    /* Maximum tokens for each state    */
	    dfa72_accept,	/* Accept table			    */
	    dfa72_special,	/* Special transition states	    */
	    dfa72_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 72
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    957:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );
 */
static const ANTLR3_INT32 dfa78_eot[62] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa78_eof[62] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa78_min[62] =
    {
	7, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 4, 5, 4, 5, 4, 5, 4, 0, 
	0, 0, 0, 0, 0, 5, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 4, 4, 0, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa78_max[62] =
    {
	38, 38, 38, 38, 38, 38, 38, 38, 5, 38, 38, 38, 38, 38, 38, 38, 12, 5, 38, 
	12, 38, 5, 40, 0, 0, 0, 0, 0, 0, 38, 40, 40, 0, 40, 40, 40, 40, 40, 40, 
	40, 40, -1, -1, 40, 40, 0, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40
    };
static const ANTLR3_INT32 dfa78_accept[62] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa78_special[62] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 3, 5, 6, 0, 1, 2, -1, -1, -1, 7, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa78_T_empty	    NULL

static const ANTLR3_INT32 dfa78_T0[] =
    {
	-1
    };static const ANTLR3_INT32 dfa78_T1[] =
    {
	47, 46, 40, 40, 40, 40, 40, 40, 40, 40, 40, 48, 40, 40, 40, 45, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T2[] =
    {
	2, 3, -1, -1, -1, -1, 5, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, 6, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa78_T3[] =
    {
	8, 7, -1, 2, 3, -1, -1, -1, -1, 5, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 
	-1, -1, -1, 4, 6, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa78_T4[] =
    {
	19
    };static const ANTLR3_INT32 dfa78_T5[] =
    {
	29
    };static const ANTLR3_INT32 dfa78_T6[] =
    {
	60, 59, 40, 53, 54, 40, 40, 40, 40, 56, 40, 48, 40, 40, 54, 45, 31, 54, 
	54, 54, 40, 40, 40, 55, 57, 52, 52, 40, 40, 40, 40, 54, 54, 54, 54, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T7[] =
    {
	47, 46, 40, 35, 36, 40, 40, 40, 40, 38, 40, 48, 40, 40, 36, 45, 31, 36, 
	36, 36, 40, 40, 40, 37, 39, 34, 34, 40, 40, 40, 40, 36, 36, 36, 36, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T8[] =
    {
	17, 16, -1, 10, 11, -1, -1, -1, 18, 13, -1, -1, -1, -1, 11, -1, -1, 11, 
	11, 11, -1, -1, -1, 12, 14, 9, 9, -1, -1, -1, -1, 11, 11, 11, 11
    };static const ANTLR3_INT32 dfa78_T9[] =
    {
	40, 49, 40, 40, 40, 40, 40, 40, 40, 40, 40, 48, 40, 40, 40, 45, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T10[] =
    {
	15
    };static const ANTLR3_INT32 dfa78_T11[] =
    {
	29, -1, 24, 25, -1, -1, -1, -1, 27, -1, -1, -1, -1, 25, 22, -1, 25, 25, 
	25, -1, -1, -1, 26, 28, 23, 23, -1, -1, -1, -1, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa78_T12[] =
    {
	8, 7, -1, 10, 11, -1, -1, -1, -1, 13, -1, -1, -1, -1, 11, -1, -1, 11, 11, 
	11, -1, -1, -1, 12, 14, 9, 9, -1, -1, -1, -1, 11, 11, 11, 11
    };static const ANTLR3_INT32 dfa78_T13[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 32, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T14[] =
    {
	40, 44, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 32, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T15[] =
    {
	40, 49, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 32, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T16[] =
    {
	40, 58, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 32, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T17[] =
    {
	60, 59, 40, 40, 40, 40, 40, 40, 40, 40, 40, 48, 40, 40, 40, 45, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T18[] =
    {
	40, 61, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 32, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T19[] =
    {
	15, -1, 10, 11, -1, -1, -1, -1, 13, -1, -1, -1, -1, 11, -1, -1, 11, 11, 
	11, -1, -1, -1, 12, 14, 9, 9, -1, -1, -1, -1, 11, 11, 11, 11
    };static const ANTLR3_INT32 dfa78_T20[] =
    {
	19, -1, -1, -1, -1, -1, -1, 18
    };static const ANTLR3_INT32 dfa78_T21[] =
    {
	43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 
	43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 
	43
    };static const ANTLR3_INT32 dfa78_T22[] =
    {
	33, 30, 40, 35, 36, 40, 40, 40, 40, 38, 40, 40, 40, 40, 36, 32, 31, 36, 
	36, 36, 40, 40, 40, 37, 39, 34, 34, 40, 40, 40, 40, 36, 36, 36, 36, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T23[] =
    {
	21, 20, -1, 24, 25, -1, -1, -1, -1, 27, -1, -1, -1, -1, 25, 22, -1, 25, 
	25, 25, -1, -1, -1, 26, 28, 23, 23, -1, -1, -1, -1, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa78_T24[] =
    {
	40, 61, 40, 40, 40, 40, 40, 40, 40, 40, 40, 48, 40, 40, 40, 45, 31, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T25[] =
    {
	51, 50, 40, 53, 54, 40, 40, 40, 40, 56, 40, 40, 40, 40, 54, 32, 31, 54, 
	54, 54, 40, 40, 40, 55, 57, 52, 52, 40, 40, 40, 40, 54, 54, 54, 54, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T26[] =
    {
	40, 44, 40, 35, 36, 40, 40, 40, 40, 38, 40, 40, 40, 40, 36, 32, 31, 36, 
	36, 36, 40, 40, 40, 37, 39, 34, 34, 40, 40, 40, 40, 36, 36, 36, 36, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T27[] =
    {
	40, 58, 40, 53, 54, 40, 40, 40, 40, 56, 40, 40, 40, 40, 54, 32, 31, 54, 
	54, 54, 40, 40, 40, 55, 57, 52, 52, 40, 40, 40, 40, 54, 54, 54, 54, 40, 
	40
    };static const ANTLR3_INT32 dfa78_T28[] =
    {
	17, 16, -1, -1, -1, -1, -1, -1, 18
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa78_transitions[] =
{
    dfa78_T2, dfa78_T3, dfa78_T3, dfa78_T3, dfa78_T3, dfa78_T3, dfa78_T3, 
    dfa78_T12, dfa78_T10, dfa78_T8, dfa78_T8, dfa78_T8, dfa78_T8, dfa78_T8, 
    dfa78_T8, dfa78_T19, dfa78_T28, dfa78_T4, dfa78_T23, dfa78_T20, dfa78_T23, 
    dfa78_T5, dfa78_T22, dfa78_T0, dfa78_T0, dfa78_T0, dfa78_T0, dfa78_T0, 
    dfa78_T0, dfa78_T11, dfa78_T22, dfa78_T21, dfa78_T0, dfa78_T14, dfa78_T7, 
    dfa78_T7, dfa78_T7, dfa78_T7, dfa78_T7, dfa78_T7, dfa78_T13, dfa78_T_empty, 
    dfa78_T_empty, dfa78_T13, dfa78_T26, dfa78_T0, dfa78_T1, dfa78_T15, 
    dfa78_T25, dfa78_T9, dfa78_T25, dfa78_T16, dfa78_T6, dfa78_T6, dfa78_T6, 
    dfa78_T6, dfa78_T6, dfa78_T6, dfa78_T27, dfa78_T17, dfa78_T18, dfa78_T24	
};

static ANTLR3_INT32 dfa78_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA78_26;

    	    ANTLR3_MARKER index78_26;


    		LA78_26 = LA(1);

    	 
    	    index78_26 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_26);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA78_27;

    	    ANTLR3_MARKER index78_27;


    		LA78_27 = LA(1);

    	 
    	    index78_27 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_27);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA78_28;

    	    ANTLR3_MARKER index78_28;


    		LA78_28 = LA(1);

    	 
    	    index78_28 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_28);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA78_23;

    	    ANTLR3_MARKER index78_23;


    		LA78_23 = LA(1);

    	 
    	    index78_23 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_23);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA78_45;

    	    ANTLR3_MARKER index78_45;


    		LA78_45 = LA(1);

    	 
    	    index78_45 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_45);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA78_24;

    	    ANTLR3_MARKER index78_24;


    		LA78_24 = LA(1);

    	 
    	    index78_24 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_24);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA78_25;

    	    ANTLR3_MARKER index78_25;


    		LA78_25 = LA(1);

    	 
    	    index78_25 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_25);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA78_32;

    	    ANTLR3_MARKER index78_32;


    		LA78_32 = LA(1);

    	 
    	    index78_32 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(Digest))) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 42;
    	    }

    	 
    		SEEK(index78_32);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"957:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );";
    EXCEPTION->decisionNum  = 78;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 78
 */
static
ANTLR3_CYCLIC_DFA cdfa78
    =	{
	    78,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"957:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );",	
	    (CDFA_SPECIAL_FUNC) dfa78_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa78_eot,	    /* EOT table			    */
	    dfa78_eof,	    /* EOF table			    */
	    dfa78_min,	    /* Minimum tokens for each state    */
	    dfa78_max,	    /* Maximum tokens for each state    */
	    dfa78_accept,	/* Accept table			    */
	    dfa78_special,	/* Special transition states	    */
	    dfa78_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 78
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    965:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );
 */
static const ANTLR3_INT32 dfa80_eot[59] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa80_eof[59] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa80_min[59] =
    {
	7, 4, 4, 4, 4, 4, 4, 4, 5, 4, 5, 4, 5, 0, 0, 0, 0, 0, 0, 4, 5, -1, -1, 
	-1, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, -1, -1, 4, 0, 4, 4, 4, 
	-1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa80_max[59] =
    {
	38, 38, 38, 38, 38, 38, 38, 12, 5, 38, 12, 38, 5, 0, 0, 0, 0, 0, 0, 40, 
	38, -1, -1, -1, 40, 40, 0, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, 
	-1, -1, 40, 0, 40, 40, 40, -1, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };
static const ANTLR3_INT32 dfa80_accept[59] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 3, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 
	2, 4, 6, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR3_INT32 dfa80_special[59] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 2, 3, 4, -1, 
	-1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa80_T_empty	    NULL

static const ANTLR3_INT32 dfa80_T0[] =
    {
	8, 7, -1, 2, 3, -1, -1, -1, 9, 5, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, 6, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa80_T1[] =
    {
	34, 40, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 26, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T2[] =
    {
	34, 46, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 26, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T3[] =
    {
	34, 55, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 26, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T4[] =
    {
	34, 58, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 26, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T5[] =
    {
	57, 56, 34, 50, 51, 34, 34, 34, 34, 53, 34, 44, 34, 34, 51, 41, 25, 51, 
	51, 51, 34, 34, 34, 52, 54, 49, 49, 34, 34, 34, 34, 51, 51, 51, 51, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T6[] =
    {
	43, 42, 34, 34, 34, 34, 34, 34, 34, 34, 34, 44, 34, 34, 34, 41, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T7[] =
    {
	35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 
	35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 
	35
    };static const ANTLR3_INT32 dfa80_T8[] =
    {
	10, -1, -1, -1, -1, -1, -1, 9
    };static const ANTLR3_INT32 dfa80_T9[] =
    {
	20, -1, 14, 15, -1, -1, -1, -1, 17, -1, -1, -1, -1, 15, 19, -1, 15, 15, 
	15, -1, -1, -1, 16, 18, 13, 13, -1, -1, -1, -1, 15, 15, 15, 15
    };static const ANTLR3_INT32 dfa80_T10[] =
    {
	34, 46, 34, 34, 34, 34, 34, 34, 34, 34, 34, 44, 34, 34, 34, 41, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T11[] =
    {
	-1
    };static const ANTLR3_INT32 dfa80_T12[] =
    {
	27, 24, 34, 29, 30, 34, 34, 34, 34, 32, 34, 34, 34, 34, 30, 26, 25, 30, 
	30, 30, 34, 34, 34, 31, 33, 28, 28, 34, 34, 34, 34, 30, 30, 30, 30, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T13[] =
    {
	48, 47, 34, 50, 51, 34, 34, 34, 34, 53, 34, 34, 34, 34, 51, 26, 25, 51, 
	51, 51, 34, 34, 34, 52, 54, 49, 49, 34, 34, 34, 34, 51, 51, 51, 51, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T14[] =
    {
	43, 42, 34, 29, 30, 34, 34, 34, 34, 32, 34, 44, 34, 34, 30, 41, 25, 30, 
	30, 30, 34, 34, 34, 31, 33, 28, 28, 34, 34, 34, 34, 30, 30, 30, 30, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T15[] =
    {
	34, 40, 34, 29, 30, 34, 34, 34, 34, 32, 34, 34, 34, 34, 30, 26, 25, 30, 
	30, 30, 34, 34, 34, 31, 33, 28, 28, 34, 34, 34, 34, 30, 30, 30, 30, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T16[] =
    {
	34, 55, 34, 50, 51, 34, 34, 34, 34, 53, 34, 34, 34, 34, 51, 26, 25, 51, 
	51, 51, 34, 34, 34, 52, 54, 49, 49, 34, 34, 34, 34, 51, 51, 51, 51, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T17[] =
    {
	57, 56, 34, 34, 34, 34, 34, 34, 34, 34, 34, 44, 34, 34, 34, 41, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T18[] =
    {
	8, 7, -1, -1, -1, -1, -1, -1, 9
    };static const ANTLR3_INT32 dfa80_T19[] =
    {
	34, 58, 34, 34, 34, 34, 34, 34, 34, 34, 34, 44, 34, 34, 34, 41, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T20[] =
    {
	12, 11, -1, 14, 15, -1, -1, -1, -1, 17, -1, -1, -1, -1, 15, 19, -1, 15, 
	15, 15, -1, -1, -1, 16, 18, 13, 13, -1, -1, -1, -1, 15, 15, 15, 15
    };static const ANTLR3_INT32 dfa80_T21[] =
    {
	10
    };static const ANTLR3_INT32 dfa80_T22[] =
    {
	20
    };static const ANTLR3_INT32 dfa80_T23[] =
    {
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 26, 25, 34, 
	34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
	34
    };static const ANTLR3_INT32 dfa80_T24[] =
    {
	2, 3, -1, -1, -1, -1, 5, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, 6, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa80_transitions[] =
{
    dfa80_T24, dfa80_T0, dfa80_T0, dfa80_T0, dfa80_T0, dfa80_T0, dfa80_T0, 
    dfa80_T18, dfa80_T21, dfa80_T20, dfa80_T8, dfa80_T20, dfa80_T22, dfa80_T11, 
    dfa80_T11, dfa80_T11, dfa80_T11, dfa80_T11, dfa80_T11, dfa80_T12, dfa80_T9, 
    dfa80_T_empty, dfa80_T_empty, dfa80_T_empty, dfa80_T12, dfa80_T7, dfa80_T11, 
    dfa80_T1, dfa80_T14, dfa80_T14, dfa80_T14, dfa80_T14, dfa80_T14, dfa80_T14, 
    dfa80_T23, dfa80_T23, dfa80_T_empty, dfa80_T_empty, dfa80_T_empty, dfa80_T_empty, 
    dfa80_T15, dfa80_T11, dfa80_T6, dfa80_T2, dfa80_T13, dfa80_T_empty, 
    dfa80_T10, dfa80_T13, dfa80_T3, dfa80_T5, dfa80_T5, dfa80_T5, dfa80_T5, 
    dfa80_T5, dfa80_T5, dfa80_T16, dfa80_T17, dfa80_T4, dfa80_T19	
};

static ANTLR3_INT32 dfa80_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA80_14;

    	    ANTLR3_MARKER index80_14;


    		LA80_14 = LA(1);

    	 
    	    index80_14 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 21;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_14);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA80_15;

    	    ANTLR3_MARKER index80_15;


    		LA80_15 = LA(1);

    	 
    	    index80_15 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 21;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_15);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA80_16;

    	    ANTLR3_MARKER index80_16;


    		LA80_16 = LA(1);

    	 
    	    index80_16 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 21;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_16);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA80_17;

    	    ANTLR3_MARKER index80_17;


    		LA80_17 = LA(1);

    	 
    	    index80_17 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 21;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_17);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA80_18;

    	    ANTLR3_MARKER index80_18;


    		LA80_18 = LA(1);

    	 
    	    index80_18 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 21;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_18);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA80_13;

    	    ANTLR3_MARKER index80_13;


    		LA80_13 = LA(1);

    	 
    	    index80_13 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(algorithm))) )
    	    {
    	        s = 21;
    	    }

    	    else if ( ((IS_TOKEN(stale))) )
    	    {
    	        s = 22;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_13);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA80_41;

    	    ANTLR3_MARKER index80_41;


    		LA80_41 = LA(1);

    	 
    	    index80_41 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(realm))) )
    	    {
    	        s = 36;
    	    }

    	    else if ( ((IS_TOKEN(nonce))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( ((IS_TOKEN(opaque))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( ((IS_TOKEN(qop))) )
    	    {
    	        s = 45;
    	    }

    	    else if ( ((IS_TOKEN(domain))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_41);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA80_26;

    	    ANTLR3_MARKER index80_26;


    		LA80_26 = LA(1);

    	 
    	    index80_26 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(realm))) )
    	    {
    	        s = 36;
    	    }

    	    else if ( ((IS_TOKEN(nonce))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( ((IS_TOKEN(opaque))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( ((IS_TOKEN(domain))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 23;
    	    }

    	 
    		SEEK(index80_26);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"965:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );";
    EXCEPTION->decisionNum  = 80;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 80
 */
static
ANTLR3_CYCLIC_DFA cdfa80
    =	{
	    80,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"965:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );",	
	    (CDFA_SPECIAL_FUNC) dfa80_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa80_eot,	    /* EOT table			    */
	    dfa80_eof,	    /* EOF table			    */
	    dfa80_min,	    /* Minimum tokens for each state    */
	    dfa80_max,	    /* Maximum tokens for each state    */
	    dfa80_accept,	/* Accept table			    */
	    dfa80_special,	/* Special transition states	    */
	    dfa80_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 80
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1188:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] )
 */
static const ANTLR3_INT32 dfa96_eot[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa96_eof[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa96_min[30] =
    {
	4, 4, 5, 4, 4, 4, 4, 4, 4, -1, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, -1, 
	4, 4, 4, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa96_max[30] =
    {
	38, 38, 5, 38, 38, 38, 38, 38, 38, -1, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, -1, 38, 38, 38, 38, 38, 38, 38
    };
static const ANTLR3_INT32 dfa96_accept[30] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa96_special[30] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa96_T_empty	    NULL

static const ANTLR3_INT32 dfa96_T0[] =
    {
	9, 9, -1, 4, 5, 22, -1, -1, -1, 7, -1, -1, -1, -1, 5, -1, -1, 5, 5, 5, 
	-1, -1, -1, 6, 8, 23, 23, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa96_T1[] =
    {
	16, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa96_T2[] =
    {
	9, 9, -1, 25, 28, 22, -1, -1, -1, 26, -1, -1, -1, -1, 27, -1, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 24, 24, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa96_T3[] =
    {
	2, 1, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa96_T4[] =
    {
	9, 9, -1, 18, 21, 22, -1, -1, -1, 19, -1, -1, -1, -1, 20, -1, -1, 5, 5, 
	5, -1, -1, -1, 6, 8, 17, 17, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa96_T5[] =
    {
	9, 9, -1, 11, 12, 22, -1, -1, -1, 14, -1, -1, -1, -1, 12, -1, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 29, 29, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa96_T6[] =
    {
	2, 1, -1, 4, 5, -1, -1, -1, -1, 7, -1, -1, -1, -1, 5, 9, -1, 5, 5, 5, -1, 
	-1, -1, 6, 8, 3, 3, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa96_T7[] =
    {
	16
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa96_transitions[] =
{
    dfa96_T6, dfa96_T3, dfa96_T7, dfa96_T4, dfa96_T0, dfa96_T0, dfa96_T0, 
    dfa96_T0, dfa96_T0, dfa96_T_empty, dfa96_T2, dfa96_T5, dfa96_T5, dfa96_T5, 
    dfa96_T5, dfa96_T5, dfa96_T1, dfa96_T4, dfa96_T4, dfa96_T4, dfa96_T4, 
    dfa96_T4, dfa96_T_empty, dfa96_T0, dfa96_T2, dfa96_T2, dfa96_T2, dfa96_T2, 
    dfa96_T2, dfa96_T5	
};


/* Declare tracking structure for Cyclic DFA 96
 */
static
ANTLR3_CYCLIC_DFA cdfa96
    =	{
	    96,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1188:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa96_eot,	    /* EOT table			    */
	    dfa96_eof,	    /* EOF table			    */
	    dfa96_min,	    /* Minimum tokens for each state    */
	    dfa96_max,	    /* Maximum tokens for each state    */
	    dfa96_accept,	/* Accept table			    */
	    dfa96_special,	/* Special transition states	    */
	    dfa96_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 96
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1207:8: ( name_addr[address] | paramless_addr_spec[address] )
 */
static const ANTLR3_INT32 dfa100_eot[18] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa100_eof[18] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa100_min[18] =
    {
	4, 4, 5, 4, 4, 4, 4, 4, 4, -1, 4, 4, 4, 4, 4, 4, 5, -1
    };
static const ANTLR3_INT32 dfa100_max[18] =
    {
	38, 38, 5, 38, 38, 38, 38, 38, 38, -1, 38, 38, 38, 38, 38, 38, 38, -1
    };
static const ANTLR3_INT32 dfa100_accept[18] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 2
    };
static const ANTLR3_INT32 dfa100_special[18] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa100_T_empty	    NULL

static const ANTLR3_INT32 dfa100_T0[] =
    {
	9, 9, -1, 11, 12, 17, -1, -1, -1, 14, -1, -1, -1, -1, 12, -1, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa100_T1[] =
    {
	2, 1, -1, 4, 5, -1, -1, -1, -1, 7, -1, -1, -1, -1, 5, 9, -1, 5, 5, 5, -1, 
	-1, -1, 6, 8, 3, 3, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa100_T2[] =
    {
	9, 9, -1, 4, 5, 17, -1, -1, -1, 7, -1, -1, -1, -1, 5, -1, -1, 5, 5, 5, 
	-1, -1, -1, 6, 8, 3, 3, 9, -1, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa100_T3[] =
    {
	2, 1, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };static const ANTLR3_INT32 dfa100_T4[] =
    {
	16
    };static const ANTLR3_INT32 dfa100_T5[] =
    {
	16, -1, 11, 12, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, 9, -1, 12, 12, 
	12, -1, -1, -1, 13, 15, 10, 10, 9, -1, -1, -1, 12, 12, 12, 12
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa100_transitions[] =
{
    dfa100_T1, dfa100_T3, dfa100_T4, dfa100_T2, dfa100_T2, dfa100_T2, dfa100_T2, 
    dfa100_T2, dfa100_T2, dfa100_T_empty, dfa100_T0, dfa100_T0, dfa100_T0, 
    dfa100_T0, dfa100_T0, dfa100_T0, dfa100_T5, dfa100_T_empty	
};


/* Declare tracking structure for Cyclic DFA 100
 */
static
ANTLR3_CYCLIC_DFA cdfa100
    =	{
	    100,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1207:8: ( name_addr[address] | paramless_addr_spec[address] )",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa100_eot,	    /* EOT table			    */
	    dfa100_eof,	    /* EOF table			    */
	    dfa100_min,	    /* Minimum tokens for each state    */
	    dfa100_max,	    /* Maximum tokens for each state    */
	    dfa100_accept,	/* Accept table			    */
	    dfa100_special,	/* Special transition states	    */
	    dfa100_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 100
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 1263:34: ( semi via_params )*
 */
static const ANTLR3_INT32 dfa106_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa106_eof[6] =
    {
	3, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa106_min[6] =
    {
	4, 4, 5, -1, -1, 5
    };
static const ANTLR3_INT32 dfa106_max[6] =
    {
	16, 16, 5, -1, -1, 16
    };
static const ANTLR3_INT32 dfa106_accept[6] =
    {
	-1, -1, -1, 2, 1, -1
    };
static const ANTLR3_INT32 dfa106_special[6] =
    {	
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa106_T_empty	    NULL

static const ANTLR3_INT32 dfa106_T0[] =
    {
	5
    };static const ANTLR3_INT32 dfa106_T1[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4
    };static const ANTLR3_INT32 dfa106_T2[] =
    {
	2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa106_transitions[] =
{
    dfa106_T2, dfa106_T2, dfa106_T0, dfa106_T_empty, dfa106_T_empty, dfa106_T1	
};


/* Declare tracking structure for Cyclic DFA 106
 */
static
ANTLR3_CYCLIC_DFA cdfa106
    =	{
	    106,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 1263:34: ( semi via_params )*",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa106_eot,	    /* EOT table			    */
	    dfa106_eof,	    /* EOF table			    */
	    dfa106_min,	    /* Minimum tokens for each state    */
	    dfa106_max,	    /* Maximum tokens for each state    */
	    dfa106_accept,	/* Accept table			    */
	    dfa106_special,	/* Special transition states	    */
	    dfa106_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 106
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1265:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );
 */
static const ANTLR3_INT32 dfa107_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa107_eof[12] =
    {
	-1, 7, 7, 7, 7, 7, 7, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa107_min[12] =
    {
	7, 4, 4, 4, 4, 4, 4, -1, 4, 0, 0, -1
    };
static const ANTLR3_INT32 dfa107_max[12] =
    {
	38, 38, 38, 38, 38, 38, 38, -1, 38, 0, 0, -1
    };
static const ANTLR3_INT32 dfa107_accept[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 1
    };
static const ANTLR3_INT32 dfa107_special[12] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa107_T_empty	    NULL

static const ANTLR3_INT32 dfa107_T0[] =
    {
	7, 7, -1, 2, 3, -1, -1, -1, 8, 5, -1, 7, 7, -1, 3, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, 6, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa107_T1[] =
    {
	-1
    };static const ANTLR3_INT32 dfa107_T2[] =
    {
	2, 3, -1, -1, -1, -1, 5, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, 6, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa107_T3[] =
    {
	7, 7, -1, 9, 7, 11, -1, -1, -1, 7, -1, -1, -1, -1, 7, 7, -1, 7, 7, 7, -1, 
	-1, -1, 7, 7, 10, 7, -1, -1, -1, -1, 7, 7, 7, 7
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa107_transitions[] =
{
    dfa107_T2, dfa107_T0, dfa107_T0, dfa107_T0, dfa107_T0, dfa107_T0, dfa107_T0, 
    dfa107_T_empty, dfa107_T3, dfa107_T1, dfa107_T1, dfa107_T_empty	
};

static ANTLR3_INT32 dfa107_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA107_10;

    	    ANTLR3_MARKER index107_10;


    		LA107_10 = LA(1);

    	 
    	    index107_10 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(received))) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 7;
    	    }

    	 
    		SEEK(index107_10);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA107_9;

    	    ANTLR3_MARKER index107_9;


    		LA107_9 = LA(1);

    	 
    	    index107_9 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(received))) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 7;
    	    }

    	 
    		SEEK(index107_9);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"1265:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );";
    EXCEPTION->decisionNum  = 107;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 107
 */
static
ANTLR3_CYCLIC_DFA cdfa107
    =	{
	    107,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1265:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );",	
	    (CDFA_SPECIAL_FUNC) dfa107_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa107_eot,	    /* EOT table			    */
	    dfa107_eof,	    /* EOF table			    */
	    dfa107_min,	    /* Minimum tokens for each state    */
	    dfa107_max,	    /* Maximum tokens for each state    */
	    dfa107_accept,	/* Accept table			    */
	    dfa107_special,	/* Special transition states	    */
	    dfa107_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 107
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1443:43: ( ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] )
 */
static const ANTLR3_INT32 dfa117_eot[165] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR3_INT32 dfa117_eof[165] =
    {
	-1, 6, -1, -1, -1, -1, -1, 6, 6, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	6, 6, 6, 6, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, 
	-1, -1, 6, -1, -1, 6, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 6, 
	6, -1, -1, 6, 6, -1, 6, 6, 6, 6, -1, -1, 6, -1, 6, 6, 6, 6, 6, 6, 6, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 6, -1, -1, -1, -1, -1, 6, 
	6, -1, 6, 6, -1, 6, 6, -1, -1, 6, 6, 6, 6, -1, 6, 6, -1, 6, 6, 6, 6, -1, 
	6, -1, 6, -1, -1, 6, 6, 6
    };
static const ANTLR3_INT32 dfa117_min[165] =
    {
	6, 4, 6, -1, -1, -1, -1, 4, 4, 4, 6, 7, -1, 6, 4, 4, 6, 6, 6, 6, -1, 6, 
	-1, 4, -1, -1, -1, -1, -1, -1, -1, 6, 6, 6, 6, 7, 6, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 6, 6, 6, 6, 4, 4, 6, 6, 6, 6, 7, 6, 4, 7, 4, 4, 4, 6, 4, 4, 
	6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 7, 6, 4, 4, 7, 4, 4, 4, 4, 7, 6, 4, 6, 4, 
	4, 4, 4, 4, 4, 4, 0, 0, 0, 7, 0, 0, 0, 0, 0, 4, 4, 6, 6, 4, 4, 7, 6, 6, 
	6, 6, 7, 6, 6, 7, 6, 6, 6, 6, 7, 6, 4, 4, 7, 6, 6, 4, 4, 4, 4, 7, 4, 4, 
	7, 4, 4, 0, 6, 4, 4, 4, 4, 7, 4, 4, 6, 4, 4, 4, 4, 7, 4, 6, 4, 7, 7, 4, 
	4, 4
    };
static const ANTLR3_INT32 dfa117_max[165] =
    {
	38, 38, 38, -1, -1, -1, -1, 38, 38, 38, 38, 38, -1, 38, 38, 38, 38, 38, 
	38, 38, -1, 38, -1, 38, -1, -1, -1, -1, -1, -1, -1, 38, 38, 38, 38, 29, 
	38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 29, 38, 38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 
	38, 38, 38, 38, 38, 29, 38, 38, 38, 29, 38, 38, 38, 38, 29, 38, 38, 38, 
	38, 38, 38, 38, 38, 38, 38, 0, 0, 0, 29, 0, 0, 0, 0, 0, 38, 38, 38, 38, 
	38, 38, 29, 38, 38, 38, 38, 29, 38, 38, 29, 38, 38, 38, 38, 29, 38, 38, 
	38, 29, 38, 38, 38, 38, 38, 38, 29, 38, 38, 29, 38, 38, 0, 38, 38, 38, 
	38, 38, 29, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 29, 29, 38, 38, 
	38
    };
static const ANTLR3_INT32 dfa117_accept[165] =
    {
	-1, -1, -1, 1, 1, 1, 2, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 
	-1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa117_special[165] =
    {	
	103, 63, 80, -1, -1, -1, -1, 66, 62, 15, 95, 5, -1, 49, 110, 34, 76, 39, 
	57, 108, -1, 19, -1, 59, -1, -1, -1, -1, -1, -1, -1, 29, 87, 1, 42, -1, 
	83, 117, 72, 68, -1, 100, 12, 73, 40, -1, 96, 101, 85, 90, 112, 54, 79, 
	115, 69, 106, 27, -1, 118, 48, -1, 64, -1, -1, 51, -1, -1, 78, 41, 2, 60, 
	26, -1, 4, 20, 50, 94, -1, 81, 58, 55, -1, 98, 35, 65, 111, -1, 52, 32, 
	7, 71, 36, 18, -1, 47, 74, 24, 37, 25, 38, -1, 9, 14, 13, 17, 16, 97, 21, 
	104, 91, -1, -1, -1, 116, 70, 107, 28, -1, 119, 113, -1, 30, 88, 3, 43, 
	-1, 84, -1, -1, -1, 82, 44, 75, 6, 53, 120, -1, 67, 86, -1, 33, 93, 0, 
	105, 31, 46, 77, 10, -1, 89, 99, 114, 11, 61, 102, 22, -1, 56, 8, 23, -1, 
	-1, 45, 92, 109
    };

/** Used when there is no transition table entry for a particular state */
#define dfa117_T_empty	    NULL

static const ANTLR3_INT32 dfa117_T0[] =
    {
	-1
    };static const ANTLR3_INT32 dfa117_T1[] =
    {
	36, 33, 34, 31, 12, 5, 59, 36, 36, 5, 5, 36, 34, -1, -1, 34, 34, 34, -1, 
	6, 6, 35, -1, 32, 32, -1, -1, -1, -1, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa117_T2[] =
    {
	6, 6, -1, 70, 71, 6, 12, 26, 27, 73, 29, 30, -1, -1, 71, -1, -1, 71, 71, 
	71, -1, -1, -1, 72, 6, 69, 69, 6, -1, -1, -1, 71, 71, 71, 71
    };static const ANTLR3_INT32 dfa117_T3[] =
    {
	126, 123, 124, 121, 12, 5, 138, 126, 126, 5, 5, 126, 124, -1, -1, 124, 
	124, 124, -1, 6, 6, 125, -1, 122, 122, -1, -1, -1, -1, 124, 124, 124, 124
    };static const ANTLR3_INT32 dfa117_T4[] =
    {
	23, 24, -1, 12, 26, 27, 28, 29, 30, -1, -1, 24, -1, -1, 24, 24, 24, -1, 
	-1, -1, 25, -1, 22, 22, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa117_T5[] =
    {
	6, 6, 6, 146, 147, 6, 12, 78, 27, 149, 150, 51, 6, 6, 147, -1, -1, 147, 
	147, 147, -1, 6, 6, 148, -1, 145, 145, -1, -1, -1, -1, 147, 147, 147, 147
    };static const ANTLR3_INT32 dfa117_T6[] =
    {
	6, 6, 5, 43, 44, 64, 12, 5, 5, 46, 5, 5, 5, 5, 44, -1, -1, 44, 44, 44, 
	-1, -1, -1, 45, 6, 42, 42, 6, -1, -1, -1, 44, 44, 44, 44
    };static const ANTLR3_INT32 dfa117_T7[] =
    {
	6, 6, 5, 9, 7, 11, 12, 5, 5, 5, 5, 15, 14, 13, 10, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 8, 8, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T8[] =
    {
	6, 6, 5, 91, 92, 20, 12, 5, 5, 94, 5, 15, 14, 5, 92, -1, -1, 92, 92, 92, 
	-1, -1, -1, 93, 6, 90, 90, -1, -1, -1, -1, 92, 92, 92, 92
    };static const ANTLR3_INT32 dfa117_T9[] =
    {
	5, 50, 49, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T10[] =
    {
	6, 6, -1, 66, 6, 6, -1, -1, -1, 6, -1, -1, -1, -1, 6, -1, -1, 6, 6, 6, 
	-1, -1, -1, 6, 6, 65, 6, 6, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T11[] =
    {
	6, 6, -1, 111, 6, 6, -1, -1, -1, 6, -1, -1, -1, -1, 6, -1, -1, 6, 6, 6, 
	-1, -1, -1, 6, 6, 110, 6, 6, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T12[] =
    {
	6, 6, 6, 75, 76, 6, 12, 78, 27, 79, 80, 51, 6, 6, 76, -1, -1, 76, 76, 76, 
	-1, 6, 6, 77, -1, 74, 74, -1, -1, -1, -1, 76, 76, 76, 76
    };static const ANTLR3_INT32 dfa117_T13[] =
    {
	6, 6, -1, 63, 6, -1, -1, -1, 6, 6, -1, 6, 6, -1, 6, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, 6, 62, 6, -1, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T14[] =
    {
	6, 6, 157, 154, 155, 152, 12, 87, 5, 157, 157, 15, 14, 157, 155, -1, -1, 
	155, 155, 155, -1, 6, 6, 156, -1, 153, 153, -1, -1, -1, -1, 155, 155, 155, 
	155
    };static const ANTLR3_INT32 dfa117_T15[] =
    {
	134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 134
    };static const ANTLR3_INT32 dfa117_T16[] =
    {
	89, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 89
    };static const ANTLR3_INT32 dfa117_T17[] =
    {
	119, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 119
    };static const ANTLR3_INT32 dfa117_T18[] =
    {
	137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 137
    };static const ANTLR3_INT32 dfa117_T19[] =
    {
	142, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 142
    };static const ANTLR3_INT32 dfa117_T20[] =
    {
	151, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 151
    };static const ANTLR3_INT32 dfa117_T21[] =
    {
	158, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 158
    };static const ANTLR3_INT32 dfa117_T22[] =
    {
	163, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 163
    };static const ANTLR3_INT32 dfa117_T23[] =
    {
	164, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 164
    };static const ANTLR3_INT32 dfa117_T24[] =
    {
	6, 6, 5, 162, 49, 11, 12, 5, 5, 5, 5, 15, 14, 13, 19, -1, -1, 3, 3, 3, 
	-1, -1, -1, 4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T25[] =
    {
	6, 6, 5, 38, 39, 20, 12, 5, 61, 41, 5, 15, 14, 5, 39, -1, -1, 39, 39, 39, 
	-1, -1, -1, 40, 6, 37, 37, -1, -1, -1, -1, 39, 39, 39, 39
    };static const ANTLR3_INT32 dfa117_T26[] =
    {
	6, 55, 56, 6, 12, 26, 52, 53, 58, 30, -1, 6, 56, -1, -1, 56, 56, 56, -1, 
	6, 6, 57, -1, 54, 54, -1, -1, -1, -1, 56, 56, 56, 56
    };static const ANTLR3_INT32 dfa117_T27[] =
    {
	6, 115, 116, 6, 12, 26, 135, 113, 118, 30, -1, 6, 116, -1, -1, 116, 116, 
	116, -1, 6, 6, 117, -1, 114, 114, -1, -1, -1, -1, 116, 116, 116, 116
    };static const ANTLR3_INT32 dfa117_T28[] =
    {
	6, 6, 5, 159, 49, 11, 12, 5, 5, 5, 5, 15, 14, 13, 19, -1, -1, 3, 3, 3, 
	-1, -1, -1, 4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T29[] =
    {
	6, 6, 88, 84, 85, 82, 12, 87, 5, 88, 88, 15, 14, 88, 85, -1, -1, 85, 85, 
	85, -1, 6, 6, 86, -1, 83, 83, -1, -1, -1, -1, 85, 85, 85, 85
    };static const ANTLR3_INT32 dfa117_T30[] =
    {
	6, 6, 5, 43, 44, 20, 12, 5, 5, 46, 5, 5, 5, 5, 44, 6, -1, 44, 44, 44, -1, 
	-1, -1, 45, 6, 42, 42, 6, -1, -1, -1, 44, 44, 44, 44
    };static const ANTLR3_INT32 dfa117_T31[] =
    {
	6, 6, -1, 96, 6, -1, -1, -1, 6, 6, -1, 6, 6, -1, 6, -1, -1, 6, 6, 6, -1, 
	-1, -1, 6, 6, 95, 6, -1, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T32[] =
    {
	5, 48, 3, 20, 12, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T33[] =
    {
	6, 6, -1, 107, 6, 6, -1, -1, -1, 6, -1, -1, -1, -1, 6, -1, -1, 6, 6, 6, 
	-1, -1, -1, 6, 6, 106, 6, 6, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T34[] =
    {
	5, 109, 3, 20, 12, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T35[] =
    {
	6, 6, -1, 133, 6, 6, -1, -1, -1, 6, -1, -1, -1, -1, 6, -1, -1, 6, 6, 6, 
	-1, -1, -1, 6, 6, 132, 6, 6, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T36[] =
    {
	6, 6, -1, 141, 6, -1, -1, -1, -1, 6, -1, 6, 6, -1, 6, -1, -1, 6, 6, 6, 
	-1, -1, -1, 6, 6, 140, 6, -1, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T37[] =
    {
	5, 144, 3, 20, 12, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T38[] =
    {
	6, 6, 5, 50, 49, 11, 12, 5, 5, 5, 5, 15, 14, 13, 19, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T39[] =
    {
	36, 33, 34, 31, 12, 5, 5, 36, 36, 5, 5, 36, 34, -1, -1, 34, 34, 34, -1, 
	6, 6, 35, -1, 32, 32, -1, -1, -1, -1, 34, 34, 34, 34
    };static const ANTLR3_INT32 dfa117_T40[] =
    {
	6, 98, 99, -1, 12, 101, 102, 103, 104, 105, 6, 6, 99, -1, -1, 99, 99, 99, 
	-1, 6, -1, 100, -1, 97, 97, -1, -1, -1, -1, 99, 99, 99, 99
    };static const ANTLR3_INT32 dfa117_T41[] =
    {
	126, 123, 124, 121, 12, 5, 5, 126, 126, 5, 5, 126, 124, -1, -1, 124, 124, 
	124, -1, 6, 6, 125, -1, 122, 122, -1, -1, -1, -1, 124, 124, 124, 124
    };static const ANTLR3_INT32 dfa117_T42[] =
    {
	139, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 139
    };static const ANTLR3_INT32 dfa117_T43[] =
    {
	81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 81
    };static const ANTLR3_INT32 dfa117_T44[] =
    {
	60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 60
    };static const ANTLR3_INT32 dfa117_T45[] =
    {
	161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 161
    };static const ANTLR3_INT32 dfa117_T46[] =
    {
	6, 6, -1, 70, 71, -1, 12, 26, 27, 73, 29, 30, -1, -1, 71, 6, -1, 71, 71, 
	71, -1, -1, -1, 72, 6, 69, 69, 6, -1, -1, -1, 71, 71, 71, 71
    };static const ANTLR3_INT32 dfa117_T47[] =
    {
	112, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 112
    };static const ANTLR3_INT32 dfa117_T48[] =
    {
	160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 160
    };static const ANTLR3_INT32 dfa117_T49[] =
    {
	120, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 120
    };static const ANTLR3_INT32 dfa117_T50[] =
    {
	129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 129
    };static const ANTLR3_INT32 dfa117_T51[] =
    {
	136, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 136
    };static const ANTLR3_INT32 dfa117_T52[] =
    {
	6, 6, -1, 23, 24, -1, 12, 26, 27, 28, 29, 51, 6, 6, 24, -1, -1, 24, 24, 
	24, -1, -1, -1, 25, -1, 22, 22, -1, -1, -1, -1, 24, 24, 24, 24
    };static const ANTLR3_INT32 dfa117_T53[] =
    {
	6, 6, 5, 91, 92, 20, 12, 5, 5, 94, 5, 5, 5, 5, 92, 6, -1, 92, 92, 92, -1, 
	-1, -1, 93, 6, 90, 90, -1, -1, -1, -1, 92, 92, 92, 92
    };static const ANTLR3_INT32 dfa117_T54[] =
    {
	6, 6, 5, 21, 3, 11, 12, 5, 5, 5, 5, 15, 14, 13, 3, -1, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T55[] =
    {
	5, 47, 17, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T56[] =
    {
	5, 108, 68, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T57[] =
    {
	5, 16, 17, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T58[] =
    {
	6, 115, 116, 6, 12, 26, 27, 113, 118, 30, -1, 6, 116, -1, -1, 116, 116, 
	116, -1, 6, 6, 117, -1, 114, 114, -1, -1, -1, -1, 116, 116, 116, 116
    };static const ANTLR3_INT32 dfa117_T59[] =
    {
	5, 143, 131, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T60[] =
    {
	5, 67, 68, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T61[] =
    {
	5, 21, 3, 20, 12, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T62[] =
    {
	5, 130, 131, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T63[] =
    {
	5, 9, 3, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 8, 8, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T64[] =
    {
	5, 50, 17, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T65[] =
    {
	6, 6, -1, 128, 6, -1, -1, -1, -1, 6, -1, 6, 6, -1, 6, -1, -1, 6, 6, 6, 
	-1, -1, -1, 6, 6, 127, 6, -1, -1, -1, -1, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa117_T66[] =
    {
	5, 2, 3, -1, -1, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, 6, -1, 4, 
	-1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T67[] =
    {
	5, 50, 68, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T68[] =
    {
	5, 50, 131, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T69[] =
    {
	5, 50, 3, 20, 12, 5, 5, 5, 5, 5, 5, 5, 19, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 18, 18, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa117_T70[] =
    {
	6, 6, 5, 38, 39, 20, 12, 5, 5, 41, 5, 5, 5, 5, 39, -1, -1, 39, 39, 39, 
	-1, -1, -1, 40, 6, 37, 37, -1, -1, -1, -1, 39, 39, 39, 39
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa117_transitions[] =
{
    dfa117_T66, dfa117_T7, dfa117_T57, dfa117_T_empty, dfa117_T_empty, dfa117_T_empty, 
    dfa117_T_empty, dfa117_T54, dfa117_T7, dfa117_T7, dfa117_T63, dfa117_T4, 
    dfa117_T_empty, dfa117_T39, dfa117_T70, dfa117_T30, dfa117_T55, dfa117_T32, 
    dfa117_T9, dfa117_T69, dfa117_T_empty, dfa117_T9, dfa117_T_empty, dfa117_T52, 
    dfa117_T_empty, dfa117_T_empty, dfa117_T_empty, dfa117_T_empty, dfa117_T_empty, 
    dfa117_T_empty, dfa117_T_empty, dfa117_T26, dfa117_T1, dfa117_T1, dfa117_T1, 
    dfa117_T44, dfa117_T1, dfa117_T25, dfa117_T25, dfa117_T25, dfa117_T13, 
    dfa117_T25, dfa117_T6, dfa117_T6, dfa117_T6, dfa117_T10, dfa117_T6, 
    dfa117_T64, dfa117_T60, dfa117_T61, dfa117_T9, dfa117_T46, dfa117_T12, 
    dfa117_T26, dfa117_T26, dfa117_T26, dfa117_T26, dfa117_T43, dfa117_T26, 
    dfa117_T29, dfa117_T16, dfa117_T53, dfa117_T31, dfa117_T31, dfa117_T40, 
    dfa117_T33, dfa117_T33, dfa117_T56, dfa117_T34, dfa117_T2, dfa117_T2, 
    dfa117_T2, dfa117_T11, dfa117_T2, dfa117_T12, dfa117_T12, dfa117_T12, 
    dfa117_T47, dfa117_T58, dfa117_T12, dfa117_T12, dfa117_T17, dfa117_T12, 
    dfa117_T29, dfa117_T29, dfa117_T29, dfa117_T49, dfa117_T41, dfa117_T29, 
    dfa117_T1, dfa117_T8, dfa117_T8, dfa117_T8, dfa117_T65, dfa117_T8, dfa117_T25, 
    dfa117_T25, dfa117_T0, dfa117_T0, dfa117_T0, dfa117_T50, dfa117_T0, 
    dfa117_T0, dfa117_T0, dfa117_T0, dfa117_T0, dfa117_T6, dfa117_T6, dfa117_T67, 
    dfa117_T62, dfa117_T35, dfa117_T35, dfa117_T15, dfa117_T27, dfa117_T27, 
    dfa117_T27, dfa117_T27, dfa117_T51, dfa117_T27, dfa117_T26, dfa117_T18, 
    dfa117_T27, dfa117_T3, dfa117_T3, dfa117_T3, dfa117_T42, dfa117_T3, 
    dfa117_T36, dfa117_T36, dfa117_T19, dfa117_T59, dfa117_T37, dfa117_T2, 
    dfa117_T2, dfa117_T12, dfa117_T5, dfa117_T20, dfa117_T29, dfa117_T14, 
    dfa117_T21, dfa117_T8, dfa117_T8, dfa117_T0, dfa117_T68, dfa117_T28, 
    dfa117_T5, dfa117_T5, dfa117_T5, dfa117_T48, dfa117_T5, dfa117_T5, dfa117_T27, 
    dfa117_T5, dfa117_T14, dfa117_T14, dfa117_T14, dfa117_T45, dfa117_T14, 
    dfa117_T3, dfa117_T24, dfa117_T22, dfa117_T23, dfa117_T38, dfa117_T5, 
    dfa117_T14	
};

static ANTLR3_INT32 dfa117_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA117_142;

    	    ANTLR3_MARKER index117_142;


    		LA117_142 = LA(1);

    	 
    	    index117_142 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_142);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA117_33;

    	    ANTLR3_MARKER index117_33;


    		LA117_33 = LA(1);

    	 
    	    index117_33 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_33 == EQUAL) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA117_33 == COLON) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (((LA117_33 >= HEX_CHAR) && (LA117_33 <= COMMON_CHAR))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA117_33 == DIGIT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA117_33 == DOT || LA117_33 == DASH || ((LA117_33 >= STAR) && (LA117_33 <= RPAREN)) || ((LA117_33 >= USCORE) && (LA117_33 <= SQUOTE))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA117_33 == PERCENT) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA117_33 == SLASH || ((LA117_33 >= PLUS) && (LA117_33 <= DOLLARD)) || LA117_33 == QMARK) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA117_33 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_33 >= LSBRAQUET) && (LA117_33 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_33 == AND || ((LA117_33 >= COMMA) && (LA117_33 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_33);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA117_69;

    	    ANTLR3_MARKER index117_69;


    		LA117_69 = LA(1);

    	 
    	    index117_69 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_69 >= CRLF) && (LA117_69 <= SP)) || LA117_69 == COLON || LA117_69 == BQUOTE || LA117_69 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_69 >= HEX_CHAR) && (LA117_69 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA117_69 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA117_69 == DOT || LA117_69 == DASH || ((LA117_69 >= STAR) && (LA117_69 <= RPAREN)) || ((LA117_69 >= USCORE) && (LA117_69 <= SQUOTE))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA117_69 == PERCENT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA117_69 == PLUS) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA117_69 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_69 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_69 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_69 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_69 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	 
    		SEEK(index117_69);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA117_123;

    	    ANTLR3_MARKER index117_123;


    		LA117_123 = LA(1);

    	 
    	    index117_123 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_123 == EQUAL) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA117_123 == COLON) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (((LA117_123 >= HEX_CHAR) && (LA117_123 <= COMMON_CHAR))) )
    	    {
    	        s = 122;
    	    }

    	    else if ( (LA117_123 == DIGIT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA117_123 == DOT || LA117_123 == DASH || ((LA117_123 >= STAR) && (LA117_123 <= RPAREN)) || ((LA117_123 >= USCORE) && (LA117_123 <= SQUOTE))) )
    	    {
    	        s = 124;
    	    }

    	    else if ( (LA117_123 == PERCENT) )
    	    {
    	        s = 125;
    	    }

    	    else if ( (LA117_123 == SLASH || ((LA117_123 >= PLUS) && (LA117_123 <= DOLLARD)) || LA117_123 == QMARK) )
    	    {
    	        s = 126;
    	    }

    	    else if ( (LA117_123 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_123 >= LSBRAQUET) && (LA117_123 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_123 == AND || ((LA117_123 >= COMMA) && (LA117_123 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_123);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA117_73;

    	    ANTLR3_MARKER index117_73;


    		LA117_73 = LA(1);

    	 
    	    index117_73 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_73 >= CRLF) && (LA117_73 <= SP)) || LA117_73 == COLON || LA117_73 == BQUOTE || LA117_73 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_73 >= HEX_CHAR) && (LA117_73 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA117_73 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA117_73 == DOT || LA117_73 == DASH || ((LA117_73 >= STAR) && (LA117_73 <= RPAREN)) || ((LA117_73 >= USCORE) && (LA117_73 <= SQUOTE))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA117_73 == PERCENT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA117_73 == PLUS) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA117_73 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_73 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_73 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_73 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_73 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	 
    		SEEK(index117_73);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA117_11;

    	    ANTLR3_MARKER index117_11;


    		LA117_11 = LA(1);

    	 
    	    index117_11 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_11 >= HEX_CHAR) && (LA117_11 <= COMMON_CHAR))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 22;
    	    }

    	    else if ( (LA117_11 == DIGIT) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (LA117_11 == DOT || LA117_11 == DASH || ((LA117_11 >= STAR) && (LA117_11 <= RPAREN)) || ((LA117_11 >= USCORE) && (LA117_11 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA117_11 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA117_11 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_11 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_11 == PLUS) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA117_11 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_11 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_11 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	 
    		SEEK(index117_11);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA117_133;

    	    ANTLR3_MARKER index117_133;


    		LA117_133 = LA(1);

    	 
    	    index117_133 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_133 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_133 >= HEX_CHAR) && (LA117_133 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA117_133 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA117_133 == DOT || LA117_133 == DASH || ((LA117_133 >= STAR) && (LA117_133 <= RPAREN)) || ((LA117_133 >= USCORE) && (LA117_133 <= SQUOTE))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA117_133 == PERCENT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA117_133 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_133 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_133 == PLUS) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA117_133 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_133 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (((LA117_133 >= CRLF) && (LA117_133 <= SP)) || LA117_133 == COLON || LA117_133 == BQUOTE || LA117_133 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_133);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA117_89;

    	    ANTLR3_MARKER index117_89;


    		LA117_89 = LA(1);

    	 
    	    index117_89 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_89 == EQUAL) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA117_89 == COLON) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (((LA117_89 >= HEX_CHAR) && (LA117_89 <= COMMON_CHAR))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA117_89 == DIGIT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA117_89 == DOT || LA117_89 == DASH || ((LA117_89 >= STAR) && (LA117_89 <= RPAREN)) || ((LA117_89 >= USCORE) && (LA117_89 <= SQUOTE))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA117_89 == PERCENT) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA117_89 == SLASH || ((LA117_89 >= PLUS) && (LA117_89 <= DOLLARD)) || LA117_89 == QMARK) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA117_89 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_89 >= LSBRAQUET) && (LA117_89 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_89 == AND || ((LA117_89 >= COMMA) && (LA117_89 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_89);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 8:
        
    	{
    	    ANTLR3_UINT32 LA117_158;

    	    ANTLR3_MARKER index117_158;


    		LA117_158 = LA(1);

    	 
    	    index117_158 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_158 == EQUAL) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA117_158 == COLON) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (((LA117_158 >= HEX_CHAR) && (LA117_158 <= COMMON_CHAR))) )
    	    {
    	        s = 122;
    	    }

    	    else if ( (LA117_158 == DIGIT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA117_158 == DOT || LA117_158 == DASH || ((LA117_158 >= STAR) && (LA117_158 <= RPAREN)) || ((LA117_158 >= USCORE) && (LA117_158 <= SQUOTE))) )
    	    {
    	        s = 124;
    	    }

    	    else if ( (LA117_158 == PERCENT) )
    	    {
    	        s = 125;
    	    }

    	    else if ( (LA117_158 == SLASH || ((LA117_158 >= PLUS) && (LA117_158 <= DOLLARD)) || LA117_158 == QMARK) )
    	    {
    	        s = 126;
    	    }

    	    else if ( (LA117_158 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_158 >= LSBRAQUET) && (LA117_158 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_158 == AND || ((LA117_158 >= COMMA) && (LA117_158 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_158);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 9:
        
    	{
    	    ANTLR3_UINT32 LA117_101;

    	    ANTLR3_MARKER index117_101;


    		LA117_101 = LA(1);

    	 
    	    index117_101 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_101);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 10:
        
    	{
    	    ANTLR3_UINT32 LA117_147;

    	    ANTLR3_MARKER index117_147;


    		LA117_147 = LA(1);

    	 
    	    index117_147 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_147 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_147 >= HEX_CHAR) && (LA117_147 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_147 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_147 == DOT || LA117_147 == DASH || ((LA117_147 >= STAR) && (LA117_147 <= RPAREN)) || ((LA117_147 >= USCORE) && (LA117_147 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_147 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_147 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_147 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_147 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (LA117_147 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	    else if ( (LA117_147 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_147 == EOF || ((LA117_147 >= CRLF) && (LA117_147 <= SLASH)) || LA117_147 == COLON || ((LA117_147 >= SEMI) && (LA117_147 <= QMARK)) || ((LA117_147 >= LSBRAQUET) && (LA117_147 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_147);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 11:
        
    	{
    	    ANTLR3_UINT32 LA117_152;

    	    ANTLR3_MARKER index117_152;


    		LA117_152 = LA(1);

    	 
    	    index117_152 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_152 >= HEX_CHAR) && (LA117_152 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_152 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_152 == DOT || LA117_152 == DASH || ((LA117_152 >= STAR) && (LA117_152 <= RPAREN)) || ((LA117_152 >= USCORE) && (LA117_152 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_152 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_152 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_152 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_152 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (LA117_152 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	    else if ( (LA117_152 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_152 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_152 == EOF || ((LA117_152 >= CRLF) && (LA117_152 <= SLASH)) || LA117_152 == COLON || ((LA117_152 >= SEMI) && (LA117_152 <= QMARK)) || ((LA117_152 >= LSBRAQUET) && (LA117_152 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_152);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 12:
        
    	{
    	    ANTLR3_UINT32 LA117_42;

    	    ANTLR3_MARKER index117_42;


    		LA117_42 = LA(1);

    	 
    	    index117_42 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_42 >= CRLF) && (LA117_42 <= SP)) || LA117_42 == BQUOTE || LA117_42 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_42 >= HEX_CHAR) && (LA117_42 <= COMMON_CHAR))) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA117_42 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA117_42 == DOT || LA117_42 == DASH || ((LA117_42 >= STAR) && (LA117_42 <= RPAREN)) || ((LA117_42 >= USCORE) && (LA117_42 <= SQUOTE))) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA117_42 == PERCENT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA117_42 == PLUS) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA117_42 == COLON) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA117_42 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_42 == SLASH || ((LA117_42 >= AND) && (LA117_42 <= EQUAL)) || ((LA117_42 >= DOLLARD) && (LA117_42 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_42);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 13:
        
    	{
    	    ANTLR3_UINT32 LA117_103;

    	    ANTLR3_MARKER index117_103;


    		LA117_103 = LA(1);

    	 
    	    index117_103 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_103);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 14:
        
    	{
    	    ANTLR3_UINT32 LA117_102;

    	    ANTLR3_MARKER index117_102;


    		LA117_102 = LA(1);

    	 
    	    index117_102 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_102);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 15:
        
    	{
    	    ANTLR3_UINT32 LA117_9;

    	    ANTLR3_MARKER index117_9;


    		LA117_9 = LA(1);

    	 
    	    index117_9 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_9 == DOT) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA117_9 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA117_9 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA117_9 == EOF || ((LA117_9 >= CRLF) && (LA117_9 <= SP))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_9 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_9 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_9 == DASH) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (((LA117_9 >= HEX_CHAR) && (LA117_9 <= COMMON_CHAR))) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA117_9 == DIGIT) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA117_9 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_9 >= STAR) && (LA117_9 <= RPAREN)) || ((LA117_9 >= USCORE) && (LA117_9 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_9 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_9 == SLASH || ((LA117_9 >= AND) && (LA117_9 <= DOLLARD))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_9);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 16:
        
    	{
    	    ANTLR3_UINT32 LA117_105;

    	    ANTLR3_MARKER index117_105;


    		LA117_105 = LA(1);

    	 
    	    index117_105 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_105);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 17:
        
    	{
    	    ANTLR3_UINT32 LA117_104;

    	    ANTLR3_MARKER index117_104;


    		LA117_104 = LA(1);

    	 
    	    index117_104 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_104);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 18:
        
    	{
    	    ANTLR3_UINT32 LA117_92;

    	    ANTLR3_MARKER index117_92;


    		LA117_92 = LA(1);

    	 
    	    index117_92 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_92 == EOF || ((LA117_92 >= CRLF) && (LA117_92 <= SP)) || LA117_92 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_92 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_92 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_92 >= HEX_CHAR) && (LA117_92 <= COMMON_CHAR))) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA117_92 == DIGIT) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA117_92 == DOT || LA117_92 == DASH || ((LA117_92 >= STAR) && (LA117_92 <= RPAREN)) || ((LA117_92 >= USCORE) && (LA117_92 <= SQUOTE))) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA117_92 == PERCENT) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA117_92 == PLUS) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA117_92 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_92 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_92 == SLASH || ((LA117_92 >= AND) && (LA117_92 <= EQUAL)) || LA117_92 == DOLLARD || LA117_92 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_92);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 19:
        
    	{
    	    ANTLR3_UINT32 LA117_21;

    	    ANTLR3_MARKER index117_21;


    		LA117_21 = LA(1);

    	 
    	    index117_21 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_21 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA117_21 >= HEX_CHAR) && (LA117_21 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_21 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_21 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_21 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_21 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_21 >= STAR) && (LA117_21 <= RPAREN)) || ((LA117_21 >= USCORE) && (LA117_21 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_21 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_21 == SLASH || ((LA117_21 >= AND) && (LA117_21 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_21);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 20:
        
    	{
    	    ANTLR3_UINT32 LA117_74;

    	    ANTLR3_MARKER index117_74;


    		LA117_74 = LA(1);

    	 
    	    index117_74 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_74 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_74 == EOF || ((LA117_74 >= CRLF) && (LA117_74 <= SLASH)) || LA117_74 == COLON || ((LA117_74 >= SEMI) && (LA117_74 <= QMARK)) || ((LA117_74 >= LSBRAQUET) && (LA117_74 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_74 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_74 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (((LA117_74 >= HEX_CHAR) && (LA117_74 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_74 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_74 == DOT || LA117_74 == DASH || ((LA117_74 >= STAR) && (LA117_74 <= RPAREN)) || ((LA117_74 >= USCORE) && (LA117_74 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_74 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_74 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_74 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_74 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	 
    		SEEK(index117_74);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 21:
        
    	{
    	    ANTLR3_UINT32 LA117_107;

    	    ANTLR3_MARKER index117_107;


    		LA117_107 = LA(1);

    	 
    	    index117_107 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_107 >= CRLF) && (LA117_107 <= SP)) || LA117_107 == BQUOTE || LA117_107 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_107 >= HEX_CHAR) && (LA117_107 <= COMMON_CHAR))) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA117_107 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA117_107 == DOT || LA117_107 == DASH || ((LA117_107 >= STAR) && (LA117_107 <= RPAREN)) || ((LA117_107 >= USCORE) && (LA117_107 <= SQUOTE))) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA117_107 == PERCENT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA117_107 == PLUS) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA117_107 == COLON) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA117_107 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_107 == SLASH || ((LA117_107 >= AND) && (LA117_107 <= EQUAL)) || ((LA117_107 >= DOLLARD) && (LA117_107 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_107);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 22:
        
    	{
    	    ANTLR3_UINT32 LA117_155;

    	    ANTLR3_MARKER index117_155;


    		LA117_155 = LA(1);

    	 
    	    index117_155 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_155 == EOF || ((LA117_155 >= CRLF) && (LA117_155 <= SP)) || ((LA117_155 >= LSBRAQUET) && (LA117_155 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_155 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_155 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_155 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_155 == COLON) )
    	    {
    	        s = 152;
    	    }

    	    else if ( (((LA117_155 >= HEX_CHAR) && (LA117_155 <= COMMON_CHAR))) )
    	    {
    	        s = 153;
    	    }

    	    else if ( (LA117_155 == DIGIT) )
    	    {
    	        s = 154;
    	    }

    	    else if ( (LA117_155 == DOT || LA117_155 == DASH || ((LA117_155 >= STAR) && (LA117_155 <= RPAREN)) || ((LA117_155 >= USCORE) && (LA117_155 <= SQUOTE))) )
    	    {
    	        s = 155;
    	    }

    	    else if ( (LA117_155 == PERCENT) )
    	    {
    	        s = 156;
    	    }

    	    else if ( (LA117_155 == SLASH || ((LA117_155 >= PLUS) && (LA117_155 <= DOLLARD)) || LA117_155 == QMARK) )
    	    {
    	        s = 157;
    	    }

    	    else if ( (LA117_155 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_155 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_155);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 23:
        
    	{
    	    ANTLR3_UINT32 LA117_159;

    	    ANTLR3_MARKER index117_159;


    		LA117_159 = LA(1);

    	 
    	    index117_159 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_159 == DIGIT) )
    	    {
    	        s = 162;
    	    }

    	    else if ( (LA117_159 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA117_159 >= HEX_CHAR) && (LA117_159 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_159 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_159 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA117_159 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_159 >= STAR) && (LA117_159 <= RPAREN)) || ((LA117_159 >= USCORE) && (LA117_159 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_159 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_159 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA117_159 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_159 == EOF || ((LA117_159 >= CRLF) && (LA117_159 <= SP))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_159 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_159 == SLASH || ((LA117_159 >= AND) && (LA117_159 <= DOLLARD))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_159);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 24:
        
    	{
    	    ANTLR3_UINT32 LA117_96;

    	    ANTLR3_MARKER index117_96;


    		LA117_96 = LA(1);

    	 
    	    index117_96 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_96 == EOF || ((LA117_96 >= CRLF) && (LA117_96 <= SP)) || LA117_96 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_96 == EQUAL) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA117_96 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_96 >= HEX_CHAR) && (LA117_96 <= COMMON_CHAR))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA117_96 == DIGIT) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA117_96 == DOT || LA117_96 == DASH || ((LA117_96 >= STAR) && (LA117_96 <= RPAREN)) || ((LA117_96 >= USCORE) && (LA117_96 <= SQUOTE))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA117_96 == PERCENT) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA117_96 == PLUS) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA117_96 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_96 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_96 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_96 == SLASH || LA117_96 == AND || LA117_96 == DOLLARD || LA117_96 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_96);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 25:
        
    	{
    	    ANTLR3_UINT32 LA117_98;

    	    ANTLR3_MARKER index117_98;


    		LA117_98 = LA(1);

    	 
    	    index117_98 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_98);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 26:
        
    	{
    	    ANTLR3_UINT32 LA117_71;

    	    ANTLR3_MARKER index117_71;


    		LA117_71 = LA(1);

    	 
    	    index117_71 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_71 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_71 >= HEX_CHAR) && (LA117_71 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA117_71 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA117_71 == DOT || LA117_71 == DASH || ((LA117_71 >= STAR) && (LA117_71 <= RPAREN)) || ((LA117_71 >= USCORE) && (LA117_71 <= SQUOTE))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA117_71 == PERCENT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA117_71 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_71 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_71 == PLUS) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA117_71 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_71 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (((LA117_71 >= CRLF) && (LA117_71 <= SP)) || LA117_71 == COLON || LA117_71 == BQUOTE || LA117_71 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_71);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 27:
        
    	{
    	    ANTLR3_UINT32 LA117_56;

    	    ANTLR3_MARKER index117_56;


    		LA117_56 = LA(1);

    	 
    	    index117_56 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_56 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_56 >= HEX_CHAR) && (LA117_56 <= COMMON_CHAR))) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA117_56 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA117_56 == DOT || LA117_56 == DASH || ((LA117_56 >= STAR) && (LA117_56 <= RPAREN)) || ((LA117_56 >= USCORE) && (LA117_56 <= SQUOTE))) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA117_56 == PERCENT) )
    	    {
    	        s = 57;
    	    }

    	    else if ( (LA117_56 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_56 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA117_56 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA117_56 == DOLLARD) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA117_56 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_56 == SLASH || LA117_56 == COLON || LA117_56 == QMARK || ((LA117_56 >= LSBRAQUET) && (LA117_56 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_56);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 28:
        
    	{
    	    ANTLR3_UINT32 LA117_116;

    	    ANTLR3_MARKER index117_116;


    		LA117_116 = LA(1);

    	 
    	    index117_116 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_116 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_116 >= HEX_CHAR) && (LA117_116 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_116 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_116 == DOT || LA117_116 == DASH || ((LA117_116 >= STAR) && (LA117_116 <= RPAREN)) || ((LA117_116 >= USCORE) && (LA117_116 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_116 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_116 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_116 == EQUAL) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA117_116 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (LA117_116 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_116 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_116 == SLASH || LA117_116 == COLON || LA117_116 == QMARK || ((LA117_116 >= LSBRAQUET) && (LA117_116 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_116);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 29:
        
    	{
    	    ANTLR3_UINT32 LA117_31;

    	    ANTLR3_MARKER index117_31;


    		LA117_31 = LA(1);

    	 
    	    index117_31 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_31 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA117_31 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (((LA117_31 >= HEX_CHAR) && (LA117_31 <= COMMON_CHAR))) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA117_31 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA117_31 == DOT || LA117_31 == DASH || ((LA117_31 >= STAR) && (LA117_31 <= RPAREN)) || ((LA117_31 >= USCORE) && (LA117_31 <= SQUOTE))) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA117_31 == PERCENT) )
    	    {
    	        s = 57;
    	    }

    	    else if ( (LA117_31 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_31 == DOLLARD) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA117_31 == SLASH || LA117_31 == COLON || LA117_31 == QMARK || ((LA117_31 >= LSBRAQUET) && (LA117_31 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_31 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_31 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	 
    		SEEK(index117_31);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 30:
        
    	{
    	    ANTLR3_UINT32 LA117_121;

    	    ANTLR3_MARKER index117_121;


    		LA117_121 = LA(1);

    	 
    	    index117_121 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_121 == EQUAL) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA117_121 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA117_121 >= HEX_CHAR) && (LA117_121 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_121 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_121 == DOT || LA117_121 == DASH || ((LA117_121 >= STAR) && (LA117_121 <= RPAREN)) || ((LA117_121 >= USCORE) && (LA117_121 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_121 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_121 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_121 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_121 == SLASH || LA117_121 == COLON || LA117_121 == QMARK || ((LA117_121 >= LSBRAQUET) && (LA117_121 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_121 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_121 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	 
    		SEEK(index117_121);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 31:
        
    	{
    	    ANTLR3_UINT32 LA117_144;

    	    ANTLR3_MARKER index117_144;


    		LA117_144 = LA(1);

    	 
    	    index117_144 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_144 == DIGIT) )
    	    {
    	        s = 159;
    	    }

    	    else if ( (LA117_144 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (LA117_144 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA117_144 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA117_144 == EOF || ((LA117_144 >= CRLF) && (LA117_144 <= SP))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_144 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_144 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (((LA117_144 >= HEX_CHAR) && (LA117_144 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_144 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_144 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_144 >= STAR) && (LA117_144 <= RPAREN)) || ((LA117_144 >= USCORE) && (LA117_144 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_144 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_144 == SLASH || ((LA117_144 >= AND) && (LA117_144 <= DOLLARD))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_144);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 32:
        
    	{
    	    ANTLR3_UINT32 LA117_88;

    	    ANTLR3_MARKER index117_88;


    		LA117_88 = LA(1);

    	 
    	    index117_88 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_88 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_88 == EOF || ((LA117_88 >= CRLF) && (LA117_88 <= SP)) || ((LA117_88 >= LSBRAQUET) && (LA117_88 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_88 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_88 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_88 == COLON) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (((LA117_88 >= HEX_CHAR) && (LA117_88 <= COMMON_CHAR))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA117_88 == DIGIT) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA117_88 == DOT || LA117_88 == DASH || ((LA117_88 >= STAR) && (LA117_88 <= RPAREN)) || ((LA117_88 >= USCORE) && (LA117_88 <= SQUOTE))) )
    	    {
    	        s = 85;
    	    }

    	    else if ( (LA117_88 == PERCENT) )
    	    {
    	        s = 86;
    	    }

    	    else if ( (LA117_88 == SLASH || ((LA117_88 >= PLUS) && (LA117_88 <= DOLLARD)) || LA117_88 == QMARK) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA117_88 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_88 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_88);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 33:
        
    	{
    	    ANTLR3_UINT32 LA117_140;

    	    ANTLR3_MARKER index117_140;


    		LA117_140 = LA(1);

    	 
    	    index117_140 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_140 == EOF || ((LA117_140 >= CRLF) && (LA117_140 <= SP)) || LA117_140 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_140 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_140 >= HEX_CHAR) && (LA117_140 <= COMMON_CHAR))) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA117_140 == DIGIT) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA117_140 == DOT || LA117_140 == DASH || ((LA117_140 >= STAR) && (LA117_140 <= RPAREN)) || ((LA117_140 >= USCORE) && (LA117_140 <= SQUOTE))) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA117_140 == PERCENT) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA117_140 == PLUS) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA117_140 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_140 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_140 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_140 == SLASH || ((LA117_140 >= AND) && (LA117_140 <= EQUAL)) || LA117_140 == DOLLARD || LA117_140 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_140);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 34:
        
    	{
    	    ANTLR3_UINT32 LA117_15;

    	    ANTLR3_MARKER index117_15;


    		LA117_15 = LA(1);

    	 
    	    index117_15 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_15 >= CRLF) && (LA117_15 <= SP)) || LA117_15 == DQUOTE || LA117_15 == BQUOTE || LA117_15 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_15 >= HEX_CHAR) && (LA117_15 <= COMMON_CHAR))) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA117_15 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA117_15 == DOT || LA117_15 == DASH || ((LA117_15 >= STAR) && (LA117_15 <= RPAREN)) || ((LA117_15 >= USCORE) && (LA117_15 <= SQUOTE))) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA117_15 == PERCENT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA117_15 == PLUS) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA117_15 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_15 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_15 == SLASH || ((LA117_15 >= AND) && (LA117_15 <= EQUAL)) || ((LA117_15 >= DOLLARD) && (LA117_15 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_15);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 35:
        
    	{
    	    ANTLR3_UINT32 LA117_83;

    	    ANTLR3_MARKER index117_83;


    		LA117_83 = LA(1);

    	 
    	    index117_83 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_83 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_83 == EOF || ((LA117_83 >= CRLF) && (LA117_83 <= SP)) || ((LA117_83 >= LSBRAQUET) && (LA117_83 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_83 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_83 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_83 == COLON) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (((LA117_83 >= HEX_CHAR) && (LA117_83 <= COMMON_CHAR))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA117_83 == DIGIT) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA117_83 == DOT || LA117_83 == DASH || ((LA117_83 >= STAR) && (LA117_83 <= RPAREN)) || ((LA117_83 >= USCORE) && (LA117_83 <= SQUOTE))) )
    	    {
    	        s = 85;
    	    }

    	    else if ( (LA117_83 == PERCENT) )
    	    {
    	        s = 86;
    	    }

    	    else if ( (LA117_83 == SLASH || ((LA117_83 >= PLUS) && (LA117_83 <= DOLLARD)) || LA117_83 == QMARK) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA117_83 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_83 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_83);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 36:
        
    	{
    	    ANTLR3_UINT32 LA117_91;

    	    ANTLR3_MARKER index117_91;


    		LA117_91 = LA(1);

    	 
    	    index117_91 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_91 == EOF || ((LA117_91 >= CRLF) && (LA117_91 <= SP)) || LA117_91 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_91 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_91 >= HEX_CHAR) && (LA117_91 <= COMMON_CHAR))) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA117_91 == DIGIT) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA117_91 == DOT || LA117_91 == DASH || ((LA117_91 >= STAR) && (LA117_91 <= RPAREN)) || ((LA117_91 >= USCORE) && (LA117_91 <= SQUOTE))) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA117_91 == PERCENT) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA117_91 == PLUS) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA117_91 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_91 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_91 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_91 == SLASH || ((LA117_91 >= AND) && (LA117_91 <= EQUAL)) || LA117_91 == DOLLARD || LA117_91 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_91);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 37:
        
    	{
    	    ANTLR3_UINT32 LA117_97;

    	    ANTLR3_MARKER index117_97;


    		LA117_97 = LA(1);

    	 
    	    index117_97 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_97);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 38:
        
    	{
    	    ANTLR3_UINT32 LA117_99;

    	    ANTLR3_MARKER index117_99;


    		LA117_99 = LA(1);

    	 
    	    index117_99 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (synpred9_belle_sip_message(ctx)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_99);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 39:
        
    	{
    	    ANTLR3_UINT32 LA117_17;

    	    ANTLR3_MARKER index117_17;


    		LA117_17 = LA(1);

    	 
    	    index117_17 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_17 >= HEX_CHAR) && (LA117_17 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA117_17 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA117_17 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_17 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_17 == DOT || LA117_17 == DASH || ((LA117_17 >= STAR) && (LA117_17 <= RPAREN)) || ((LA117_17 >= USCORE) && (LA117_17 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_17 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_17 == SLASH || ((LA117_17 >= AND) && (LA117_17 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_17);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 40:
        
    	{
    	    ANTLR3_UINT32 LA117_44;

    	    ANTLR3_MARKER index117_44;


    		LA117_44 = LA(1);

    	 
    	    index117_44 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_44 >= CRLF) && (LA117_44 <= SP)) || LA117_44 == BQUOTE || LA117_44 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_44 >= HEX_CHAR) && (LA117_44 <= COMMON_CHAR))) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA117_44 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA117_44 == DOT || LA117_44 == DASH || ((LA117_44 >= STAR) && (LA117_44 <= RPAREN)) || ((LA117_44 >= USCORE) && (LA117_44 <= SQUOTE))) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA117_44 == PERCENT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA117_44 == PLUS) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA117_44 == COLON) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA117_44 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_44 == SLASH || ((LA117_44 >= AND) && (LA117_44 <= EQUAL)) || ((LA117_44 >= DOLLARD) && (LA117_44 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_44);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 41:
        
    	{
    	    ANTLR3_UINT32 LA117_68;

    	    ANTLR3_MARKER index117_68;


    		LA117_68 = LA(1);

    	 
    	    index117_68 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_68 >= HEX_CHAR) && (LA117_68 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA117_68 == DIGIT) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA117_68 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_68 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_68 == DOT || LA117_68 == DASH || ((LA117_68 >= STAR) && (LA117_68 <= RPAREN)) || ((LA117_68 >= USCORE) && (LA117_68 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_68 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_68 == SLASH || ((LA117_68 >= AND) && (LA117_68 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_68);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 42:
        
    	{
    	    ANTLR3_UINT32 LA117_34;

    	    ANTLR3_MARKER index117_34;


    		LA117_34 = LA(1);

    	 
    	    index117_34 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_34 == EQUAL) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA117_34 == COLON) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (((LA117_34 >= HEX_CHAR) && (LA117_34 <= COMMON_CHAR))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA117_34 == DIGIT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA117_34 == DOT || LA117_34 == DASH || ((LA117_34 >= STAR) && (LA117_34 <= RPAREN)) || ((LA117_34 >= USCORE) && (LA117_34 <= SQUOTE))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA117_34 == PERCENT) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA117_34 == SLASH || ((LA117_34 >= PLUS) && (LA117_34 <= DOLLARD)) || LA117_34 == QMARK) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA117_34 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_34 >= LSBRAQUET) && (LA117_34 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_34 == AND || ((LA117_34 >= COMMA) && (LA117_34 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_34);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 43:
        
    	{
    	    ANTLR3_UINT32 LA117_124;

    	    ANTLR3_MARKER index117_124;


    		LA117_124 = LA(1);

    	 
    	    index117_124 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_124 == EQUAL) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA117_124 == COLON) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (((LA117_124 >= HEX_CHAR) && (LA117_124 <= COMMON_CHAR))) )
    	    {
    	        s = 122;
    	    }

    	    else if ( (LA117_124 == DIGIT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA117_124 == DOT || LA117_124 == DASH || ((LA117_124 >= STAR) && (LA117_124 <= RPAREN)) || ((LA117_124 >= USCORE) && (LA117_124 <= SQUOTE))) )
    	    {
    	        s = 124;
    	    }

    	    else if ( (LA117_124 == PERCENT) )
    	    {
    	        s = 125;
    	    }

    	    else if ( (LA117_124 == SLASH || ((LA117_124 >= PLUS) && (LA117_124 <= DOLLARD)) || LA117_124 == QMARK) )
    	    {
    	        s = 126;
    	    }

    	    else if ( (LA117_124 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_124 >= LSBRAQUET) && (LA117_124 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_124 == AND || ((LA117_124 >= COMMA) && (LA117_124 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_124);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 44:
        
    	{
    	    ANTLR3_UINT32 LA117_131;

    	    ANTLR3_MARKER index117_131;


    		LA117_131 = LA(1);

    	 
    	    index117_131 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_131 == DIGIT) )
    	    {
    	        s = 144;
    	    }

    	    else if ( (((LA117_131 >= HEX_CHAR) && (LA117_131 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA117_131 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_131 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_131 == DOT || LA117_131 == DASH || ((LA117_131 >= STAR) && (LA117_131 <= RPAREN)) || ((LA117_131 >= USCORE) && (LA117_131 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_131 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_131 == SLASH || ((LA117_131 >= AND) && (LA117_131 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_131);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 45:
        
    	{
    	    ANTLR3_UINT32 LA117_162;

    	    ANTLR3_MARKER index117_162;


    		LA117_162 = LA(1);

    	 
    	    index117_162 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_162 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA117_162 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA117_162 == EOF || ((LA117_162 >= CRLF) && (LA117_162 <= SP))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_162 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_162 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_162 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA117_162 >= HEX_CHAR) && (LA117_162 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_162 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_162 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_162 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_162 >= STAR) && (LA117_162 <= RPAREN)) || ((LA117_162 >= USCORE) && (LA117_162 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_162 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_162 == SLASH || ((LA117_162 >= AND) && (LA117_162 <= DOLLARD))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_162);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 46:
        
    	{
    	    ANTLR3_UINT32 LA117_145;

    	    ANTLR3_MARKER index117_145;


    		LA117_145 = LA(1);

    	 
    	    index117_145 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_145 == EOF || ((LA117_145 >= CRLF) && (LA117_145 <= SLASH)) || LA117_145 == COLON || ((LA117_145 >= SEMI) && (LA117_145 <= QMARK)) || ((LA117_145 >= LSBRAQUET) && (LA117_145 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_145 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_145 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_145 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (((LA117_145 >= HEX_CHAR) && (LA117_145 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_145 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_145 == DOT || LA117_145 == DASH || ((LA117_145 >= STAR) && (LA117_145 <= RPAREN)) || ((LA117_145 >= USCORE) && (LA117_145 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_145 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_145 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_145 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_145 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	 
    		SEEK(index117_145);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 47:
        
    	{
    	    ANTLR3_UINT32 LA117_94;

    	    ANTLR3_MARKER index117_94;


    		LA117_94 = LA(1);

    	 
    	    index117_94 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_94 == EOF || ((LA117_94 >= CRLF) && (LA117_94 <= SP)) || LA117_94 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_94 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_94 >= HEX_CHAR) && (LA117_94 <= COMMON_CHAR))) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA117_94 == DIGIT) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA117_94 == DOT || LA117_94 == DASH || ((LA117_94 >= STAR) && (LA117_94 <= RPAREN)) || ((LA117_94 >= USCORE) && (LA117_94 <= SQUOTE))) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA117_94 == PERCENT) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA117_94 == PLUS) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA117_94 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_94 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_94 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_94 == SLASH || ((LA117_94 >= AND) && (LA117_94 <= EQUAL)) || LA117_94 == DOLLARD || LA117_94 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_94);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 48:
        
    	{
    	    ANTLR3_UINT32 LA117_59;

    	    ANTLR3_MARKER index117_59;


    		LA117_59 = LA(1);

    	 
    	    index117_59 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_59 == COLON) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (((LA117_59 >= HEX_CHAR) && (LA117_59 <= COMMON_CHAR))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA117_59 == DIGIT) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA117_59 == DOT || LA117_59 == DASH || ((LA117_59 >= STAR) && (LA117_59 <= RPAREN)) || ((LA117_59 >= USCORE) && (LA117_59 <= SQUOTE))) )
    	    {
    	        s = 85;
    	    }

    	    else if ( (LA117_59 == PERCENT) )
    	    {
    	        s = 86;
    	    }

    	    else if ( (LA117_59 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_59 == EOF || ((LA117_59 >= CRLF) && (LA117_59 <= SP)) || ((LA117_59 >= LSBRAQUET) && (LA117_59 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_59 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_59 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_59 == SLASH || ((LA117_59 >= PLUS) && (LA117_59 <= DOLLARD)) || LA117_59 == QMARK) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA117_59 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_59 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_59);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 49:
        
    	{
    	    ANTLR3_UINT32 LA117_13;

    	    ANTLR3_MARKER index117_13;


    		LA117_13 = LA(1);

    	 
    	    index117_13 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_13 == COLON) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (((LA117_13 >= HEX_CHAR) && (LA117_13 <= COMMON_CHAR))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA117_13 == DIGIT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA117_13 == DOT || LA117_13 == DASH || ((LA117_13 >= STAR) && (LA117_13 <= RPAREN)) || ((LA117_13 >= USCORE) && (LA117_13 <= SQUOTE))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA117_13 == PERCENT) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA117_13 == SLASH || ((LA117_13 >= PLUS) && (LA117_13 <= DOLLARD)) || LA117_13 == QMARK) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA117_13 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_13 >= LSBRAQUET) && (LA117_13 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_13 >= AND) && (LA117_13 <= EQUAL)) || ((LA117_13 >= COMMA) && (LA117_13 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_13);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 50:
        
    	{
    	    ANTLR3_UINT32 LA117_75;

    	    ANTLR3_MARKER index117_75;


    		LA117_75 = LA(1);

    	 
    	    index117_75 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_75 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_75 >= HEX_CHAR) && (LA117_75 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_75 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_75 == DOT || LA117_75 == DASH || ((LA117_75 >= STAR) && (LA117_75 <= RPAREN)) || ((LA117_75 >= USCORE) && (LA117_75 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_75 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_75 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_75 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_75 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA117_75 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA117_75 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_75 == EOF || ((LA117_75 >= CRLF) && (LA117_75 <= SLASH)) || LA117_75 == COLON || ((LA117_75 >= SEMI) && (LA117_75 <= QMARK)) || ((LA117_75 >= LSBRAQUET) && (LA117_75 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_75);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 51:
        
    	{
    	    ANTLR3_UINT32 LA117_64;

    	    ANTLR3_MARKER index117_64;


    		LA117_64 = LA(1);

    	 
    	    index117_64 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_64 >= HEX_CHAR) && (LA117_64 <= COMMON_CHAR))) )
    	    {
    	        s = 97;
    	    }

    	    else if ( (LA117_64 == DIGIT) )
    	    {
    	        s = 98;
    	    }

    	    else if ( (LA117_64 == DOT || LA117_64 == DASH || ((LA117_64 >= STAR) && (LA117_64 <= RPAREN)) || ((LA117_64 >= USCORE) && (LA117_64 <= SQUOTE))) )
    	    {
    	        s = 99;
    	    }

    	    else if ( (LA117_64 == PERCENT) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA117_64 == AND) )
    	    {
    	        s = 101;
    	    }

    	    else if ( (LA117_64 == EQUAL) )
    	    {
    	        s = 102;
    	    }

    	    else if ( (LA117_64 == PLUS) )
    	    {
    	        s = 103;
    	    }

    	    else if ( (LA117_64 == DOLLARD) )
    	    {
    	        s = 104;
    	    }

    	    else if ( (LA117_64 == COMMA) )
    	    {
    	        s = 105;
    	    }

    	    else if ( (LA117_64 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_64 == SLASH || ((LA117_64 >= SEMI) && (LA117_64 <= QMARK)) || LA117_64 == LSBRAQUET) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_64);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 52:
        
    	{
    	    ANTLR3_UINT32 LA117_87;

    	    ANTLR3_MARKER index117_87;


    		LA117_87 = LA(1);

    	 
    	    index117_87 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_87 == COLON) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (((LA117_87 >= HEX_CHAR) && (LA117_87 <= COMMON_CHAR))) )
    	    {
    	        s = 122;
    	    }

    	    else if ( (LA117_87 == DIGIT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA117_87 == DOT || LA117_87 == DASH || ((LA117_87 >= STAR) && (LA117_87 <= RPAREN)) || ((LA117_87 >= USCORE) && (LA117_87 <= SQUOTE))) )
    	    {
    	        s = 124;
    	    }

    	    else if ( (LA117_87 == PERCENT) )
    	    {
    	        s = 125;
    	    }

    	    else if ( (LA117_87 == SLASH || ((LA117_87 >= PLUS) && (LA117_87 <= DOLLARD)) || LA117_87 == QMARK) )
    	    {
    	        s = 126;
    	    }

    	    else if ( (LA117_87 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_87 >= LSBRAQUET) && (LA117_87 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_87 >= AND) && (LA117_87 <= EQUAL)) || ((LA117_87 >= COMMA) && (LA117_87 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_87);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 53:
        
    	{
    	    ANTLR3_UINT32 LA117_134;

    	    ANTLR3_MARKER index117_134;


    		LA117_134 = LA(1);

    	 
    	    index117_134 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_134 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_134 >= HEX_CHAR) && (LA117_134 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_134 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_134 == DOT || LA117_134 == DASH || ((LA117_134 >= STAR) && (LA117_134 <= RPAREN)) || ((LA117_134 >= USCORE) && (LA117_134 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_134 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_134 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_134 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_134 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA117_134 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA117_134 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_134 == EOF || ((LA117_134 >= CRLF) && (LA117_134 <= SLASH)) || LA117_134 == COLON || ((LA117_134 >= SEMI) && (LA117_134 <= QMARK)) || ((LA117_134 >= LSBRAQUET) && (LA117_134 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_134);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 54:
        
    	{
    	    ANTLR3_UINT32 LA117_51;

    	    ANTLR3_MARKER index117_51;


    		LA117_51 = LA(1);

    	 
    	    index117_51 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_51 >= CRLF) && (LA117_51 <= SP)) || LA117_51 == DQUOTE || LA117_51 == BQUOTE || LA117_51 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_51 >= HEX_CHAR) && (LA117_51 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA117_51 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA117_51 == DOT || LA117_51 == DASH || ((LA117_51 >= STAR) && (LA117_51 <= RPAREN)) || ((LA117_51 >= USCORE) && (LA117_51 <= SQUOTE))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA117_51 == PERCENT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA117_51 == PLUS) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA117_51 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_51 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_51 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_51 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_51 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	 
    		SEEK(index117_51);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 55:
        
    	{
    	    ANTLR3_UINT32 LA117_80;

    	    ANTLR3_MARKER index117_80;


    		LA117_80 = LA(1);

    	 
    	    index117_80 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_80 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_80 >= HEX_CHAR) && (LA117_80 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_80 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_80 == DOT || LA117_80 == DASH || ((LA117_80 >= STAR) && (LA117_80 <= RPAREN)) || ((LA117_80 >= USCORE) && (LA117_80 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_80 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_80 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_80 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_80 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA117_80 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA117_80 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_80 == EOF || ((LA117_80 >= CRLF) && (LA117_80 <= SLASH)) || LA117_80 == COLON || ((LA117_80 >= SEMI) && (LA117_80 <= QMARK)) || ((LA117_80 >= LSBRAQUET) && (LA117_80 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_80);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 56:
        
    	{
    	    ANTLR3_UINT32 LA117_157;

    	    ANTLR3_MARKER index117_157;


    		LA117_157 = LA(1);

    	 
    	    index117_157 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_157 == COLON) )
    	    {
    	        s = 152;
    	    }

    	    else if ( (LA117_157 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_157 >= HEX_CHAR) && (LA117_157 <= COMMON_CHAR))) )
    	    {
    	        s = 153;
    	    }

    	    else if ( (LA117_157 == DIGIT) )
    	    {
    	        s = 154;
    	    }

    	    else if ( (LA117_157 == DOT || LA117_157 == DASH || ((LA117_157 >= STAR) && (LA117_157 <= RPAREN)) || ((LA117_157 >= USCORE) && (LA117_157 <= SQUOTE))) )
    	    {
    	        s = 155;
    	    }

    	    else if ( (LA117_157 == PERCENT) )
    	    {
    	        s = 156;
    	    }

    	    else if ( (LA117_157 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_157 == EOF || ((LA117_157 >= CRLF) && (LA117_157 <= SP)) || ((LA117_157 >= LSBRAQUET) && (LA117_157 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_157 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_157 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_157 == SLASH || ((LA117_157 >= PLUS) && (LA117_157 <= DOLLARD)) || LA117_157 == QMARK) )
    	    {
    	        s = 157;
    	    }

    	    else if ( (LA117_157 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_157);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 57:
        
    	{
    	    ANTLR3_UINT32 LA117_18;

    	    ANTLR3_MARKER index117_18;


    		LA117_18 = LA(1);

    	 
    	    index117_18 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_18 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA117_18 >= HEX_CHAR) && (LA117_18 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_18 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_18 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_18 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_18 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_18 >= STAR) && (LA117_18 <= RPAREN)) || ((LA117_18 >= USCORE) && (LA117_18 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_18 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_18 == SLASH || ((LA117_18 >= AND) && (LA117_18 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_18);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 58:
        
    	{
    	    ANTLR3_UINT32 LA117_79;

    	    ANTLR3_MARKER index117_79;


    		LA117_79 = LA(1);

    	 
    	    index117_79 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_79 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_79 >= HEX_CHAR) && (LA117_79 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_79 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_79 == DOT || LA117_79 == DASH || ((LA117_79 >= STAR) && (LA117_79 <= RPAREN)) || ((LA117_79 >= USCORE) && (LA117_79 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_79 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_79 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_79 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_79 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA117_79 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA117_79 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_79 == EOF || ((LA117_79 >= CRLF) && (LA117_79 <= SLASH)) || LA117_79 == COLON || ((LA117_79 >= SEMI) && (LA117_79 <= QMARK)) || ((LA117_79 >= LSBRAQUET) && (LA117_79 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_79);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 59:
        
    	{
    	    ANTLR3_UINT32 LA117_23;

    	    ANTLR3_MARKER index117_23;


    		LA117_23 = LA(1);

    	 
    	    index117_23 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_23 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_23 >= HEX_CHAR) && (LA117_23 <= COMMON_CHAR))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 22;
    	    }

    	    else if ( (LA117_23 == DIGIT) )
    	    {
    	        s = 23;
    	    }

    	    else if ( (LA117_23 == DOT || LA117_23 == DASH || ((LA117_23 >= STAR) && (LA117_23 <= RPAREN)) || ((LA117_23 >= USCORE) && (LA117_23 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA117_23 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA117_23 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_23 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_23 == PLUS) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA117_23 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_23 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_23 == EOF || ((LA117_23 >= CRLF) && (LA117_23 <= SP)) || ((LA117_23 >= SEMI) && (LA117_23 <= QMARK))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_23);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 60:
        
    	{
    	    ANTLR3_UINT32 LA117_70;

    	    ANTLR3_MARKER index117_70;


    		LA117_70 = LA(1);

    	 
    	    index117_70 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_70 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_70 >= HEX_CHAR) && (LA117_70 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA117_70 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA117_70 == DOT || LA117_70 == DASH || ((LA117_70 >= STAR) && (LA117_70 <= RPAREN)) || ((LA117_70 >= USCORE) && (LA117_70 <= SQUOTE))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA117_70 == PERCENT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA117_70 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_70 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_70 == PLUS) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA117_70 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_70 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (((LA117_70 >= CRLF) && (LA117_70 <= SP)) || LA117_70 == COLON || LA117_70 == BQUOTE || LA117_70 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_70);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 61:
        
    	{
    	    ANTLR3_UINT32 LA117_153;

    	    ANTLR3_MARKER index117_153;


    		LA117_153 = LA(1);

    	 
    	    index117_153 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_153 == EOF || ((LA117_153 >= CRLF) && (LA117_153 <= SP)) || ((LA117_153 >= LSBRAQUET) && (LA117_153 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_153 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_153 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_153 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_153 == COLON) )
    	    {
    	        s = 152;
    	    }

    	    else if ( (((LA117_153 >= HEX_CHAR) && (LA117_153 <= COMMON_CHAR))) )
    	    {
    	        s = 153;
    	    }

    	    else if ( (LA117_153 == DIGIT) )
    	    {
    	        s = 154;
    	    }

    	    else if ( (LA117_153 == DOT || LA117_153 == DASH || ((LA117_153 >= STAR) && (LA117_153 <= RPAREN)) || ((LA117_153 >= USCORE) && (LA117_153 <= SQUOTE))) )
    	    {
    	        s = 155;
    	    }

    	    else if ( (LA117_153 == PERCENT) )
    	    {
    	        s = 156;
    	    }

    	    else if ( (LA117_153 == SLASH || ((LA117_153 >= PLUS) && (LA117_153 <= DOLLARD)) || LA117_153 == QMARK) )
    	    {
    	        s = 157;
    	    }

    	    else if ( (LA117_153 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_153 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_153);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 62:
        
    	{
    	    ANTLR3_UINT32 LA117_8;

    	    ANTLR3_MARKER index117_8;


    		LA117_8 = LA(1);

    	 
    	    index117_8 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_8 == DOT) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (((LA117_8 >= HEX_CHAR) && (LA117_8 <= COMMON_CHAR))) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA117_8 == DIGIT) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA117_8 == DASH) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA117_8 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA117_8 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_8 >= STAR) && (LA117_8 <= RPAREN)) || ((LA117_8 >= USCORE) && (LA117_8 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_8 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_8 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA117_8 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_8 == EOF || ((LA117_8 >= CRLF) && (LA117_8 <= SP))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_8 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_8 == SLASH || ((LA117_8 >= AND) && (LA117_8 <= DOLLARD))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_8);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 63:
        
    	{
    	    ANTLR3_UINT32 LA117_1;

    	    ANTLR3_MARKER index117_1;


    		LA117_1 = LA(1);

    	 
    	    index117_1 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_1 == DOT) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (((LA117_1 >= HEX_CHAR) && (LA117_1 <= COMMON_CHAR))) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA117_1 == DIGIT) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA117_1 == DASH) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA117_1 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA117_1 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_1 >= STAR) && (LA117_1 <= RPAREN)) || ((LA117_1 >= USCORE) && (LA117_1 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_1 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_1 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA117_1 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_1 == EOF || ((LA117_1 >= CRLF) && (LA117_1 <= SP))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_1 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_1 == SLASH || ((LA117_1 >= AND) && (LA117_1 <= DOLLARD))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_1);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 64:
        
    	{
    	    ANTLR3_UINT32 LA117_61;

    	    ANTLR3_MARKER index117_61;


    		LA117_61 = LA(1);

    	 
    	    index117_61 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_61 >= CRLF) && (LA117_61 <= SP)) || LA117_61 == DQUOTE || LA117_61 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_61 >= HEX_CHAR) && (LA117_61 <= COMMON_CHAR))) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA117_61 == DIGIT) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA117_61 == DOT || LA117_61 == DASH || ((LA117_61 >= STAR) && (LA117_61 <= RPAREN)) || ((LA117_61 >= USCORE) && (LA117_61 <= SQUOTE))) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA117_61 == PERCENT) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA117_61 == PLUS) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA117_61 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_61 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_61 == SLASH || ((LA117_61 >= AND) && (LA117_61 <= EQUAL)) || ((LA117_61 >= DOLLARD) && (LA117_61 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_61);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 65:
        
    	{
    	    ANTLR3_UINT32 LA117_84;

    	    ANTLR3_MARKER index117_84;


    		LA117_84 = LA(1);

    	 
    	    index117_84 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_84 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_84 == EOF || ((LA117_84 >= CRLF) && (LA117_84 <= SP)) || ((LA117_84 >= LSBRAQUET) && (LA117_84 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_84 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_84 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_84 == COLON) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (((LA117_84 >= HEX_CHAR) && (LA117_84 <= COMMON_CHAR))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA117_84 == DIGIT) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA117_84 == DOT || LA117_84 == DASH || ((LA117_84 >= STAR) && (LA117_84 <= RPAREN)) || ((LA117_84 >= USCORE) && (LA117_84 <= SQUOTE))) )
    	    {
    	        s = 85;
    	    }

    	    else if ( (LA117_84 == PERCENT) )
    	    {
    	        s = 86;
    	    }

    	    else if ( (LA117_84 == SLASH || ((LA117_84 >= PLUS) && (LA117_84 <= DOLLARD)) || LA117_84 == QMARK) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA117_84 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_84 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_84);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 66:
        
    	{
    	    ANTLR3_UINT32 LA117_7;

    	    ANTLR3_MARKER index117_7;


    		LA117_7 = LA(1);

    	 
    	    index117_7 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_7 >= HEX_CHAR) && (LA117_7 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA117_7 == DIGIT) )
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA117_7 == COLON) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA117_7 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_7 == DOT || LA117_7 == DASH || ((LA117_7 >= STAR) && (LA117_7 <= RPAREN)) || ((LA117_7 >= USCORE) && (LA117_7 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_7 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_7 == QMARK) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA117_7 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_7 == EOF || ((LA117_7 >= CRLF) && (LA117_7 <= SP))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_7 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_7 == SLASH || ((LA117_7 >= AND) && (LA117_7 <= DOLLARD))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_7);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 67:
        
    	{
    	    ANTLR3_UINT32 LA117_137;

    	    ANTLR3_MARKER index117_137;


    		LA117_137 = LA(1);

    	 
    	    index117_137 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_137 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_137 == EOF || ((LA117_137 >= CRLF) && (LA117_137 <= SP)) || ((LA117_137 >= LSBRAQUET) && (LA117_137 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_137 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_137 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_137 == COLON) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (((LA117_137 >= HEX_CHAR) && (LA117_137 <= COMMON_CHAR))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA117_137 == DIGIT) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA117_137 == DOT || LA117_137 == DASH || ((LA117_137 >= STAR) && (LA117_137 <= RPAREN)) || ((LA117_137 >= USCORE) && (LA117_137 <= SQUOTE))) )
    	    {
    	        s = 85;
    	    }

    	    else if ( (LA117_137 == PERCENT) )
    	    {
    	        s = 86;
    	    }

    	    else if ( (LA117_137 == SLASH || ((LA117_137 >= PLUS) && (LA117_137 <= DOLLARD)) || LA117_137 == QMARK) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA117_137 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_137 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_137);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 68:
        
    	{
    	    ANTLR3_UINT32 LA117_39;

    	    ANTLR3_MARKER index117_39;


    		LA117_39 = LA(1);

    	 
    	    index117_39 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_39 == EOF || ((LA117_39 >= CRLF) && (LA117_39 <= SP)) || LA117_39 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_39 == EQUAL) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA117_39 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_39 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_39 >= HEX_CHAR) && (LA117_39 <= COMMON_CHAR))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA117_39 == DIGIT) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA117_39 == DOT || LA117_39 == DASH || ((LA117_39 >= STAR) && (LA117_39 <= RPAREN)) || ((LA117_39 >= USCORE) && (LA117_39 <= SQUOTE))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA117_39 == PERCENT) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA117_39 == PLUS) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA117_39 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_39 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_39 == SLASH || LA117_39 == AND || LA117_39 == DOLLARD || LA117_39 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_39);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 69:
        
    	{
    	    ANTLR3_UINT32 LA117_54;

    	    ANTLR3_MARKER index117_54;


    		LA117_54 = LA(1);

    	 
    	    index117_54 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_54 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA117_54 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (((LA117_54 >= HEX_CHAR) && (LA117_54 <= COMMON_CHAR))) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA117_54 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA117_54 == DOT || LA117_54 == DASH || ((LA117_54 >= STAR) && (LA117_54 <= RPAREN)) || ((LA117_54 >= USCORE) && (LA117_54 <= SQUOTE))) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA117_54 == PERCENT) )
    	    {
    	        s = 57;
    	    }

    	    else if ( (LA117_54 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_54 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_54 == DOLLARD) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA117_54 == SLASH || LA117_54 == COLON || LA117_54 == QMARK || ((LA117_54 >= LSBRAQUET) && (LA117_54 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_54 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	 
    		SEEK(index117_54);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 70:
        
    	{
    	    ANTLR3_UINT32 LA117_114;

    	    ANTLR3_MARKER index117_114;


    		LA117_114 = LA(1);

    	 
    	    index117_114 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_114 == EQUAL) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA117_114 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA117_114 >= HEX_CHAR) && (LA117_114 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_114 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_114 == DOT || LA117_114 == DASH || ((LA117_114 >= STAR) && (LA117_114 <= RPAREN)) || ((LA117_114 >= USCORE) && (LA117_114 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_114 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_114 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_114 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_114 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_114 == SLASH || LA117_114 == COLON || LA117_114 == QMARK || ((LA117_114 >= LSBRAQUET) && (LA117_114 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_114 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	 
    		SEEK(index117_114);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 71:
        
    	{
    	    ANTLR3_UINT32 LA117_90;

    	    ANTLR3_MARKER index117_90;


    		LA117_90 = LA(1);

    	 
    	    index117_90 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_90 == EOF || ((LA117_90 >= CRLF) && (LA117_90 <= SP)) || LA117_90 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_90 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_90 >= HEX_CHAR) && (LA117_90 <= COMMON_CHAR))) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA117_90 == DIGIT) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA117_90 == DOT || LA117_90 == DASH || ((LA117_90 >= STAR) && (LA117_90 <= RPAREN)) || ((LA117_90 >= USCORE) && (LA117_90 <= SQUOTE))) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA117_90 == PERCENT) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA117_90 == PLUS) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA117_90 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_90 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_90 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_90 == SLASH || ((LA117_90 >= AND) && (LA117_90 <= EQUAL)) || LA117_90 == DOLLARD || LA117_90 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_90);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 72:
        
    	{
    	    ANTLR3_UINT32 LA117_38;

    	    ANTLR3_MARKER index117_38;


    		LA117_38 = LA(1);

    	 
    	    index117_38 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_38 == EOF || ((LA117_38 >= CRLF) && (LA117_38 <= SP)) || LA117_38 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_38 == EQUAL) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA117_38 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_38 >= HEX_CHAR) && (LA117_38 <= COMMON_CHAR))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA117_38 == DIGIT) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA117_38 == DOT || LA117_38 == DASH || ((LA117_38 >= STAR) && (LA117_38 <= RPAREN)) || ((LA117_38 >= USCORE) && (LA117_38 <= SQUOTE))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA117_38 == PERCENT) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA117_38 == PLUS) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA117_38 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_38 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_38 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_38 == SLASH || LA117_38 == AND || LA117_38 == DOLLARD || LA117_38 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_38);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 73:
        
    	{
    	    ANTLR3_UINT32 LA117_43;

    	    ANTLR3_MARKER index117_43;


    		LA117_43 = LA(1);

    	 
    	    index117_43 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_43 >= CRLF) && (LA117_43 <= SP)) || LA117_43 == BQUOTE || LA117_43 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_43 >= HEX_CHAR) && (LA117_43 <= COMMON_CHAR))) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA117_43 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA117_43 == DOT || LA117_43 == DASH || ((LA117_43 >= STAR) && (LA117_43 <= RPAREN)) || ((LA117_43 >= USCORE) && (LA117_43 <= SQUOTE))) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA117_43 == PERCENT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA117_43 == PLUS) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA117_43 == COLON) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA117_43 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_43 == SLASH || ((LA117_43 >= AND) && (LA117_43 <= EQUAL)) || ((LA117_43 >= DOLLARD) && (LA117_43 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_43);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 74:
        
    	{
    	    ANTLR3_UINT32 LA117_95;

    	    ANTLR3_MARKER index117_95;


    		LA117_95 = LA(1);

    	 
    	    index117_95 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_95 == EOF || ((LA117_95 >= CRLF) && (LA117_95 <= SP)) || LA117_95 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_95 == EQUAL) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA117_95 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_95 >= HEX_CHAR) && (LA117_95 <= COMMON_CHAR))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA117_95 == DIGIT) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA117_95 == DOT || LA117_95 == DASH || ((LA117_95 >= STAR) && (LA117_95 <= RPAREN)) || ((LA117_95 >= USCORE) && (LA117_95 <= SQUOTE))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA117_95 == PERCENT) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA117_95 == PLUS) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA117_95 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_95 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_95 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_95 == SLASH || LA117_95 == AND || LA117_95 == DOLLARD || LA117_95 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_95);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 75:
        
    	{
    	    ANTLR3_UINT32 LA117_132;

    	    ANTLR3_MARKER index117_132;


    		LA117_132 = LA(1);

    	 
    	    index117_132 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_132 >= CRLF) && (LA117_132 <= SP)) || LA117_132 == COLON || LA117_132 == BQUOTE || LA117_132 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_132 >= HEX_CHAR) && (LA117_132 <= COMMON_CHAR))) )
    	    {
    	        s = 69;
    	    }

    	    else if ( (LA117_132 == DIGIT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA117_132 == DOT || LA117_132 == DASH || ((LA117_132 >= STAR) && (LA117_132 <= RPAREN)) || ((LA117_132 >= USCORE) && (LA117_132 <= SQUOTE))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA117_132 == PERCENT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA117_132 == PLUS) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA117_132 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_132 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_132 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_132 == DOLLARD) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA117_132 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	 
    		SEEK(index117_132);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 76:
        
    	{
    	    ANTLR3_UINT32 LA117_16;

    	    ANTLR3_MARKER index117_16;


    		LA117_16 = LA(1);

    	 
    	    index117_16 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_16 == DIGIT) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA117_16 == DOT) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (((LA117_16 >= HEX_CHAR) && (LA117_16 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_16 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_16 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_16 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_16 >= STAR) && (LA117_16 <= RPAREN)) || ((LA117_16 >= USCORE) && (LA117_16 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_16 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_16 == SLASH || ((LA117_16 >= AND) && (LA117_16 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_16);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 77:
        
    	{
    	    ANTLR3_UINT32 LA117_146;

    	    ANTLR3_MARKER index117_146;


    		LA117_146 = LA(1);

    	 
    	    index117_146 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_146 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_146 >= HEX_CHAR) && (LA117_146 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_146 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_146 == DOT || LA117_146 == DASH || ((LA117_146 >= STAR) && (LA117_146 <= RPAREN)) || ((LA117_146 >= USCORE) && (LA117_146 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_146 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_146 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_146 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_146 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (LA117_146 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	    else if ( (LA117_146 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_146 == EOF || ((LA117_146 >= CRLF) && (LA117_146 <= SLASH)) || LA117_146 == COLON || ((LA117_146 >= SEMI) && (LA117_146 <= QMARK)) || ((LA117_146 >= LSBRAQUET) && (LA117_146 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_146);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 78:
        
    	{
    	    ANTLR3_UINT32 LA117_67;

    	    ANTLR3_MARKER index117_67;


    		LA117_67 = LA(1);

    	 
    	    index117_67 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_67 == DIGIT) )
    	    {
    	        s = 108;
    	    }

    	    else if ( (LA117_67 == DOT) )
    	    {
    	        s = 68;
    	    }

    	    else if ( (((LA117_67 >= HEX_CHAR) && (LA117_67 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_67 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_67 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_67 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_67 >= STAR) && (LA117_67 <= RPAREN)) || ((LA117_67 >= USCORE) && (LA117_67 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_67 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_67 == SLASH || ((LA117_67 >= AND) && (LA117_67 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_67);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 79:
        
    	{
    	    ANTLR3_UINT32 LA117_52;

    	    ANTLR3_MARKER index117_52;


    		LA117_52 = LA(1);

    	 
    	    index117_52 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_52 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_52 >= HEX_CHAR) && (LA117_52 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_52 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_52 == DOT || LA117_52 == DASH || ((LA117_52 >= STAR) && (LA117_52 <= RPAREN)) || ((LA117_52 >= USCORE) && (LA117_52 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_52 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_52 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_52 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_52 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA117_52 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA117_52 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_52 == EOF || ((LA117_52 >= CRLF) && (LA117_52 <= SLASH)) || LA117_52 == COLON || ((LA117_52 >= SEMI) && (LA117_52 <= QMARK)) || ((LA117_52 >= LSBRAQUET) && (LA117_52 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_52);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 80:
        
    	{
    	    ANTLR3_UINT32 LA117_2;

    	    ANTLR3_MARKER index117_2;


    		LA117_2 = LA(1);

    	 
    	    index117_2 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_2 == DIGIT) )
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA117_2 == DOT) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (((LA117_2 >= HEX_CHAR) && (LA117_2 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_2 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_2 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_2 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_2 >= STAR) && (LA117_2 <= RPAREN)) || ((LA117_2 >= USCORE) && (LA117_2 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_2 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_2 == SLASH || ((LA117_2 >= AND) && (LA117_2 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_2);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 81:
        
    	{
    	    ANTLR3_UINT32 LA117_78;

    	    ANTLR3_MARKER index117_78;


    		LA117_78 = LA(1);

    	 
    	    index117_78 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_78 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA117_78 >= HEX_CHAR) && (LA117_78 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_78 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_78 == DOT || LA117_78 == DASH || ((LA117_78 >= STAR) && (LA117_78 <= RPAREN)) || ((LA117_78 >= USCORE) && (LA117_78 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_78 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_78 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_78 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_78 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_78 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_78 == SLASH || LA117_78 == COLON || LA117_78 == QMARK || ((LA117_78 >= LSBRAQUET) && (LA117_78 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_78 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	 
    		SEEK(index117_78);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 82:
        
    	{
    	    ANTLR3_UINT32 LA117_130;

    	    ANTLR3_MARKER index117_130;


    		LA117_130 = LA(1);

    	 
    	    index117_130 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_130 == DIGIT) )
    	    {
    	        s = 143;
    	    }

    	    else if ( (LA117_130 == DOT) )
    	    {
    	        s = 131;
    	    }

    	    else if ( (((LA117_130 >= HEX_CHAR) && (LA117_130 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_130 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_130 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_130 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_130 >= STAR) && (LA117_130 <= RPAREN)) || ((LA117_130 >= USCORE) && (LA117_130 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_130 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_130 == SLASH || ((LA117_130 >= AND) && (LA117_130 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_130);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 83:
        
    	{
    	    ANTLR3_UINT32 LA117_36;

    	    ANTLR3_MARKER index117_36;


    		LA117_36 = LA(1);

    	 
    	    index117_36 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_36 == EQUAL) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA117_36 == COLON) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (((LA117_36 >= HEX_CHAR) && (LA117_36 <= COMMON_CHAR))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA117_36 == DIGIT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA117_36 == DOT || LA117_36 == DASH || ((LA117_36 >= STAR) && (LA117_36 <= RPAREN)) || ((LA117_36 >= USCORE) && (LA117_36 <= SQUOTE))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA117_36 == PERCENT) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA117_36 == SLASH || ((LA117_36 >= PLUS) && (LA117_36 <= DOLLARD)) || LA117_36 == QMARK) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA117_36 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_36 >= LSBRAQUET) && (LA117_36 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_36 == AND || ((LA117_36 >= COMMA) && (LA117_36 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_36);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 84:
        
    	{
    	    ANTLR3_UINT32 LA117_126;

    	    ANTLR3_MARKER index117_126;


    		LA117_126 = LA(1);

    	 
    	    index117_126 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_126 == EQUAL) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA117_126 == COLON) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (((LA117_126 >= HEX_CHAR) && (LA117_126 <= COMMON_CHAR))) )
    	    {
    	        s = 122;
    	    }

    	    else if ( (LA117_126 == DIGIT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA117_126 == DOT || LA117_126 == DASH || ((LA117_126 >= STAR) && (LA117_126 <= RPAREN)) || ((LA117_126 >= USCORE) && (LA117_126 <= SQUOTE))) )
    	    {
    	        s = 124;
    	    }

    	    else if ( (LA117_126 == PERCENT) )
    	    {
    	        s = 125;
    	    }

    	    else if ( (LA117_126 == SLASH || ((LA117_126 >= PLUS) && (LA117_126 <= DOLLARD)) || LA117_126 == QMARK) )
    	    {
    	        s = 126;
    	    }

    	    else if ( (LA117_126 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_126 >= LSBRAQUET) && (LA117_126 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_126 == AND || ((LA117_126 >= COMMA) && (LA117_126 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_126);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 85:
        
    	{
    	    ANTLR3_UINT32 LA117_48;

    	    ANTLR3_MARKER index117_48;


    		LA117_48 = LA(1);

    	 
    	    index117_48 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_48 == DIGIT) )
    	    {
    	        s = 67;
    	    }

    	    else if ( (LA117_48 == DOT) )
    	    {
    	        s = 68;
    	    }

    	    else if ( (((LA117_48 >= HEX_CHAR) && (LA117_48 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_48 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_48 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_48 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_48 >= STAR) && (LA117_48 <= RPAREN)) || ((LA117_48 >= USCORE) && (LA117_48 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_48 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_48 == SLASH || ((LA117_48 >= AND) && (LA117_48 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_48);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 86:
        
    	{
    	    ANTLR3_UINT32 LA117_138;

    	    ANTLR3_MARKER index117_138;


    		LA117_138 = LA(1);

    	 
    	    index117_138 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_138 == COLON) )
    	    {
    	        s = 152;
    	    }

    	    else if ( (LA117_138 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_138 >= HEX_CHAR) && (LA117_138 <= COMMON_CHAR))) )
    	    {
    	        s = 153;
    	    }

    	    else if ( (LA117_138 == DIGIT) )
    	    {
    	        s = 154;
    	    }

    	    else if ( (LA117_138 == DOT || LA117_138 == DASH || ((LA117_138 >= STAR) && (LA117_138 <= RPAREN)) || ((LA117_138 >= USCORE) && (LA117_138 <= SQUOTE))) )
    	    {
    	        s = 155;
    	    }

    	    else if ( (LA117_138 == PERCENT) )
    	    {
    	        s = 156;
    	    }

    	    else if ( (LA117_138 == SLASH || ((LA117_138 >= PLUS) && (LA117_138 <= DOLLARD)) || LA117_138 == QMARK) )
    	    {
    	        s = 157;
    	    }

    	    else if ( (LA117_138 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_138 == EOF || ((LA117_138 >= CRLF) && (LA117_138 <= SP)) || ((LA117_138 >= LSBRAQUET) && (LA117_138 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_138 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_138 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_138 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_138);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 87:
        
    	{
    	    ANTLR3_UINT32 LA117_32;

    	    ANTLR3_MARKER index117_32;


    		LA117_32 = LA(1);

    	 
    	    index117_32 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_32 == EQUAL) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA117_32 == COLON) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (((LA117_32 >= HEX_CHAR) && (LA117_32 <= COMMON_CHAR))) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA117_32 == DIGIT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA117_32 == DOT || LA117_32 == DASH || ((LA117_32 >= STAR) && (LA117_32 <= RPAREN)) || ((LA117_32 >= USCORE) && (LA117_32 <= SQUOTE))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA117_32 == PERCENT) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA117_32 == SLASH || ((LA117_32 >= PLUS) && (LA117_32 <= DOLLARD)) || LA117_32 == QMARK) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA117_32 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_32 >= LSBRAQUET) && (LA117_32 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_32 == AND || ((LA117_32 >= COMMA) && (LA117_32 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_32);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 88:
        
    	{
    	    ANTLR3_UINT32 LA117_122;

    	    ANTLR3_MARKER index117_122;


    		LA117_122 = LA(1);

    	 
    	    index117_122 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_122 == EQUAL) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA117_122 == COLON) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (((LA117_122 >= HEX_CHAR) && (LA117_122 <= COMMON_CHAR))) )
    	    {
    	        s = 122;
    	    }

    	    else if ( (LA117_122 == DIGIT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA117_122 == DOT || LA117_122 == DASH || ((LA117_122 >= STAR) && (LA117_122 <= RPAREN)) || ((LA117_122 >= USCORE) && (LA117_122 <= SQUOTE))) )
    	    {
    	        s = 124;
    	    }

    	    else if ( (LA117_122 == PERCENT) )
    	    {
    	        s = 125;
    	    }

    	    else if ( (LA117_122 == SLASH || ((LA117_122 >= PLUS) && (LA117_122 <= DOLLARD)) || LA117_122 == QMARK) )
    	    {
    	        s = 126;
    	    }

    	    else if ( (LA117_122 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_122 >= LSBRAQUET) && (LA117_122 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_122 == AND || ((LA117_122 >= COMMA) && (LA117_122 <= SEMI))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_122);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 89:
        
    	{
    	    ANTLR3_UINT32 LA117_149;

    	    ANTLR3_MARKER index117_149;


    		LA117_149 = LA(1);

    	 
    	    index117_149 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_149 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_149 >= HEX_CHAR) && (LA117_149 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_149 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_149 == DOT || LA117_149 == DASH || ((LA117_149 >= STAR) && (LA117_149 <= RPAREN)) || ((LA117_149 >= USCORE) && (LA117_149 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_149 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_149 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_149 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_149 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (LA117_149 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	    else if ( (LA117_149 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_149 == EOF || ((LA117_149 >= CRLF) && (LA117_149 <= SLASH)) || LA117_149 == COLON || ((LA117_149 >= SEMI) && (LA117_149 <= QMARK)) || ((LA117_149 >= LSBRAQUET) && (LA117_149 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_149);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 90:
        
    	{
    	    ANTLR3_UINT32 LA117_49;

    	    ANTLR3_MARKER index117_49;


    		LA117_49 = LA(1);

    	 
    	    index117_49 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_49 >= HEX_CHAR) && (LA117_49 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA117_49 == DIGIT) )
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA117_49 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_49 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_49 == DOT || LA117_49 == DASH || ((LA117_49 >= STAR) && (LA117_49 <= RPAREN)) || ((LA117_49 >= USCORE) && (LA117_49 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_49 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_49 == SLASH || ((LA117_49 >= AND) && (LA117_49 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_49);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 91:
        
    	{
    	    ANTLR3_UINT32 LA117_109;

    	    ANTLR3_MARKER index117_109;


    		LA117_109 = LA(1);

    	 
    	    index117_109 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_109 == DIGIT) )
    	    {
    	        s = 130;
    	    }

    	    else if ( (LA117_109 == DOT) )
    	    {
    	        s = 131;
    	    }

    	    else if ( (((LA117_109 >= HEX_CHAR) && (LA117_109 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_109 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_109 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_109 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_109 >= STAR) && (LA117_109 <= RPAREN)) || ((LA117_109 >= USCORE) && (LA117_109 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_109 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_109 == SLASH || ((LA117_109 >= AND) && (LA117_109 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_109);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 92:
        
    	{
    	    ANTLR3_UINT32 LA117_163;

    	    ANTLR3_MARKER index117_163;


    		LA117_163 = LA(1);

    	 
    	    index117_163 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_163 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_163 >= HEX_CHAR) && (LA117_163 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_163 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_163 == DOT || LA117_163 == DASH || ((LA117_163 >= STAR) && (LA117_163 <= RPAREN)) || ((LA117_163 >= USCORE) && (LA117_163 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_163 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_163 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_163 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_163 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (LA117_163 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	    else if ( (LA117_163 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_163 == EOF || ((LA117_163 >= CRLF) && (LA117_163 <= SLASH)) || LA117_163 == COLON || ((LA117_163 >= SEMI) && (LA117_163 <= QMARK)) || ((LA117_163 >= LSBRAQUET) && (LA117_163 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_163);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 93:
        
    	{
    	    ANTLR3_UINT32 LA117_141;

    	    ANTLR3_MARKER index117_141;


    		LA117_141 = LA(1);

    	 
    	    index117_141 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_141 == EOF || ((LA117_141 >= CRLF) && (LA117_141 <= SP)) || LA117_141 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_141 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_141 >= HEX_CHAR) && (LA117_141 <= COMMON_CHAR))) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA117_141 == DIGIT) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA117_141 == DOT || LA117_141 == DASH || ((LA117_141 >= STAR) && (LA117_141 <= RPAREN)) || ((LA117_141 >= USCORE) && (LA117_141 <= SQUOTE))) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA117_141 == PERCENT) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA117_141 == PLUS) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA117_141 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_141 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_141 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_141 == SLASH || ((LA117_141 >= AND) && (LA117_141 <= EQUAL)) || LA117_141 == DOLLARD || LA117_141 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_141);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 94:
        
    	{
    	    ANTLR3_UINT32 LA117_76;

    	    ANTLR3_MARKER index117_76;


    		LA117_76 = LA(1);

    	 
    	    index117_76 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_76 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_76 >= HEX_CHAR) && (LA117_76 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_76 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_76 == DOT || LA117_76 == DASH || ((LA117_76 >= STAR) && (LA117_76 <= RPAREN)) || ((LA117_76 >= USCORE) && (LA117_76 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_76 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_76 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_76 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_76 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA117_76 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA117_76 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_76 == EOF || ((LA117_76 >= CRLF) && (LA117_76 <= SLASH)) || LA117_76 == COLON || ((LA117_76 >= SEMI) && (LA117_76 <= QMARK)) || ((LA117_76 >= LSBRAQUET) && (LA117_76 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_76);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 95:
        
    	{
    	    ANTLR3_UINT32 LA117_10;

    	    ANTLR3_MARKER index117_10;


    		LA117_10 = LA(1);

    	 
    	    index117_10 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_10 >= HEX_CHAR) && (LA117_10 <= COMMON_CHAR))) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA117_10 == DIGIT) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA117_10 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_10 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_10 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_10 == DOT || ((LA117_10 >= STAR) && (LA117_10 <= RPAREN)) || ((LA117_10 >= USCORE) && (LA117_10 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_10 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_10 == SLASH || ((LA117_10 >= AND) && (LA117_10 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_10);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 96:
        
    	{
    	    ANTLR3_UINT32 LA117_46;

    	    ANTLR3_MARKER index117_46;


    		LA117_46 = LA(1);

    	 
    	    index117_46 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_46 == COLON) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (((LA117_46 >= HEX_CHAR) && (LA117_46 <= COMMON_CHAR))) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA117_46 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA117_46 == DOT || LA117_46 == DASH || ((LA117_46 >= STAR) && (LA117_46 <= RPAREN)) || ((LA117_46 >= USCORE) && (LA117_46 <= SQUOTE))) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA117_46 == PERCENT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA117_46 == PLUS) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (((LA117_46 >= CRLF) && (LA117_46 <= SP)) || LA117_46 == BQUOTE || LA117_46 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_46 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_46 == SLASH || ((LA117_46 >= AND) && (LA117_46 <= EQUAL)) || ((LA117_46 >= DOLLARD) && (LA117_46 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_46);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 97:
        
    	{
    	    ANTLR3_UINT32 LA117_106;

    	    ANTLR3_MARKER index117_106;


    		LA117_106 = LA(1);

    	 
    	    index117_106 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_106 >= CRLF) && (LA117_106 <= SP)) || LA117_106 == BQUOTE || LA117_106 == LAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_106 >= HEX_CHAR) && (LA117_106 <= COMMON_CHAR))) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA117_106 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA117_106 == DOT || LA117_106 == DASH || ((LA117_106 >= STAR) && (LA117_106 <= RPAREN)) || ((LA117_106 >= USCORE) && (LA117_106 <= SQUOTE))) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA117_106 == PERCENT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA117_106 == PLUS) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA117_106 == COLON) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA117_106 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_106 == SLASH || ((LA117_106 >= AND) && (LA117_106 <= EQUAL)) || ((LA117_106 >= DOLLARD) && (LA117_106 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_106);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 98:
        
    	{
    	    ANTLR3_UINT32 LA117_82;

    	    ANTLR3_MARKER index117_82;


    		LA117_82 = LA(1);

    	 
    	    index117_82 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_82 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_82 == EOF || ((LA117_82 >= CRLF) && (LA117_82 <= SLASH)) || LA117_82 == COLON || ((LA117_82 >= SEMI) && (LA117_82 <= QMARK)) || ((LA117_82 >= LSBRAQUET) && (LA117_82 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_82 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_82 == PLUS) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (((LA117_82 >= HEX_CHAR) && (LA117_82 <= COMMON_CHAR))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA117_82 == DIGIT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA117_82 == DOT || LA117_82 == DASH || ((LA117_82 >= STAR) && (LA117_82 <= RPAREN)) || ((LA117_82 >= USCORE) && (LA117_82 <= SQUOTE))) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA117_82 == PERCENT) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA117_82 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_82 == DOLLARD) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA117_82 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	 
    		SEEK(index117_82);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 99:
        
    	{
    	    ANTLR3_UINT32 LA117_150;

    	    ANTLR3_MARKER index117_150;


    		LA117_150 = LA(1);

    	 
    	    index117_150 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_150 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_150 >= HEX_CHAR) && (LA117_150 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_150 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_150 == DOT || LA117_150 == DASH || ((LA117_150 >= STAR) && (LA117_150 <= RPAREN)) || ((LA117_150 >= USCORE) && (LA117_150 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_150 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_150 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_150 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_150 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (LA117_150 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	    else if ( (LA117_150 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_150 == EOF || ((LA117_150 >= CRLF) && (LA117_150 <= SLASH)) || LA117_150 == COLON || ((LA117_150 >= SEMI) && (LA117_150 <= QMARK)) || ((LA117_150 >= LSBRAQUET) && (LA117_150 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_150);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 100:
        
    	{
    	    ANTLR3_UINT32 LA117_41;

    	    ANTLR3_MARKER index117_41;


    		LA117_41 = LA(1);

    	 
    	    index117_41 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_41 == EOF || ((LA117_41 >= CRLF) && (LA117_41 <= SP)) || LA117_41 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_41 == EQUAL) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA117_41 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_41 >= HEX_CHAR) && (LA117_41 <= COMMON_CHAR))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA117_41 == DIGIT) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA117_41 == DOT || LA117_41 == DASH || ((LA117_41 >= STAR) && (LA117_41 <= RPAREN)) || ((LA117_41 >= USCORE) && (LA117_41 <= SQUOTE))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA117_41 == PERCENT) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA117_41 == PLUS) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA117_41 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_41 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_41 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_41 == SLASH || LA117_41 == AND || LA117_41 == DOLLARD || LA117_41 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_41);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 101:
        
    	{
    	    ANTLR3_UINT32 LA117_47;

    	    ANTLR3_MARKER index117_47;


    		LA117_47 = LA(1);

    	 
    	    index117_47 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_47 == DOT) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (((LA117_47 >= HEX_CHAR) && (LA117_47 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_47 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_47 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_47 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_47 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_47 >= STAR) && (LA117_47 <= RPAREN)) || ((LA117_47 >= USCORE) && (LA117_47 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_47 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_47 == SLASH || ((LA117_47 >= AND) && (LA117_47 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_47);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 102:
        
    	{
    	    ANTLR3_UINT32 LA117_154;

    	    ANTLR3_MARKER index117_154;


    		LA117_154 = LA(1);

    	 
    	    index117_154 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_154 == EOF || ((LA117_154 >= CRLF) && (LA117_154 <= SP)) || ((LA117_154 >= LSBRAQUET) && (LA117_154 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_154 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_154 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_154 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_154 == COLON) )
    	    {
    	        s = 152;
    	    }

    	    else if ( (((LA117_154 >= HEX_CHAR) && (LA117_154 <= COMMON_CHAR))) )
    	    {
    	        s = 153;
    	    }

    	    else if ( (LA117_154 == DIGIT) )
    	    {
    	        s = 154;
    	    }

    	    else if ( (LA117_154 == DOT || LA117_154 == DASH || ((LA117_154 >= STAR) && (LA117_154 <= RPAREN)) || ((LA117_154 >= USCORE) && (LA117_154 <= SQUOTE))) )
    	    {
    	        s = 155;
    	    }

    	    else if ( (LA117_154 == PERCENT) )
    	    {
    	        s = 156;
    	    }

    	    else if ( (LA117_154 == SLASH || ((LA117_154 >= PLUS) && (LA117_154 <= DOLLARD)) || LA117_154 == QMARK) )
    	    {
    	        s = 157;
    	    }

    	    else if ( (LA117_154 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_154 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_154);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 103:
        
    	{
    	    ANTLR3_UINT32 LA117_0;

    	    ANTLR3_MARKER index117_0;


    		LA117_0 = LA(1);

    	 
    	    index117_0 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_0 >= HEX_CHAR) && (LA117_0 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA117_0 == DIGIT) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (LA117_0 == DOT || LA117_0 == DASH || ((LA117_0 >= STAR) && (LA117_0 <= RPAREN)) || ((LA117_0 >= USCORE) && (LA117_0 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_0 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_0 == SLASH || ((LA117_0 >= AND) && (LA117_0 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA117_0 == LSBRAQUET) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_0);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 104:
        
    	{
    	    ANTLR3_UINT32 LA117_108;

    	    ANTLR3_MARKER index117_108;


    		LA117_108 = LA(1);

    	 
    	    index117_108 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_108 == DOT) )
    	    {
    	        s = 68;
    	    }

    	    else if ( (((LA117_108 >= HEX_CHAR) && (LA117_108 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_108 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_108 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_108 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_108 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_108 >= STAR) && (LA117_108 <= RPAREN)) || ((LA117_108 >= USCORE) && (LA117_108 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_108 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_108 == SLASH || ((LA117_108 >= AND) && (LA117_108 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_108);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 105:
        
    	{
    	    ANTLR3_UINT32 LA117_143;

    	    ANTLR3_MARKER index117_143;


    		LA117_143 = LA(1);

    	 
    	    index117_143 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_143 == DOT) )
    	    {
    	        s = 131;
    	    }

    	    else if ( (((LA117_143 >= HEX_CHAR) && (LA117_143 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_143 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_143 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_143 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_143 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_143 >= STAR) && (LA117_143 <= RPAREN)) || ((LA117_143 >= USCORE) && (LA117_143 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_143 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_143 == SLASH || ((LA117_143 >= AND) && (LA117_143 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_143);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 106:
        
    	{
    	    ANTLR3_UINT32 LA117_55;

    	    ANTLR3_MARKER index117_55;


    		LA117_55 = LA(1);

    	 
    	    index117_55 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_55 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_55 >= HEX_CHAR) && (LA117_55 <= COMMON_CHAR))) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA117_55 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA117_55 == DOT || LA117_55 == DASH || ((LA117_55 >= STAR) && (LA117_55 <= RPAREN)) || ((LA117_55 >= USCORE) && (LA117_55 <= SQUOTE))) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA117_55 == PERCENT) )
    	    {
    	        s = 57;
    	    }

    	    else if ( (LA117_55 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_55 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA117_55 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA117_55 == DOLLARD) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA117_55 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_55 == SLASH || LA117_55 == COLON || LA117_55 == QMARK || ((LA117_55 >= LSBRAQUET) && (LA117_55 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_55);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 107:
        
    	{
    	    ANTLR3_UINT32 LA117_115;

    	    ANTLR3_MARKER index117_115;


    		LA117_115 = LA(1);

    	 
    	    index117_115 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_115 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_115 >= HEX_CHAR) && (LA117_115 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_115 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_115 == DOT || LA117_115 == DASH || ((LA117_115 >= STAR) && (LA117_115 <= RPAREN)) || ((LA117_115 >= USCORE) && (LA117_115 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_115 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_115 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_115 == EQUAL) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA117_115 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (LA117_115 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_115 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_115 == SLASH || LA117_115 == COLON || LA117_115 == QMARK || ((LA117_115 >= LSBRAQUET) && (LA117_115 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_115);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 108:
        
    	{
    	    ANTLR3_UINT32 LA117_19;

    	    ANTLR3_MARKER index117_19;


    		LA117_19 = LA(1);

    	 
    	    index117_19 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_19 >= HEX_CHAR) && (LA117_19 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_19 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_19 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_19 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_19 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_19 == DOT || ((LA117_19 >= STAR) && (LA117_19 <= RPAREN)) || ((LA117_19 >= USCORE) && (LA117_19 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_19 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_19 == SLASH || ((LA117_19 >= AND) && (LA117_19 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_19);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 109:
        
    	{
    	    ANTLR3_UINT32 LA117_164;

    	    ANTLR3_MARKER index117_164;


    		LA117_164 = LA(1);

    	 
    	    index117_164 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_164 == EOF || ((LA117_164 >= CRLF) && (LA117_164 <= SP)) || ((LA117_164 >= LSBRAQUET) && (LA117_164 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_164 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_164 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_164 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_164 == COLON) )
    	    {
    	        s = 152;
    	    }

    	    else if ( (((LA117_164 >= HEX_CHAR) && (LA117_164 <= COMMON_CHAR))) )
    	    {
    	        s = 153;
    	    }

    	    else if ( (LA117_164 == DIGIT) )
    	    {
    	        s = 154;
    	    }

    	    else if ( (LA117_164 == DOT || LA117_164 == DASH || ((LA117_164 >= STAR) && (LA117_164 <= RPAREN)) || ((LA117_164 >= USCORE) && (LA117_164 <= SQUOTE))) )
    	    {
    	        s = 155;
    	    }

    	    else if ( (LA117_164 == PERCENT) )
    	    {
    	        s = 156;
    	    }

    	    else if ( (LA117_164 == SLASH || ((LA117_164 >= PLUS) && (LA117_164 <= DOLLARD)) || LA117_164 == QMARK) )
    	    {
    	        s = 157;
    	    }

    	    else if ( (LA117_164 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_164 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_164);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 110:
        
    	{
    	    ANTLR3_UINT32 LA117_14;

    	    ANTLR3_MARKER index117_14;


    		LA117_14 = LA(1);

    	 
    	    index117_14 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA117_14 >= CRLF) && (LA117_14 <= SP)) || LA117_14 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA117_14 >= HEX_CHAR) && (LA117_14 <= COMMON_CHAR))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA117_14 == DIGIT) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA117_14 == DOT || LA117_14 == DASH || ((LA117_14 >= STAR) && (LA117_14 <= RPAREN)) || ((LA117_14 >= USCORE) && (LA117_14 <= SQUOTE))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA117_14 == PERCENT) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA117_14 == PLUS) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA117_14 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_14 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_14 == SLASH || ((LA117_14 >= AND) && (LA117_14 <= EQUAL)) || ((LA117_14 >= DOLLARD) && (LA117_14 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_14);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 111:
        
    	{
    	    ANTLR3_UINT32 LA117_85;

    	    ANTLR3_MARKER index117_85;


    		LA117_85 = LA(1);

    	 
    	    index117_85 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_85 == AND) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA117_85 == EOF || ((LA117_85 >= CRLF) && (LA117_85 <= SP)) || ((LA117_85 >= LSBRAQUET) && (LA117_85 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_85 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA117_85 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_85 == COLON) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (((LA117_85 >= HEX_CHAR) && (LA117_85 <= COMMON_CHAR))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA117_85 == DIGIT) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA117_85 == DOT || LA117_85 == DASH || ((LA117_85 >= STAR) && (LA117_85 <= RPAREN)) || ((LA117_85 >= USCORE) && (LA117_85 <= SQUOTE))) )
    	    {
    	        s = 85;
    	    }

    	    else if ( (LA117_85 == PERCENT) )
    	    {
    	        s = 86;
    	    }

    	    else if ( (LA117_85 == SLASH || ((LA117_85 >= PLUS) && (LA117_85 <= DOLLARD)) || LA117_85 == QMARK) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA117_85 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_85 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_85);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 112:
        
    	{
    	    ANTLR3_UINT32 LA117_50;

    	    ANTLR3_MARKER index117_50;


    		LA117_50 = LA(1);

    	 
    	    index117_50 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_50 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA117_50 >= HEX_CHAR) && (LA117_50 <= COMMON_CHAR))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA117_50 == DIGIT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA117_50 == DASH) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA117_50 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_50 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_50 >= STAR) && (LA117_50 <= RPAREN)) || ((LA117_50 >= USCORE) && (LA117_50 <= SQUOTE))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA117_50 == PERCENT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA117_50 == SLASH || ((LA117_50 >= AND) && (LA117_50 <= QMARK))) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_50);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 113:
        
    	{
    	    ANTLR3_UINT32 LA117_119;

    	    ANTLR3_MARKER index117_119;


    		LA117_119 = LA(1);

    	 
    	    index117_119 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_119 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_119 >= HEX_CHAR) && (LA117_119 <= COMMON_CHAR))) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA117_119 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA117_119 == DOT || LA117_119 == DASH || ((LA117_119 >= STAR) && (LA117_119 <= RPAREN)) || ((LA117_119 >= USCORE) && (LA117_119 <= SQUOTE))) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA117_119 == PERCENT) )
    	    {
    	        s = 57;
    	    }

    	    else if ( (LA117_119 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_119 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA117_119 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA117_119 == DOLLARD) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA117_119 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_119 == SLASH || LA117_119 == COLON || LA117_119 == QMARK || ((LA117_119 >= LSBRAQUET) && (LA117_119 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_119);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 114:
        
    	{
    	    ANTLR3_UINT32 LA117_151;

    	    ANTLR3_MARKER index117_151;


    		LA117_151 = LA(1);

    	 
    	    index117_151 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_151 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_151 >= HEX_CHAR) && (LA117_151 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_151 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_151 == DOT || LA117_151 == DASH || ((LA117_151 >= STAR) && (LA117_151 <= RPAREN)) || ((LA117_151 >= USCORE) && (LA117_151 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_151 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_151 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_151 == EQUAL) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA117_151 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (LA117_151 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_151 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_151 == SLASH || LA117_151 == COLON || LA117_151 == QMARK || ((LA117_151 >= LSBRAQUET) && (LA117_151 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_151);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 115:
        
    	{
    	    ANTLR3_UINT32 LA117_53;

    	    ANTLR3_MARKER index117_53;


    		LA117_53 = LA(1);

    	 
    	    index117_53 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_53 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_53 >= HEX_CHAR) && (LA117_53 <= COMMON_CHAR))) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA117_53 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA117_53 == DOT || LA117_53 == DASH || ((LA117_53 >= STAR) && (LA117_53 <= RPAREN)) || ((LA117_53 >= USCORE) && (LA117_53 <= SQUOTE))) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA117_53 == PERCENT) )
    	    {
    	        s = 57;
    	    }

    	    else if ( (LA117_53 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_53 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA117_53 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA117_53 == DOLLARD) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA117_53 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_53 == SLASH || LA117_53 == COLON || LA117_53 == QMARK || ((LA117_53 >= LSBRAQUET) && (LA117_53 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_53);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 116:
        
    	{
    	    ANTLR3_UINT32 LA117_113;

    	    ANTLR3_MARKER index117_113;


    		LA117_113 = LA(1);

    	 
    	    index117_113 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_113 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_113 >= HEX_CHAR) && (LA117_113 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_113 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_113 == DOT || LA117_113 == DASH || ((LA117_113 >= STAR) && (LA117_113 <= RPAREN)) || ((LA117_113 >= USCORE) && (LA117_113 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_113 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_113 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_113 == EQUAL) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA117_113 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (LA117_113 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_113 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_113 == SLASH || LA117_113 == COLON || LA117_113 == QMARK || ((LA117_113 >= LSBRAQUET) && (LA117_113 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_113);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 117:
        
    	{
    	    ANTLR3_UINT32 LA117_37;

    	    ANTLR3_MARKER index117_37;


    		LA117_37 = LA(1);

    	 
    	    index117_37 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_37 == EOF || ((LA117_37 >= CRLF) && (LA117_37 <= SP)) || LA117_37 == BQUOTE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA117_37 == EQUAL) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA117_37 == SEMI) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA117_37 >= HEX_CHAR) && (LA117_37 <= COMMON_CHAR))) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA117_37 == DIGIT) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA117_37 == DOT || LA117_37 == DASH || ((LA117_37 >= STAR) && (LA117_37 <= RPAREN)) || ((LA117_37 >= USCORE) && (LA117_37 <= SQUOTE))) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA117_37 == PERCENT) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA117_37 == PLUS) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA117_37 == COLON) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA117_37 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA117_37 == COMMA) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA117_37 == SLASH || LA117_37 == AND || LA117_37 == DOLLARD || LA117_37 == QMARK) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index117_37);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 118:
        
    	{
    	    ANTLR3_UINT32 LA117_58;

    	    ANTLR3_MARKER index117_58;


    		LA117_58 = LA(1);

    	 
    	    index117_58 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_58 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_58 >= HEX_CHAR) && (LA117_58 <= COMMON_CHAR))) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA117_58 == DIGIT) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA117_58 == DOT || LA117_58 == DASH || ((LA117_58 >= STAR) && (LA117_58 <= RPAREN)) || ((LA117_58 >= USCORE) && (LA117_58 <= SQUOTE))) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA117_58 == PERCENT) )
    	    {
    	        s = 57;
    	    }

    	    else if ( (LA117_58 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_58 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA117_58 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA117_58 == DOLLARD) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA117_58 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_58 == SLASH || LA117_58 == COLON || LA117_58 == QMARK || ((LA117_58 >= LSBRAQUET) && (LA117_58 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_58);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 119:
        
    	{
    	    ANTLR3_UINT32 LA117_118;

    	    ANTLR3_MARKER index117_118;


    		LA117_118 = LA(1);

    	 
    	    index117_118 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_118 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_118 >= HEX_CHAR) && (LA117_118 <= COMMON_CHAR))) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA117_118 == DIGIT) )
    	    {
    	        s = 115;
    	    }

    	    else if ( (LA117_118 == DOT || LA117_118 == DASH || ((LA117_118 >= STAR) && (LA117_118 <= RPAREN)) || ((LA117_118 >= USCORE) && (LA117_118 <= SQUOTE))) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA117_118 == PERCENT) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA117_118 == AND) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA117_118 == EQUAL) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA117_118 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (LA117_118 == DOLLARD) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA117_118 == COMMA) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA117_118 == SLASH || LA117_118 == COLON || LA117_118 == QMARK || ((LA117_118 >= LSBRAQUET) && (LA117_118 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_118);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 120:
        
    	{
    	    ANTLR3_UINT32 LA117_135;

    	    ANTLR3_MARKER index117_135;


    		LA117_135 = LA(1);

    	 
    	    index117_135 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA117_135 == AT) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (((LA117_135 >= HEX_CHAR) && (LA117_135 <= COMMON_CHAR))) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA117_135 == DIGIT) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA117_135 == DOT || LA117_135 == DASH || ((LA117_135 >= STAR) && (LA117_135 <= RPAREN)) || ((LA117_135 >= USCORE) && (LA117_135 <= SQUOTE))) )
    	    {
    	        s = 147;
    	    }

    	    else if ( (LA117_135 == PERCENT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA117_135 == AND) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA117_135 == EQUAL) && (synpred9_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA117_135 == PLUS) )
    	    {
    	        s = 149;
    	    }

    	    else if ( (LA117_135 == DOLLARD) )
    	    {
    	        s = 150;
    	    }

    	    else if ( (LA117_135 == COMMA) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA117_135 == EOF || ((LA117_135 >= CRLF) && (LA117_135 <= SLASH)) || LA117_135 == COLON || ((LA117_135 >= SEMI) && (LA117_135 <= QMARK)) || ((LA117_135 >= LSBRAQUET) && (LA117_135 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index117_135);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"1443:43: ( ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] )";
    EXCEPTION->decisionNum  = 117;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 117
 */
static
ANTLR3_CYCLIC_DFA cdfa117
    =	{
	    117,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1443:43: ( ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] )",	
	    (CDFA_SPECIAL_FUNC) dfa117_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa117_eot,	    /* EOT table			    */
	    dfa117_eof,	    /* EOF table			    */
	    dfa117_min,	    /* Minimum tokens for each state    */
	    dfa117_max,	    /* Maximum tokens for each state    */
	    dfa117_accept,	/* Accept table			    */
	    dfa117_special,	/* Special transition states	    */
	    dfa117_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 117
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1455:33: ( ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] )
 */
static const ANTLR3_INT32 dfa119_eot[154] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa119_eof[154] =
    {
	-1, 6, -1, -1, -1, -1, -1, -1, -1, 6, 6, -1, 6, 6, -1, -1, -1, -1, -1, 
	-1, -1, 6, -1, -1, -1, -1, -1, -1, -1, 6, 6, 6, 6, -1, 6, 6, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 6, 6, 6, -1, 6, -1, 6, 6, 6, -1, -1, -1, 
	-1, -1, -1, 6, -1, -1, 6, -1, -1, -1, -1, 6, 6, 6, 6, 6, -1, 6, 6, 6, 6, 
	6, 6, -1, 6, 6, 6, -1, 6, 6, 6, -1, -1, 6, 6, 6, 6, 6, 6, -1, 6, -1, -1, 
	-1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 6, 6, 6, 6, -1, 6, 6, -1, -1, 6, 6, 6, 6, -1, 6, 6, -1, 
	6, 6, 6, 6, -1, 6, -1, 6, -1, -1, 6, 6, 6
    };
static const ANTLR3_INT32 dfa119_min[154] =
    {
	6, 4, 6, -1, -1, -1, -1, 7, -1, 4, 4, 6, 4, 4, 6, 6, -1, 6, 6, 6, -1, 4, 
	-1, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 7, 4, 4, 6, 6, 6, 6, 6, 7, 6, 6, 
	6, 6, 6, 4, 4, 4, 7, 4, 6, 4, 4, 4, 6, 7, 6, 6, 6, 7, 4, 6, 6, 4, 7, 6, 
	6, 7, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 7, 4, 4, 4, 7, 6, 
	4, 4, 4, 4, 4, 4, 7, 4, 6, 6, 6, 6, 4, 7, 7, 6, 7, 6, 6, 6, 7, 6, 6, 7, 
	6, 6, 6, 6, 7, 6, 6, 6, 4, 4, 4, 4, 7, 4, 4, 7, 6, 4, 4, 4, 4, 7, 4, 4, 
	6, 4, 4, 4, 4, 7, 4, 6, 4, 7, 7, 4, 4, 4
    };
static const ANTLR3_INT32 dfa119_max[154] =
    {
	38, 38, 38, -1, -1, -1, -1, 38, -1, 38, 38, 38, 38, 38, 38, 38, -1, 38, 
	38, 38, -1, 38, -1, -1, -1, -1, -1, -1, -1, 38, 38, 38, 38, 29, 38, 38, 
	38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 
	38, 38, 38, 29, 38, 38, 38, 29, 38, 38, 38, 38, 29, 38, 38, 29, 38, 38, 
	38, 38, 38, 29, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 29, 38, 38, 38, 
	29, 38, 38, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 38, 29, 29, 38, 
	29, 38, 38, 38, 29, 38, 38, 29, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 
	38, 38, 29, 38, 38, 29, 38, 38, 38, 38, 38, 29, 38, 38, 38, 38, 38, 38, 
	38, 29, 38, 38, 38, 29, 29, 38, 38, 38
    };
static const ANTLR3_INT32 dfa119_accept[154] =
    {
	-1, -1, -1, 1, 1, 1, 2, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 
	1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa119_special[154] =
    {	
	19, 34, 70, -1, -1, -1, -1, 6, -1, 24, 84, 85, 102, 29, 48, 68, -1, 51, 
	103, 38, -1, 25, -1, -1, -1, -1, -1, -1, -1, 7, 21, 57, 46, -1, 53, 15, 
	20, 30, 78, 3, 40, -1, 74, 89, 107, 80, 76, 14, 47, 28, -1, 82, 104, 92, 
	94, 0, 66, -1, 60, 100, 26, -1, 87, 110, 112, 54, -1, 69, 39, -1, 12, 33, 
	62, 36, 115, -1, 44, 42, 63, 45, 77, 22, -1, 10, 13, 18, -1, 23, 50, 99, 
	-1, 71, 55, 59, 95, 37, 64, 1, -1, 35, 49, 8, 91, 81, 11, -1, -1, 108, 
	-1, 61, 101, 27, -1, 111, 113, -1, 31, 79, 4, 41, -1, 75, 72, 43, 67, 83, 
	56, 5, -1, 73, 86, -1, 97, 114, 52, 88, 17, -1, 96, 93, 109, 16, 65, 105, 
	32, -1, 58, 9, 98, -1, -1, 2, 90, 106
    };

/** Used when there is no transition table entry for a particular state */
#define dfa119_T_empty	    NULL

static const ANTLR3_INT32 dfa119_T0[] =
    {
	6, 6, 6, 48, 49, 6, 8, 51, 52, 53, 54, 28, 6, 6, 55, 6, -1, 55, 55, 55, 
	-1, 6, 6, 50, -1, 47, 47, -1, 6, -1, -1, 55, 55, 55, 55
    };static const ANTLR3_INT32 dfa119_T1[] =
    {
	6, 6, 99, 96, 97, 94, 8, 100, 5, 99, 99, 5, 5, 99, 97, 6, -1, 97, 97, 97, 
	-1, 6, 6, 98, -1, 95, 95, -1, 6, -1, -1, 97, 97, 97, 97
    };static const ANTLR3_INT32 dfa119_T2[] =
    {
	6, 6, 5, 44, 45, 7, 8, 5, 5, 5, 5, 5, 12, 14, 18, 6, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 17, 17, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T3[] =
    {
	42, 39, 40, 37, 8, 5, 65, 42, 42, 5, 5, 42, 40, -1, -1, 40, 40, 40, -1, 
	6, 6, 41, -1, 38, 38, -1, -1, -1, -1, 40, 40, 40, 40
    };static const ANTLR3_INT32 dfa119_T4[] =
    {
	121, 118, 119, 116, 8, 5, 130, 121, 121, 5, 5, 121, 119, -1, -1, 119, 119, 
	119, -1, 6, 6, 120, -1, 117, 117, -1, -1, -1, -1, 119, 119, 119, 119
    };static const ANTLR3_INT32 dfa119_T5[] =
    {
	6, 6, 6, 135, 136, 6, 8, 91, 25, 138, 139, 28, -1, 6, 136, 6, -1, 136, 
	136, 136, -1, 6, 6, 137, -1, 134, 134, -1, 6, -1, -1, 136, 136, 136, 136
    };static const ANTLR3_INT32 dfa119_T6[] =
    {
	21, 22, -1, 8, 24, 25, 26, 27, 28, -1, -1, 22, -1, -1, 22, 22, 22, -1, 
	-1, -1, 23, -1, 20, 20, -1, -1, -1, -1, 22, 22, 22, 22
    };static const ANTLR3_INT32 dfa119_T7[] =
    {
	6, 6, 83, 80, 81, 78, 8, 83, 5, 83, 83, 5, 12, 14, 84, 6, -1, 84, 84, 84, 
	-1, 6, 6, 82, -1, 79, 79, -1, 6, -1, -1, 84, 84, 84, 84
    };static const ANTLR3_INT32 dfa119_T8[] =
    {
	6, 6, 6, 72, 70, 6, 8, 73, 25, 76, 77, 28, 6, 6, 74, 6, -1, 74, 74, 74, 
	-1, 6, 6, 75, -1, 71, 71, -1, 6, -1, -1, 74, 74, 74, 74
    };static const ANTLR3_INT32 dfa119_T9[] =
    {
	6, 6, 34, 31, 32, 29, 8, 34, 56, 34, 34, 5, 12, 14, 35, 6, -1, 35, 35, 
	35, -1, 6, 6, 33, -1, 30, 30, -1, 6, -1, -1, 35, 35, 35, 35
    };static const ANTLR3_INT32 dfa119_T10[] =
    {
	5, 2, 3, -1, -1, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, 6, -1, 4, 
	-1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T11[] =
    {
	5, 44, 45, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T12[] =
    {
	101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 101
    };static const ANTLR3_INT32 dfa119_T13[] =
    {
	107, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 107
    };static const ANTLR3_INT32 dfa119_T14[] =
    {
	124, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 124
    };static const ANTLR3_INT32 dfa119_T15[] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 152
    };static const ANTLR3_INT32 dfa119_T16[] =
    {
	153, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 153
    };static const ANTLR3_INT32 dfa119_T17[] =
    {
	125, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 125
    };static const ANTLR3_INT32 dfa119_T18[] =
    {
	126, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 126
    };static const ANTLR3_INT32 dfa119_T19[] =
    {
	129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 129
    };static const ANTLR3_INT32 dfa119_T20[] =
    {
	140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 140
    };static const ANTLR3_INT32 dfa119_T21[] =
    {
	147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 147
    };static const ANTLR3_INT32 dfa119_T22[] =
    {
	6, 6, 6, 88, 89, 6, 8, 91, 25, 92, 93, 28, -1, 6, 89, 6, -1, 89, 89, 89, 
	-1, 6, 6, 90, -1, 87, 87, -1, 6, -1, -1, 89, 89, 89, 89
    };static const ANTLR3_INT32 dfa119_T23[] =
    {
	6, 6, 5, 10, 13, 7, 8, 5, 5, 5, 5, 5, 12, 14, 11, 6, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 9, 9, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T24[] =
    {
	6, 6, -1, 21, 22, -1, 8, 24, 25, 26, 27, 28, 6, 6, 22, 6, -1, 22, 22, 22, 
	-1, -1, -1, 23, -1, 20, 20, -1, 6, -1, -1, 22, 22, 22, 22
    };static const ANTLR3_INT32 dfa119_T25[] =
    {
	6, 59, 60, 6, 8, 24, 62, 63, 64, 28, -1, 6, 60, -1, -1, 60, 60, 60, -1, 
	6, 6, 61, -1, 58, 58, -1, -1, -1, -1, 60, 60, 60, 60
    };static const ANTLR3_INT32 dfa119_T26[] =
    {
	6, 110, 111, 6, 8, 24, 127, 113, 114, 28, -1, 6, 111, -1, -1, 111, 111, 
	111, -1, 6, 6, 112, -1, 109, 109, -1, -1, -1, -1, 111, 111, 111, 111
    };static const ANTLR3_INT32 dfa119_T27[] =
    {
	6, 6, 5, 36, 3, 7, 8, 5, 5, 5, 5, 5, 12, 14, 3, 6, -1, 3, 3, 3, -1, -1, 
	-1, 4, -1, 1, 1, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T28[] =
    {
	6, 6, 146, 143, 144, 141, 8, 100, 5, 146, 146, 5, 5, 146, 144, 6, -1, 144, 
	144, 144, -1, 6, 6, 145, -1, 142, 142, -1, 6, -1, -1, 144, 144, 144, 144
    };static const ANTLR3_INT32 dfa119_T29[] =
    {
	57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 57
    };static const ANTLR3_INT32 dfa119_T30[] =
    {
	69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 69
    };static const ANTLR3_INT32 dfa119_T31[] =
    {
	5, 46, 3, 16, 8, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 4, 
	-1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T32[] =
    {
	5, 103, 3, 16, 8, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T33[] =
    {
	5, 133, 3, 16, 8, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T34[] =
    {
	42, 39, 40, 37, 8, 5, 5, 42, 42, 5, 5, 42, 40, -1, -1, 40, 40, 40, -1, 
	6, 6, 41, -1, 38, 38, -1, -1, -1, -1, 40, 40, 40, 40
    };static const ANTLR3_INT32 dfa119_T35[] =
    {
	121, 118, 119, 116, 8, 5, 5, 121, 121, 5, 5, 121, 119, -1, -1, 119, 119, 
	119, -1, 6, 6, 120, -1, 117, 117, -1, -1, -1, -1, 119, 119, 119, 119
    };static const ANTLR3_INT32 dfa119_T36[] =
    {
	66, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 66
    };static const ANTLR3_INT32 dfa119_T37[] =
    {
	86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 86
    };static const ANTLR3_INT32 dfa119_T38[] =
    {
	105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 105
    };static const ANTLR3_INT32 dfa119_T39[] =
    {
	150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 150
    };static const ANTLR3_INT32 dfa119_T40[] =
    {
	106, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 106
    };static const ANTLR3_INT32 dfa119_T41[] =
    {
	108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 108
    };static const ANTLR3_INT32 dfa119_T42[] =
    {
	115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 115
    };static const ANTLR3_INT32 dfa119_T43[] =
    {
	128, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 128
    };static const ANTLR3_INT32 dfa119_T44[] =
    {
	131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 131
    };static const ANTLR3_INT32 dfa119_T45[] =
    {
	149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 149
    };static const ANTLR3_INT32 dfa119_T46[] =
    {
	83, 80, 81, 78, 8, 83, 5, 83, 83, 5, 5, 5, 84, -1, -1, 84, 84, 84, -1, 
	6, 6, 82, -1, 79, 79, -1, -1, -1, -1, 84, 84, 84, 84
    };static const ANTLR3_INT32 dfa119_T47[] =
    {
	5, 43, 19, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T48[] =
    {
	5, 102, 68, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T49[] =
    {
	5, 15, 19, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T50[] =
    {
	6, 110, 111, 6, 8, 24, 25, 113, 114, 28, -1, 6, 111, -1, -1, 111, 111, 
	111, -1, 6, 6, 112, -1, 109, 109, -1, -1, -1, -1, 111, 111, 111, 111
    };static const ANTLR3_INT32 dfa119_T51[] =
    {
	5, 132, 123, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T52[] =
    {
	5, 67, 68, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T53[] =
    {
	5, 36, 3, 16, 8, 5, 5, 5, 5, 5, 5, 5, 3, -1, -1, 3, 3, 3, -1, -1, -1, 4, 
	-1, 1, 1, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T54[] =
    {
	5, 122, 123, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T55[] =
    {
	5, 10, 3, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 9, 9, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T56[] =
    {
	5, 44, 19, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T57[] =
    {
	5, 44, 68, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T58[] =
    {
	85, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 85
    };static const ANTLR3_INT32 dfa119_T59[] =
    {
	104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 104
    };static const ANTLR3_INT32 dfa119_T60[] =
    {
	5, 44, 123, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T61[] =
    {
	6, 6, 5, 151, 45, 7, 8, 5, 5, 5, 5, 5, 12, 14, 18, 6, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 17, 17, -1, 6, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T62[] =
    {
	6, 6, 34, 31, 32, 29, 8, 34, 5, 34, 34, 5, 12, 14, 35, 6, -1, 35, 35, 35, 
	-1, 6, 6, 33, -1, 30, 30, -1, 6, -1, -1, 35, 35, 35, 35
    };static const ANTLR3_INT32 dfa119_T63[] =
    {
	5, 44, 3, 16, 8, 5, 5, 5, 5, 5, 5, 5, 18, -1, -1, 3, 3, 3, -1, -1, -1, 
	4, -1, 17, 17, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa119_T64[] =
    {
	6, 72, 70, 6, 8, 73, 25, 76, 77, 28, -1, -1, 74, -1, -1, 74, 74, 74, -1, 
	6, 6, 75, -1, 71, 71, -1, -1, -1, -1, 74, 74, 74, 74
    };static const ANTLR3_INT32 dfa119_T65[] =
    {
	6, 6, 5, 148, 45, 7, 8, 5, 5, 5, 5, 5, 12, 14, 18, 6, -1, 3, 3, 3, -1, 
	-1, -1, 4, -1, 17, 17, -1, 6, -1, -1, 3, 3, 3, 3
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa119_transitions[] =
{
    dfa119_T10, dfa119_T23, dfa119_T49, dfa119_T_empty, dfa119_T_empty, 
    dfa119_T_empty, dfa119_T_empty, dfa119_T6, dfa119_T_empty, dfa119_T23, 
    dfa119_T23, dfa119_T55, dfa119_T62, dfa119_T27, dfa119_T34, dfa119_T47, 
    dfa119_T_empty, dfa119_T11, dfa119_T63, dfa119_T31, dfa119_T_empty, 
    dfa119_T24, dfa119_T_empty, dfa119_T_empty, dfa119_T_empty, dfa119_T_empty, 
    dfa119_T_empty, dfa119_T_empty, dfa119_T_empty, dfa119_T0, dfa119_T9, 
    dfa119_T9, dfa119_T9, dfa119_T29, dfa119_T9, dfa119_T9, dfa119_T11, 
    dfa119_T25, dfa119_T3, dfa119_T3, dfa119_T3, dfa119_T36, dfa119_T3, 
    dfa119_T56, dfa119_T11, dfa119_T53, dfa119_T52, dfa119_T0, dfa119_T0, 
    dfa119_T0, dfa119_T30, dfa119_T0, dfa119_T64, dfa119_T0, dfa119_T0, 
    dfa119_T0, dfa119_T46, dfa119_T58, dfa119_T25, dfa119_T25, dfa119_T25, 
    dfa119_T37, dfa119_T22, dfa119_T25, dfa119_T25, dfa119_T1, dfa119_T12, 
    dfa119_T48, dfa119_T32, dfa119_T59, dfa119_T8, dfa119_T8, dfa119_T8, 
    dfa119_T8, dfa119_T8, dfa119_T38, dfa119_T8, dfa119_T8, dfa119_T8, dfa119_T7, 
    dfa119_T7, dfa119_T7, dfa119_T40, dfa119_T7, dfa119_T7, dfa119_T9, dfa119_T13, 
    dfa119_T22, dfa119_T22, dfa119_T22, dfa119_T41, dfa119_T50, dfa119_T22, 
    dfa119_T22, dfa119_T22, dfa119_T1, dfa119_T1, dfa119_T1, dfa119_T42, 
    dfa119_T1, dfa119_T35, dfa119_T3, dfa119_T57, dfa119_T54, dfa119_T0, 
    dfa119_T14, dfa119_T17, dfa119_T25, dfa119_T18, dfa119_T26, dfa119_T26, 
    dfa119_T26, dfa119_T43, dfa119_T26, dfa119_T26, dfa119_T19, dfa119_T26, 
    dfa119_T4, dfa119_T4, dfa119_T4, dfa119_T44, dfa119_T4, dfa119_T51, 
    dfa119_T33, dfa119_T8, dfa119_T7, dfa119_T22, dfa119_T5, dfa119_T20, 
    dfa119_T1, dfa119_T28, dfa119_T21, dfa119_T60, dfa119_T65, dfa119_T5, 
    dfa119_T5, dfa119_T5, dfa119_T45, dfa119_T5, dfa119_T5, dfa119_T26, 
    dfa119_T5, dfa119_T28, dfa119_T28, dfa119_T28, dfa119_T39, dfa119_T28, 
    dfa119_T4, dfa119_T61, dfa119_T15, dfa119_T16, dfa119_T2, dfa119_T5, 
    dfa119_T28	
};

static ANTLR3_INT32 dfa119_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA119_55;

    	    ANTLR3_MARKER index119_55;


    		LA119_55 = LA(1);

    	 
    	    index119_55 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_55 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_55 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_55 >= HEX_CHAR) && (LA119_55 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_55 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_55 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_55 == DASH || ((LA119_55 >= STAR) && (LA119_55 <= RPAREN)) || ((LA119_55 >= USCORE) && (LA119_55 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_55 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_55 == EOF || ((LA119_55 >= CRLF) && (LA119_55 <= SLASH)) || LA119_55 == COLON || ((LA119_55 >= SEMI) && (LA119_55 <= QMARK)) || LA119_55 == DQUOTE || ((LA119_55 >= LSBRAQUET) && (LA119_55 <= RSBRAQUET)) || LA119_55 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_55 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_55 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_55 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_55 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_55);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA119_97;

    	    ANTLR3_MARKER index119_97;


    		LA119_97 = LA(1);

    	 
    	    index119_97 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_97 == COLON) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA119_97 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_97 >= HEX_CHAR) && (LA119_97 <= COMMON_CHAR))) )
    	    {
    	        s = 95;
    	    }

    	    else if ( (LA119_97 == DIGIT) )
    	    {
    	        s = 96;
    	    }

    	    else if ( (LA119_97 == DOT || LA119_97 == DASH || ((LA119_97 >= STAR) && (LA119_97 <= RPAREN)) || ((LA119_97 >= USCORE) && (LA119_97 <= SQUOTE))) )
    	    {
    	        s = 97;
    	    }

    	    else if ( (LA119_97 == PERCENT) )
    	    {
    	        s = 98;
    	    }

    	    else if ( (LA119_97 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_97 == SLASH || ((LA119_97 >= PLUS) && (LA119_97 <= DOLLARD)) || LA119_97 == QMARK) )
    	    {
    	        s = 99;
    	    }

    	    else if ( (LA119_97 == EOF || ((LA119_97 >= CRLF) && (LA119_97 <= SP)) || LA119_97 == DQUOTE || ((LA119_97 >= LSBRAQUET) && (LA119_97 <= RSBRAQUET)) || LA119_97 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_97 == EQUAL || ((LA119_97 >= COMMA) && (LA119_97 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_97);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA119_151;

    	    ANTLR3_MARKER index119_151;


    		LA119_151 = LA(1);

    	 
    	    index119_151 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_151 == COLON) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA119_151 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_151 >= HEX_CHAR) && (LA119_151 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_151 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_151 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_151 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_151 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_151 == DOT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA119_151 == EOF || ((LA119_151 >= CRLF) && (LA119_151 <= SP)) || LA119_151 == DQUOTE || LA119_151 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_151 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_151 == SLASH || ((LA119_151 >= AND) && (LA119_151 <= COMMA))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_151 >= STAR) && (LA119_151 <= RPAREN)) || ((LA119_151 >= USCORE) && (LA119_151 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_151);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA119_39;

    	    ANTLR3_MARKER index119_39;


    		LA119_39 = LA(1);

    	 
    	    index119_39 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_39 == EQUAL) )
    	    {
    	        s = 65;
    	    }

    	    else if ( (LA119_39 == COLON) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (((LA119_39 >= HEX_CHAR) && (LA119_39 <= COMMON_CHAR))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA119_39 == DIGIT) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA119_39 == DOT || LA119_39 == DASH || ((LA119_39 >= STAR) && (LA119_39 <= RPAREN)) || ((LA119_39 >= USCORE) && (LA119_39 <= SQUOTE))) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA119_39 == PERCENT) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA119_39 == SLASH || ((LA119_39 >= PLUS) && (LA119_39 <= DOLLARD)) || LA119_39 == QMARK) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA119_39 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_39 >= LSBRAQUET) && (LA119_39 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_39 == AND || ((LA119_39 >= COMMA) && (LA119_39 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_39);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 4:
        
    	{
    	    ANTLR3_UINT32 LA119_118;

    	    ANTLR3_MARKER index119_118;


    		LA119_118 = LA(1);

    	 
    	    index119_118 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_118 == COLON) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA119_118 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_118 >= HEX_CHAR) && (LA119_118 <= COMMON_CHAR))) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA119_118 == DIGIT) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA119_118 == DOT || LA119_118 == DASH || ((LA119_118 >= STAR) && (LA119_118 <= RPAREN)) || ((LA119_118 >= USCORE) && (LA119_118 <= SQUOTE))) )
    	    {
    	        s = 119;
    	    }

    	    else if ( (LA119_118 == PERCENT) )
    	    {
    	        s = 120;
    	    }

    	    else if ( (LA119_118 == EQUAL) )
    	    {
    	        s = 130;
    	    }

    	    else if ( (LA119_118 == SLASH || ((LA119_118 >= PLUS) && (LA119_118 <= DOLLARD)) || LA119_118 == QMARK) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (LA119_118 == AND || ((LA119_118 >= COMMA) && (LA119_118 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_118 >= LSBRAQUET) && (LA119_118 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_118);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 5:
        
    	{
    	    ANTLR3_UINT32 LA119_127;

    	    ANTLR3_MARKER index119_127;


    		LA119_127 = LA(1);

    	 
    	    index119_127 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_127 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_127 >= HEX_CHAR) && (LA119_127 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_127 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_127 == DOT || LA119_127 == DASH || ((LA119_127 >= STAR) && (LA119_127 <= RPAREN)) || ((LA119_127 >= USCORE) && (LA119_127 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_127 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_127 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_127 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_127 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_127 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_127 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_127 == EOF || ((LA119_127 >= CRLF) && (LA119_127 <= SLASH)) || LA119_127 == COLON || LA119_127 == QMARK || LA119_127 == DQUOTE || ((LA119_127 >= LSBRAQUET) && (LA119_127 <= RSBRAQUET)) || LA119_127 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_127);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 6:
        
    	{
    	    ANTLR3_UINT32 LA119_7;

    	    ANTLR3_MARKER index119_7;


    		LA119_7 = LA(1);

    	 
    	    index119_7 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_7 >= HEX_CHAR) && (LA119_7 <= COMMON_CHAR))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA119_7 == DIGIT) )
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA119_7 == DOT || LA119_7 == DASH || ((LA119_7 >= STAR) && (LA119_7 <= RPAREN)) || ((LA119_7 >= USCORE) && (LA119_7 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 22;
    	    }

    	    else if ( (LA119_7 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 23;
    	    }

    	    else if ( (LA119_7 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_7 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_7 == PLUS) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA119_7 == DOLLARD) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA119_7 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_7 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	 
    		SEEK(index119_7);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 7:
        
    	{
    	    ANTLR3_UINT32 LA119_29;

    	    ANTLR3_MARKER index119_29;


    		LA119_29 = LA(1);

    	 
    	    index119_29 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_29 >= HEX_CHAR) && (LA119_29 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_29 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_29 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (LA119_29 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_29 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_29 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_29 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_29 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_29 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_29 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_29 == DASH || ((LA119_29 >= STAR) && (LA119_29 <= RPAREN)) || ((LA119_29 >= USCORE) && (LA119_29 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_29 == EOF || ((LA119_29 >= CRLF) && (LA119_29 <= SLASH)) || LA119_29 == COLON || ((LA119_29 >= SEMI) && (LA119_29 <= QMARK)) || LA119_29 == DQUOTE || ((LA119_29 >= LSBRAQUET) && (LA119_29 <= RSBRAQUET)) || LA119_29 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_29);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 8:
        
    	{
    	    ANTLR3_UINT32 LA119_101;

    	    ANTLR3_MARKER index119_101;


    		LA119_101 = LA(1);

    	 
    	    index119_101 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_101 == EQUAL) )
    	    {
    	        s = 65;
    	    }

    	    else if ( (LA119_101 == COLON) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (((LA119_101 >= HEX_CHAR) && (LA119_101 <= COMMON_CHAR))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA119_101 == DIGIT) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA119_101 == DOT || LA119_101 == DASH || ((LA119_101 >= STAR) && (LA119_101 <= RPAREN)) || ((LA119_101 >= USCORE) && (LA119_101 <= SQUOTE))) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA119_101 == PERCENT) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA119_101 == SLASH || ((LA119_101 >= PLUS) && (LA119_101 <= DOLLARD)) || LA119_101 == QMARK) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA119_101 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_101 >= LSBRAQUET) && (LA119_101 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_101 == AND || ((LA119_101 >= COMMA) && (LA119_101 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_101);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 9:
        
    	{
    	    ANTLR3_UINT32 LA119_147;

    	    ANTLR3_MARKER index119_147;


    		LA119_147 = LA(1);

    	 
    	    index119_147 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_147 == COLON) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA119_147 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_147 >= HEX_CHAR) && (LA119_147 <= COMMON_CHAR))) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA119_147 == DIGIT) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA119_147 == DOT || LA119_147 == DASH || ((LA119_147 >= STAR) && (LA119_147 <= RPAREN)) || ((LA119_147 >= USCORE) && (LA119_147 <= SQUOTE))) )
    	    {
    	        s = 119;
    	    }

    	    else if ( (LA119_147 == PERCENT) )
    	    {
    	        s = 120;
    	    }

    	    else if ( (LA119_147 == EQUAL) )
    	    {
    	        s = 130;
    	    }

    	    else if ( (LA119_147 == SLASH || ((LA119_147 >= PLUS) && (LA119_147 <= DOLLARD)) || LA119_147 == QMARK) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (LA119_147 == AND || ((LA119_147 >= COMMA) && (LA119_147 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_147 >= LSBRAQUET) && (LA119_147 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_147);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 10:
        
    	{
    	    ANTLR3_UINT32 LA119_83;

    	    ANTLR3_MARKER index119_83;


    		LA119_83 = LA(1);

    	 
    	    index119_83 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_83 == COLON) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA119_83 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_83 >= HEX_CHAR) && (LA119_83 <= COMMON_CHAR))) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA119_83 == DIGIT) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA119_83 == DOT) )
    	    {
    	        s = 81;
    	    }

    	    else if ( (LA119_83 == PERCENT) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA119_83 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_83 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_83 == EOF || ((LA119_83 >= CRLF) && (LA119_83 <= SP)) || LA119_83 == DQUOTE || ((LA119_83 >= LSBRAQUET) && (LA119_83 <= RSBRAQUET)) || LA119_83 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_83 == SLASH || LA119_83 == AND || ((LA119_83 >= PLUS) && (LA119_83 <= DOLLARD))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA119_83 == DASH || ((LA119_83 >= STAR) && (LA119_83 <= RPAREN)) || ((LA119_83 >= USCORE) && (LA119_83 <= SQUOTE))) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA119_83 == EQUAL || LA119_83 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_83);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 11:
        
    	{
    	    ANTLR3_UINT32 LA119_104;

    	    ANTLR3_MARKER index119_104;


    		LA119_104 = LA(1);

    	 
    	    index119_104 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_104 == EOF || ((LA119_104 >= CRLF) && (LA119_104 <= SLASH)) || LA119_104 == COLON || ((LA119_104 >= SEMI) && (LA119_104 <= QMARK)) || LA119_104 == DQUOTE || ((LA119_104 >= LSBRAQUET) && (LA119_104 <= RSBRAQUET)) || LA119_104 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_104 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_104 >= HEX_CHAR) && (LA119_104 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_104 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_104 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_104 == DASH || ((LA119_104 >= STAR) && (LA119_104 <= RPAREN)) || ((LA119_104 >= USCORE) && (LA119_104 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_104 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_104 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_104 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_104 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_104 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_104 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_104);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 12:
        
    	{
    	    ANTLR3_UINT32 LA119_70;

    	    ANTLR3_MARKER index119_70;


    		LA119_70 = LA(1);

    	 
    	    index119_70 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_70 == EOF || ((LA119_70 >= CRLF) && (LA119_70 <= SLASH)) || LA119_70 == COLON || ((LA119_70 >= SEMI) && (LA119_70 <= QMARK)) || LA119_70 == DQUOTE || ((LA119_70 >= LSBRAQUET) && (LA119_70 <= RSBRAQUET)) || LA119_70 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_70 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_70 >= HEX_CHAR) && (LA119_70 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_70 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_70 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_70 == DASH || ((LA119_70 >= STAR) && (LA119_70 <= RPAREN)) || ((LA119_70 >= USCORE) && (LA119_70 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_70 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_70 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_70 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_70 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_70 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_70 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_70);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 13:
        
    	{
    	    ANTLR3_UINT32 LA119_84;

    	    ANTLR3_MARKER index119_84;


    		LA119_84 = LA(1);

    	 
    	    index119_84 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_84 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_84 == EOF || ((LA119_84 >= CRLF) && (LA119_84 <= SP)) || LA119_84 == DQUOTE || ((LA119_84 >= LSBRAQUET) && (LA119_84 <= RSBRAQUET)) || LA119_84 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_84 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_84 == DOT) )
    	    {
    	        s = 81;
    	    }

    	    else if ( (((LA119_84 >= HEX_CHAR) && (LA119_84 <= COMMON_CHAR))) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA119_84 == DIGIT) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA119_84 == COLON) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA119_84 == DASH || ((LA119_84 >= STAR) && (LA119_84 <= RPAREN)) || ((LA119_84 >= USCORE) && (LA119_84 <= SQUOTE))) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA119_84 == PERCENT) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA119_84 == SLASH || LA119_84 == AND || ((LA119_84 >= PLUS) && (LA119_84 <= DOLLARD))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA119_84 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_84 == EQUAL || LA119_84 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_84);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 14:
        
    	{
    	    ANTLR3_UINT32 LA119_47;

    	    ANTLR3_MARKER index119_47;


    		LA119_47 = LA(1);

    	 
    	    index119_47 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_47 == EOF || ((LA119_47 >= CRLF) && (LA119_47 <= SLASH)) || LA119_47 == COLON || ((LA119_47 >= SEMI) && (LA119_47 <= QMARK)) || LA119_47 == DQUOTE || ((LA119_47 >= LSBRAQUET) && (LA119_47 <= RSBRAQUET)) || LA119_47 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_47 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_47 >= HEX_CHAR) && (LA119_47 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_47 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_47 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_47 == DASH || ((LA119_47 >= STAR) && (LA119_47 <= RPAREN)) || ((LA119_47 >= USCORE) && (LA119_47 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_47 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_47 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_47 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_47 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_47 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_47 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_47);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 15:
        
    	{
    	    ANTLR3_UINT32 LA119_35;

    	    ANTLR3_MARKER index119_35;


    		LA119_35 = LA(1);

    	 
    	    index119_35 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_35 == EQUAL) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA119_35 == DOT) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (((LA119_35 >= HEX_CHAR) && (LA119_35 <= COMMON_CHAR))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA119_35 == DIGIT) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA119_35 == COLON) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA119_35 == DASH || ((LA119_35 >= STAR) && (LA119_35 <= RPAREN)) || ((LA119_35 >= USCORE) && (LA119_35 <= SQUOTE))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA119_35 == PERCENT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA119_35 == SLASH || LA119_35 == AND || ((LA119_35 >= PLUS) && (LA119_35 <= DOLLARD))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA119_35 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_35 == EOF || ((LA119_35 >= CRLF) && (LA119_35 <= SP)) || LA119_35 == DQUOTE || ((LA119_35 >= LSBRAQUET) && (LA119_35 <= RSBRAQUET)) || LA119_35 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_35 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_35 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_35 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_35);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 16:
        
    	{
    	    ANTLR3_UINT32 LA119_141;

    	    ANTLR3_MARKER index119_141;


    		LA119_141 = LA(1);

    	 
    	    index119_141 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_141 >= HEX_CHAR) && (LA119_141 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_141 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_141 == DOT || LA119_141 == DASH || ((LA119_141 >= STAR) && (LA119_141 <= RPAREN)) || ((LA119_141 >= USCORE) && (LA119_141 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_141 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_141 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_141 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_141 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_141 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_141 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_141 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_141 == EOF || ((LA119_141 >= CRLF) && (LA119_141 <= SLASH)) || LA119_141 == COLON || LA119_141 == QMARK || LA119_141 == DQUOTE || ((LA119_141 >= LSBRAQUET) && (LA119_141 <= RSBRAQUET)) || LA119_141 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_141);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 17:
        
    	{
    	    ANTLR3_UINT32 LA119_136;

    	    ANTLR3_MARKER index119_136;


    		LA119_136 = LA(1);

    	 
    	    index119_136 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_136 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_136 >= HEX_CHAR) && (LA119_136 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_136 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_136 == DOT || LA119_136 == DASH || ((LA119_136 >= STAR) && (LA119_136 <= RPAREN)) || ((LA119_136 >= USCORE) && (LA119_136 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_136 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_136 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_136 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_136 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_136 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_136 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_136 == EOF || ((LA119_136 >= CRLF) && (LA119_136 <= SLASH)) || LA119_136 == COLON || LA119_136 == QMARK || LA119_136 == DQUOTE || ((LA119_136 >= LSBRAQUET) && (LA119_136 <= RSBRAQUET)) || LA119_136 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_136);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 18:
        
    	{
    	    ANTLR3_UINT32 LA119_85;

    	    ANTLR3_MARKER index119_85;


    		LA119_85 = LA(1);

    	 
    	    index119_85 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_85 == COLON) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA119_85 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_85 >= HEX_CHAR) && (LA119_85 <= COMMON_CHAR))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA119_85 == DIGIT) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA119_85 == DOT) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA119_85 == PERCENT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA119_85 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_85 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_85 == EOF || ((LA119_85 >= CRLF) && (LA119_85 <= SP)) || LA119_85 == DQUOTE || ((LA119_85 >= LSBRAQUET) && (LA119_85 <= RSBRAQUET)) || LA119_85 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_85 == SLASH || LA119_85 == AND || ((LA119_85 >= PLUS) && (LA119_85 <= DOLLARD))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA119_85 == DASH || ((LA119_85 >= STAR) && (LA119_85 <= RPAREN)) || ((LA119_85 >= USCORE) && (LA119_85 <= SQUOTE))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA119_85 == EQUAL) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA119_85 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_85);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 19:
        
    	{
    	    ANTLR3_UINT32 LA119_0;

    	    ANTLR3_MARKER index119_0;


    		LA119_0 = LA(1);

    	 
    	    index119_0 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_0 >= HEX_CHAR) && (LA119_0 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA119_0 == DIGIT) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (LA119_0 == DOT || LA119_0 == DASH || ((LA119_0 >= STAR) && (LA119_0 <= RPAREN)) || ((LA119_0 >= USCORE) && (LA119_0 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_0 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_0 == SLASH || ((LA119_0 >= AND) && (LA119_0 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_0 == LSBRAQUET) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_0);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 20:
        
    	{
    	    ANTLR3_UINT32 LA119_36;

    	    ANTLR3_MARKER index119_36;


    		LA119_36 = LA(1);

    	 
    	    index119_36 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_36 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_36 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_36 >= HEX_CHAR) && (LA119_36 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_36 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_36 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_36 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_36 == SLASH || ((LA119_36 >= AND) && (LA119_36 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_36 == DOT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (((LA119_36 >= STAR) && (LA119_36 <= RPAREN)) || ((LA119_36 >= USCORE) && (LA119_36 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_36);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 21:
        
    	{
    	    ANTLR3_UINT32 LA119_30;

    	    ANTLR3_MARKER index119_30;


    		LA119_30 = LA(1);

    	 
    	    index119_30 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_30 == COLON) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA119_30 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_30 >= HEX_CHAR) && (LA119_30 <= COMMON_CHAR))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA119_30 == DIGIT) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA119_30 == DOT) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA119_30 == PERCENT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA119_30 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_30 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_30 == EOF || ((LA119_30 >= CRLF) && (LA119_30 <= SP)) || LA119_30 == DQUOTE || ((LA119_30 >= LSBRAQUET) && (LA119_30 <= RSBRAQUET)) || LA119_30 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_30 == SLASH || LA119_30 == AND || ((LA119_30 >= PLUS) && (LA119_30 <= DOLLARD))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA119_30 == DASH || ((LA119_30 >= STAR) && (LA119_30 <= RPAREN)) || ((LA119_30 >= USCORE) && (LA119_30 <= SQUOTE))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA119_30 == EQUAL) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA119_30 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_30);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 22:
        
    	{
    	    ANTLR3_UINT32 LA119_81;

    	    ANTLR3_MARKER index119_81;


    		LA119_81 = LA(1);

    	 
    	    index119_81 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_81 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_81 == EOF || ((LA119_81 >= CRLF) && (LA119_81 <= SP)) || LA119_81 == DQUOTE || ((LA119_81 >= LSBRAQUET) && (LA119_81 <= RSBRAQUET)) || LA119_81 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_81 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_81 == DOT) )
    	    {
    	        s = 81;
    	    }

    	    else if ( (((LA119_81 >= HEX_CHAR) && (LA119_81 <= COMMON_CHAR))) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA119_81 == DIGIT) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA119_81 == COLON) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA119_81 == DASH || ((LA119_81 >= STAR) && (LA119_81 <= RPAREN)) || ((LA119_81 >= USCORE) && (LA119_81 <= SQUOTE))) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA119_81 == PERCENT) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA119_81 == SLASH || LA119_81 == AND || ((LA119_81 >= PLUS) && (LA119_81 <= DOLLARD))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA119_81 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_81 == EQUAL || LA119_81 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_81);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 23:
        
    	{
    	    ANTLR3_UINT32 LA119_87;

    	    ANTLR3_MARKER index119_87;


    		LA119_87 = LA(1);

    	 
    	    index119_87 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_87 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_87 == EOF || ((LA119_87 >= CRLF) && (LA119_87 <= SLASH)) || LA119_87 == COLON || LA119_87 == QMARK || LA119_87 == DQUOTE || ((LA119_87 >= LSBRAQUET) && (LA119_87 <= RSBRAQUET)) || LA119_87 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_87 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (((LA119_87 >= HEX_CHAR) && (LA119_87 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_87 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_87 == DOT || LA119_87 == DASH || ((LA119_87 >= STAR) && (LA119_87 <= RPAREN)) || ((LA119_87 >= USCORE) && (LA119_87 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_87 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_87 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_87 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_87 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_87 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_87);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 24:
        
    	{
    	    ANTLR3_UINT32 LA119_9;

    	    ANTLR3_MARKER index119_9;


    		LA119_9 = LA(1);

    	 
    	    index119_9 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_9 == COLON) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA119_9 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_9 >= HEX_CHAR) && (LA119_9 <= COMMON_CHAR))) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA119_9 == DIGIT) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA119_9 == DASH) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA119_9 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_9 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_9 == DOT) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (((LA119_9 >= STAR) && (LA119_9 <= RPAREN)) || ((LA119_9 >= USCORE) && (LA119_9 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_9 == EOF || ((LA119_9 >= CRLF) && (LA119_9 <= SP)) || LA119_9 == DQUOTE || LA119_9 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_9 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_9 == SLASH || ((LA119_9 >= AND) && (LA119_9 <= COMMA))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_9);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 25:
        
    	{
    	    ANTLR3_UINT32 LA119_21;

    	    ANTLR3_MARKER index119_21;


    		LA119_21 = LA(1);

    	 
    	    index119_21 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_21 == EOF || ((LA119_21 >= CRLF) && (LA119_21 <= SP)) || ((LA119_21 >= SEMI) && (LA119_21 <= QMARK)) || LA119_21 == DQUOTE || LA119_21 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_21 == DIGIT) )
    	    {
    	        s = 21;
    	    }

    	    else if ( (LA119_21 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_21 >= HEX_CHAR) && (LA119_21 <= COMMON_CHAR))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 20;
    	    }

    	    else if ( (LA119_21 == DOT || LA119_21 == DASH || ((LA119_21 >= STAR) && (LA119_21 <= RPAREN)) || ((LA119_21 >= USCORE) && (LA119_21 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 22;
    	    }

    	    else if ( (LA119_21 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 23;
    	    }

    	    else if ( (LA119_21 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_21 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_21 == PLUS) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 26;
    	    }

    	    else if ( (LA119_21 == DOLLARD) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA119_21 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_21);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 26:
        
    	{
    	    ANTLR3_UINT32 LA119_60;

    	    ANTLR3_MARKER index119_60;


    		LA119_60 = LA(1);

    	 
    	    index119_60 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_60 == EQUAL) )
    	    {
    	        s = 62;
    	    }

    	    else if ( (LA119_60 == PLUS) )
    	    {
    	        s = 63;
    	    }

    	    else if ( (((LA119_60 >= HEX_CHAR) && (LA119_60 <= COMMON_CHAR))) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA119_60 == DIGIT) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA119_60 == DOT || LA119_60 == DASH || ((LA119_60 >= STAR) && (LA119_60 <= RPAREN)) || ((LA119_60 >= USCORE) && (LA119_60 <= SQUOTE))) )
    	    {
    	        s = 60;
    	    }

    	    else if ( (LA119_60 == PERCENT) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA119_60 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_60 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_60 == DOLLARD) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA119_60 == SLASH || LA119_60 == COLON || LA119_60 == QMARK || ((LA119_60 >= LSBRAQUET) && (LA119_60 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_60 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_60);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 27:
        
    	{
    	    ANTLR3_UINT32 LA119_111;

    	    ANTLR3_MARKER index119_111;


    		LA119_111 = LA(1);

    	 
    	    index119_111 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_111 == EQUAL) )
    	    {
    	        s = 127;
    	    }

    	    else if ( (LA119_111 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA119_111 >= HEX_CHAR) && (LA119_111 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_111 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_111 == DOT || LA119_111 == DASH || ((LA119_111 >= STAR) && (LA119_111 <= RPAREN)) || ((LA119_111 >= USCORE) && (LA119_111 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_111 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_111 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_111 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_111 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_111 == SLASH || LA119_111 == COLON || LA119_111 == QMARK || ((LA119_111 >= LSBRAQUET) && (LA119_111 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_111 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_111);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 28:
        
    	{
    	    ANTLR3_UINT32 LA119_49;

    	    ANTLR3_MARKER index119_49;


    		LA119_49 = LA(1);

    	 
    	    index119_49 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_49 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_49 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_49 >= HEX_CHAR) && (LA119_49 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_49 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_49 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_49 == DASH || ((LA119_49 >= STAR) && (LA119_49 <= RPAREN)) || ((LA119_49 >= USCORE) && (LA119_49 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_49 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_49 == EOF || ((LA119_49 >= CRLF) && (LA119_49 <= SLASH)) || LA119_49 == COLON || ((LA119_49 >= SEMI) && (LA119_49 <= QMARK)) || LA119_49 == DQUOTE || ((LA119_49 >= LSBRAQUET) && (LA119_49 <= RSBRAQUET)) || LA119_49 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_49 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_49 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_49 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_49 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_49);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 29:
        
    	{
    	    ANTLR3_UINT32 LA119_13;

    	    ANTLR3_MARKER index119_13;


    		LA119_13 = LA(1);

    	 
    	    index119_13 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_13 == COLON) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA119_13 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_13 >= HEX_CHAR) && (LA119_13 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA119_13 == DIGIT) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA119_13 == DOT || LA119_13 == DASH || ((LA119_13 >= STAR) && (LA119_13 <= RPAREN)) || ((LA119_13 >= USCORE) && (LA119_13 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_13 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_13 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_13 == EOF || ((LA119_13 >= CRLF) && (LA119_13 <= SP)) || LA119_13 == DQUOTE || LA119_13 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_13 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_13 == SLASH || ((LA119_13 >= AND) && (LA119_13 <= COMMA))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_13);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 30:
        
    	{
    	    ANTLR3_UINT32 LA119_37;

    	    ANTLR3_MARKER index119_37;


    		LA119_37 = LA(1);

    	 
    	    index119_37 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_37 >= HEX_CHAR) && (LA119_37 <= COMMON_CHAR))) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA119_37 == DIGIT) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA119_37 == DOT || LA119_37 == DASH || ((LA119_37 >= STAR) && (LA119_37 <= RPAREN)) || ((LA119_37 >= USCORE) && (LA119_37 <= SQUOTE))) )
    	    {
    	        s = 60;
    	    }

    	    else if ( (LA119_37 == PERCENT) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA119_37 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_37 == EQUAL) )
    	    {
    	        s = 62;
    	    }

    	    else if ( (LA119_37 == PLUS) )
    	    {
    	        s = 63;
    	    }

    	    else if ( (LA119_37 == DOLLARD) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA119_37 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_37 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_37 == SLASH || LA119_37 == COLON || LA119_37 == QMARK || ((LA119_37 >= LSBRAQUET) && (LA119_37 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_37);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 31:
        
    	{
    	    ANTLR3_UINT32 LA119_116;

    	    ANTLR3_MARKER index119_116;


    		LA119_116 = LA(1);

    	 
    	    index119_116 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_116 >= HEX_CHAR) && (LA119_116 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_116 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_116 == DOT || LA119_116 == DASH || ((LA119_116 >= STAR) && (LA119_116 <= RPAREN)) || ((LA119_116 >= USCORE) && (LA119_116 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_116 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_116 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_116 == EQUAL) )
    	    {
    	        s = 127;
    	    }

    	    else if ( (LA119_116 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (LA119_116 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_116 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_116 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_116 == SLASH || LA119_116 == COLON || LA119_116 == QMARK || ((LA119_116 >= LSBRAQUET) && (LA119_116 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_116);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 32:
        
    	{
    	    ANTLR3_UINT32 LA119_144;

    	    ANTLR3_MARKER index119_144;


    		LA119_144 = LA(1);

    	 
    	    index119_144 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_144 == COLON) )
    	    {
    	        s = 141;
    	    }

    	    else if ( (LA119_144 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_144 >= HEX_CHAR) && (LA119_144 <= COMMON_CHAR))) )
    	    {
    	        s = 142;
    	    }

    	    else if ( (LA119_144 == DIGIT) )
    	    {
    	        s = 143;
    	    }

    	    else if ( (LA119_144 == DOT || LA119_144 == DASH || ((LA119_144 >= STAR) && (LA119_144 <= RPAREN)) || ((LA119_144 >= USCORE) && (LA119_144 <= SQUOTE))) )
    	    {
    	        s = 144;
    	    }

    	    else if ( (LA119_144 == PERCENT) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA119_144 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_144 == EOF || ((LA119_144 >= CRLF) && (LA119_144 <= SP)) || LA119_144 == DQUOTE || ((LA119_144 >= LSBRAQUET) && (LA119_144 <= RSBRAQUET)) || LA119_144 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_144 == SLASH || ((LA119_144 >= PLUS) && (LA119_144 <= DOLLARD)) || LA119_144 == QMARK) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA119_144 == EQUAL || ((LA119_144 >= COMMA) && (LA119_144 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_144);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 33:
        
    	{
    	    ANTLR3_UINT32 LA119_71;

    	    ANTLR3_MARKER index119_71;


    		LA119_71 = LA(1);

    	 
    	    index119_71 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_71 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_71 >= HEX_CHAR) && (LA119_71 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_71 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_71 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA119_71 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_71 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_71 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_71 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_71 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_71 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_71 == EOF || ((LA119_71 >= CRLF) && (LA119_71 <= SLASH)) || LA119_71 == COLON || ((LA119_71 >= SEMI) && (LA119_71 <= QMARK)) || LA119_71 == DQUOTE || ((LA119_71 >= LSBRAQUET) && (LA119_71 <= RSBRAQUET)) || LA119_71 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_71 == DASH || ((LA119_71 >= STAR) && (LA119_71 <= RPAREN)) || ((LA119_71 >= USCORE) && (LA119_71 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	 
    		SEEK(index119_71);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 34:
        
    	{
    	    ANTLR3_UINT32 LA119_1;

    	    ANTLR3_MARKER index119_1;


    		LA119_1 = LA(1);

    	 
    	    index119_1 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_1 == COLON) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA119_1 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_1 >= HEX_CHAR) && (LA119_1 <= COMMON_CHAR))) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA119_1 == DIGIT) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA119_1 == DASH) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA119_1 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_1 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_1 == DOT) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (((LA119_1 >= STAR) && (LA119_1 <= RPAREN)) || ((LA119_1 >= USCORE) && (LA119_1 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_1 == EOF || ((LA119_1 >= CRLF) && (LA119_1 <= SP)) || LA119_1 == DQUOTE || LA119_1 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_1 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_1 == SLASH || ((LA119_1 >= AND) && (LA119_1 <= COMMA))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_1);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 35:
        
    	{
    	    ANTLR3_UINT32 LA119_99;

    	    ANTLR3_MARKER index119_99;


    		LA119_99 = LA(1);

    	 
    	    index119_99 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_99 == COLON) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA119_99 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_99 >= HEX_CHAR) && (LA119_99 <= COMMON_CHAR))) )
    	    {
    	        s = 95;
    	    }

    	    else if ( (LA119_99 == DIGIT) )
    	    {
    	        s = 96;
    	    }

    	    else if ( (LA119_99 == DOT || LA119_99 == DASH || ((LA119_99 >= STAR) && (LA119_99 <= RPAREN)) || ((LA119_99 >= USCORE) && (LA119_99 <= SQUOTE))) )
    	    {
    	        s = 97;
    	    }

    	    else if ( (LA119_99 == PERCENT) )
    	    {
    	        s = 98;
    	    }

    	    else if ( (LA119_99 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_99 == SLASH || ((LA119_99 >= PLUS) && (LA119_99 <= DOLLARD)) || LA119_99 == QMARK) )
    	    {
    	        s = 99;
    	    }

    	    else if ( (LA119_99 == EOF || ((LA119_99 >= CRLF) && (LA119_99 <= SP)) || LA119_99 == DQUOTE || ((LA119_99 >= LSBRAQUET) && (LA119_99 <= RSBRAQUET)) || LA119_99 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_99 == EQUAL || ((LA119_99 >= COMMA) && (LA119_99 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_99);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 36:
        
    	{
    	    ANTLR3_UINT32 LA119_73;

    	    ANTLR3_MARKER index119_73;


    		LA119_73 = LA(1);

    	 
    	    index119_73 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_73 == EOF || ((LA119_73 >= CRLF) && (LA119_73 <= SLASH)) || LA119_73 == COLON || ((LA119_73 >= SEMI) && (LA119_73 <= QMARK)) || LA119_73 == DQUOTE || ((LA119_73 >= LSBRAQUET) && (LA119_73 <= RSBRAQUET)) || LA119_73 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_73 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_73 >= HEX_CHAR) && (LA119_73 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_73 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_73 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_73 == DASH || ((LA119_73 >= STAR) && (LA119_73 <= RPAREN)) || ((LA119_73 >= USCORE) && (LA119_73 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_73 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_73 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_73 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_73 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_73 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_73 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_73);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 37:
        
    	{
    	    ANTLR3_UINT32 LA119_95;

    	    ANTLR3_MARKER index119_95;


    		LA119_95 = LA(1);

    	 
    	    index119_95 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_95 == COLON) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA119_95 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_95 >= HEX_CHAR) && (LA119_95 <= COMMON_CHAR))) )
    	    {
    	        s = 95;
    	    }

    	    else if ( (LA119_95 == DIGIT) )
    	    {
    	        s = 96;
    	    }

    	    else if ( (LA119_95 == DOT || LA119_95 == DASH || ((LA119_95 >= STAR) && (LA119_95 <= RPAREN)) || ((LA119_95 >= USCORE) && (LA119_95 <= SQUOTE))) )
    	    {
    	        s = 97;
    	    }

    	    else if ( (LA119_95 == PERCENT) )
    	    {
    	        s = 98;
    	    }

    	    else if ( (LA119_95 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_95 == SLASH || ((LA119_95 >= PLUS) && (LA119_95 <= DOLLARD)) || LA119_95 == QMARK) )
    	    {
    	        s = 99;
    	    }

    	    else if ( (LA119_95 == EOF || ((LA119_95 >= CRLF) && (LA119_95 <= SP)) || LA119_95 == DQUOTE || ((LA119_95 >= LSBRAQUET) && (LA119_95 <= RSBRAQUET)) || LA119_95 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_95 == EQUAL || ((LA119_95 >= COMMA) && (LA119_95 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_95);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 38:
        
    	{
    	    ANTLR3_UINT32 LA119_19;

    	    ANTLR3_MARKER index119_19;


    		LA119_19 = LA(1);

    	 
    	    index119_19 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_19 == DIGIT) )
    	    {
    	        s = 46;
    	    }

    	    else if ( (LA119_19 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_19 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_19 >= HEX_CHAR) && (LA119_19 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA119_19 == DOT || LA119_19 == DASH || ((LA119_19 >= STAR) && (LA119_19 <= RPAREN)) || ((LA119_19 >= USCORE) && (LA119_19 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_19 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_19 == SLASH || ((LA119_19 >= AND) && (LA119_19 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_19);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 39:
        
    	{
    	    ANTLR3_UINT32 LA119_68;

    	    ANTLR3_MARKER index119_68;


    		LA119_68 = LA(1);

    	 
    	    index119_68 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_68 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_68 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_68 >= HEX_CHAR) && (LA119_68 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA119_68 == DIGIT) )
    	    {
    	        s = 103;
    	    }

    	    else if ( (LA119_68 == DOT || LA119_68 == DASH || ((LA119_68 >= STAR) && (LA119_68 <= RPAREN)) || ((LA119_68 >= USCORE) && (LA119_68 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_68 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_68 == SLASH || ((LA119_68 >= AND) && (LA119_68 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_68);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 40:
        
    	{
    	    ANTLR3_UINT32 LA119_40;

    	    ANTLR3_MARKER index119_40;


    		LA119_40 = LA(1);

    	 
    	    index119_40 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_40 == EQUAL) )
    	    {
    	        s = 65;
    	    }

    	    else if ( (LA119_40 == COLON) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (((LA119_40 >= HEX_CHAR) && (LA119_40 <= COMMON_CHAR))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA119_40 == DIGIT) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA119_40 == DOT || LA119_40 == DASH || ((LA119_40 >= STAR) && (LA119_40 <= RPAREN)) || ((LA119_40 >= USCORE) && (LA119_40 <= SQUOTE))) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA119_40 == PERCENT) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA119_40 == SLASH || ((LA119_40 >= PLUS) && (LA119_40 <= DOLLARD)) || LA119_40 == QMARK) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA119_40 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_40 >= LSBRAQUET) && (LA119_40 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_40 == AND || ((LA119_40 >= COMMA) && (LA119_40 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_40);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 41:
        
    	{
    	    ANTLR3_UINT32 LA119_119;

    	    ANTLR3_MARKER index119_119;


    		LA119_119 = LA(1);

    	 
    	    index119_119 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_119 == COLON) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA119_119 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_119 >= HEX_CHAR) && (LA119_119 <= COMMON_CHAR))) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA119_119 == DIGIT) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA119_119 == DOT || LA119_119 == DASH || ((LA119_119 >= STAR) && (LA119_119 <= RPAREN)) || ((LA119_119 >= USCORE) && (LA119_119 <= SQUOTE))) )
    	    {
    	        s = 119;
    	    }

    	    else if ( (LA119_119 == PERCENT) )
    	    {
    	        s = 120;
    	    }

    	    else if ( (LA119_119 == EQUAL) )
    	    {
    	        s = 130;
    	    }

    	    else if ( (LA119_119 == SLASH || ((LA119_119 >= PLUS) && (LA119_119 <= DOLLARD)) || LA119_119 == QMARK) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (LA119_119 == AND || ((LA119_119 >= COMMA) && (LA119_119 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_119 >= LSBRAQUET) && (LA119_119 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_119);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 42:
        
    	{
    	    ANTLR3_UINT32 LA119_77;

    	    ANTLR3_MARKER index119_77;


    		LA119_77 = LA(1);

    	 
    	    index119_77 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_77 == EOF || ((LA119_77 >= CRLF) && (LA119_77 <= SLASH)) || LA119_77 == COLON || ((LA119_77 >= SEMI) && (LA119_77 <= QMARK)) || LA119_77 == DQUOTE || ((LA119_77 >= LSBRAQUET) && (LA119_77 <= RSBRAQUET)) || LA119_77 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_77 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_77 >= HEX_CHAR) && (LA119_77 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_77 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_77 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_77 == DASH || ((LA119_77 >= STAR) && (LA119_77 <= RPAREN)) || ((LA119_77 >= USCORE) && (LA119_77 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_77 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_77 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_77 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_77 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_77 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_77 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_77);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 43:
        
    	{
    	    ANTLR3_UINT32 LA119_123;

    	    ANTLR3_MARKER index119_123;


    		LA119_123 = LA(1);

    	 
    	    index119_123 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_123 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_123 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_123 >= HEX_CHAR) && (LA119_123 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA119_123 == DIGIT) )
    	    {
    	        s = 133;
    	    }

    	    else if ( (LA119_123 == DOT || LA119_123 == DASH || ((LA119_123 >= STAR) && (LA119_123 <= RPAREN)) || ((LA119_123 >= USCORE) && (LA119_123 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_123 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_123 == SLASH || ((LA119_123 >= AND) && (LA119_123 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_123);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 44:
        
    	{
    	    ANTLR3_UINT32 LA119_76;

    	    ANTLR3_MARKER index119_76;


    		LA119_76 = LA(1);

    	 
    	    index119_76 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_76 == EOF || ((LA119_76 >= CRLF) && (LA119_76 <= SLASH)) || LA119_76 == COLON || ((LA119_76 >= SEMI) && (LA119_76 <= QMARK)) || LA119_76 == DQUOTE || ((LA119_76 >= LSBRAQUET) && (LA119_76 <= RSBRAQUET)) || LA119_76 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_76 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_76 >= HEX_CHAR) && (LA119_76 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_76 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_76 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_76 == DASH || ((LA119_76 >= STAR) && (LA119_76 <= RPAREN)) || ((LA119_76 >= USCORE) && (LA119_76 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_76 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_76 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_76 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_76 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_76 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_76 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_76);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 45:
        
    	{
    	    ANTLR3_UINT32 LA119_79;

    	    ANTLR3_MARKER index119_79;


    		LA119_79 = LA(1);

    	 
    	    index119_79 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_79 == COLON) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA119_79 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_79 >= HEX_CHAR) && (LA119_79 <= COMMON_CHAR))) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA119_79 == DIGIT) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA119_79 == DOT) )
    	    {
    	        s = 81;
    	    }

    	    else if ( (LA119_79 == PERCENT) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA119_79 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_79 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_79 == EOF || ((LA119_79 >= CRLF) && (LA119_79 <= SP)) || LA119_79 == DQUOTE || ((LA119_79 >= LSBRAQUET) && (LA119_79 <= RSBRAQUET)) || LA119_79 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_79 == SLASH || LA119_79 == AND || ((LA119_79 >= PLUS) && (LA119_79 <= DOLLARD))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA119_79 == DASH || ((LA119_79 >= STAR) && (LA119_79 <= RPAREN)) || ((LA119_79 >= USCORE) && (LA119_79 <= SQUOTE))) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA119_79 == EQUAL || LA119_79 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_79);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 46:
        
    	{
    	    ANTLR3_UINT32 LA119_32;

    	    ANTLR3_MARKER index119_32;


    		LA119_32 = LA(1);

    	 
    	    index119_32 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_32 == EQUAL) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA119_32 == DOT) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (((LA119_32 >= HEX_CHAR) && (LA119_32 <= COMMON_CHAR))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA119_32 == DIGIT) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA119_32 == COLON) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA119_32 == DASH || ((LA119_32 >= STAR) && (LA119_32 <= RPAREN)) || ((LA119_32 >= USCORE) && (LA119_32 <= SQUOTE))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA119_32 == PERCENT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA119_32 == SLASH || LA119_32 == AND || ((LA119_32 >= PLUS) && (LA119_32 <= DOLLARD))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA119_32 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_32 == EOF || ((LA119_32 >= CRLF) && (LA119_32 <= SP)) || LA119_32 == DQUOTE || ((LA119_32 >= LSBRAQUET) && (LA119_32 <= RSBRAQUET)) || LA119_32 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_32 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_32 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_32 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_32);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 47:
        
    	{
    	    ANTLR3_UINT32 LA119_48;

    	    ANTLR3_MARKER index119_48;


    		LA119_48 = LA(1);

    	 
    	    index119_48 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_48 == EOF || ((LA119_48 >= CRLF) && (LA119_48 <= SLASH)) || LA119_48 == COLON || ((LA119_48 >= SEMI) && (LA119_48 <= QMARK)) || LA119_48 == DQUOTE || ((LA119_48 >= LSBRAQUET) && (LA119_48 <= RSBRAQUET)) || LA119_48 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_48 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_48 >= HEX_CHAR) && (LA119_48 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_48 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_48 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_48 == DASH || ((LA119_48 >= STAR) && (LA119_48 <= RPAREN)) || ((LA119_48 >= USCORE) && (LA119_48 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_48 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_48 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_48 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_48 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_48 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_48 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_48);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 48:
        
    	{
    	    ANTLR3_UINT32 LA119_14;

    	    ANTLR3_MARKER index119_14;


    		LA119_14 = LA(1);

    	 
    	    index119_14 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_14 == COLON) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA119_14 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_14 >= HEX_CHAR) && (LA119_14 <= COMMON_CHAR))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA119_14 == DIGIT) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA119_14 == DOT || LA119_14 == DASH || ((LA119_14 >= STAR) && (LA119_14 <= RPAREN)) || ((LA119_14 >= USCORE) && (LA119_14 <= SQUOTE))) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA119_14 == PERCENT) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA119_14 == SLASH || ((LA119_14 >= PLUS) && (LA119_14 <= DOLLARD)) || LA119_14 == QMARK) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (((LA119_14 >= AND) && (LA119_14 <= EQUAL)) || ((LA119_14 >= COMMA) && (LA119_14 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_14 >= LSBRAQUET) && (LA119_14 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_14);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 49:
        
    	{
    	    ANTLR3_UINT32 LA119_100;

    	    ANTLR3_MARKER index119_100;


    		LA119_100 = LA(1);

    	 
    	    index119_100 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_100 == COLON) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA119_100 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_100 >= HEX_CHAR) && (LA119_100 <= COMMON_CHAR))) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA119_100 == DIGIT) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA119_100 == DOT || LA119_100 == DASH || ((LA119_100 >= STAR) && (LA119_100 <= RPAREN)) || ((LA119_100 >= USCORE) && (LA119_100 <= SQUOTE))) )
    	    {
    	        s = 119;
    	    }

    	    else if ( (LA119_100 == PERCENT) )
    	    {
    	        s = 120;
    	    }

    	    else if ( (LA119_100 == SLASH || ((LA119_100 >= PLUS) && (LA119_100 <= DOLLARD)) || LA119_100 == QMARK) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (((LA119_100 >= AND) && (LA119_100 <= EQUAL)) || ((LA119_100 >= COMMA) && (LA119_100 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_100 >= LSBRAQUET) && (LA119_100 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_100);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 50:
        
    	{
    	    ANTLR3_UINT32 LA119_88;

    	    ANTLR3_MARKER index119_88;


    		LA119_88 = LA(1);

    	 
    	    index119_88 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_88 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_88 == EOF || ((LA119_88 >= CRLF) && (LA119_88 <= SLASH)) || LA119_88 == COLON || LA119_88 == QMARK || LA119_88 == DQUOTE || ((LA119_88 >= LSBRAQUET) && (LA119_88 <= RSBRAQUET)) || LA119_88 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_88 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (((LA119_88 >= HEX_CHAR) && (LA119_88 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_88 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_88 == DOT || LA119_88 == DASH || ((LA119_88 >= STAR) && (LA119_88 <= RPAREN)) || ((LA119_88 >= USCORE) && (LA119_88 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_88 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_88 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_88 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_88 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_88 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_88);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 51:
        
    	{
    	    ANTLR3_UINT32 LA119_17;

    	    ANTLR3_MARKER index119_17;


    		LA119_17 = LA(1);

    	 
    	    index119_17 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_17 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_17 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_17 >= HEX_CHAR) && (LA119_17 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_17 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_17 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_17 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_17 == SLASH || ((LA119_17 >= AND) && (LA119_17 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_17 == DOT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (((LA119_17 >= STAR) && (LA119_17 <= RPAREN)) || ((LA119_17 >= USCORE) && (LA119_17 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_17);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 52:
        
    	{
    	    ANTLR3_UINT32 LA119_134;

    	    ANTLR3_MARKER index119_134;


    		LA119_134 = LA(1);

    	 
    	    index119_134 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_134 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_134 >= HEX_CHAR) && (LA119_134 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_134 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_134 == DOT || LA119_134 == DASH || ((LA119_134 >= STAR) && (LA119_134 <= RPAREN)) || ((LA119_134 >= USCORE) && (LA119_134 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_134 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_134 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_134 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_134 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_134 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_134 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_134 == EOF || ((LA119_134 >= CRLF) && (LA119_134 <= SLASH)) || LA119_134 == COLON || LA119_134 == QMARK || LA119_134 == DQUOTE || ((LA119_134 >= LSBRAQUET) && (LA119_134 <= RSBRAQUET)) || LA119_134 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_134);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 53:
        
    	{
    	    ANTLR3_UINT32 LA119_34;

    	    ANTLR3_MARKER index119_34;


    		LA119_34 = LA(1);

    	 
    	    index119_34 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_34 == COLON) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA119_34 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_34 >= HEX_CHAR) && (LA119_34 <= COMMON_CHAR))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA119_34 == DIGIT) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA119_34 == DOT) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA119_34 == PERCENT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA119_34 == EQUAL) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA119_34 == SLASH || LA119_34 == AND || ((LA119_34 >= PLUS) && (LA119_34 <= DOLLARD))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA119_34 == DASH || ((LA119_34 >= STAR) && (LA119_34 <= RPAREN)) || ((LA119_34 >= USCORE) && (LA119_34 <= SQUOTE))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA119_34 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_34 == EOF || ((LA119_34 >= CRLF) && (LA119_34 <= SP)) || LA119_34 == DQUOTE || ((LA119_34 >= LSBRAQUET) && (LA119_34 <= RSBRAQUET)) || LA119_34 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_34 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_34 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_34);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 54:
        
    	{
    	    ANTLR3_UINT32 LA119_65;

    	    ANTLR3_MARKER index119_65;


    		LA119_65 = LA(1);

    	 
    	    index119_65 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_65 == COLON) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA119_65 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_65 >= HEX_CHAR) && (LA119_65 <= COMMON_CHAR))) )
    	    {
    	        s = 95;
    	    }

    	    else if ( (LA119_65 == DIGIT) )
    	    {
    	        s = 96;
    	    }

    	    else if ( (LA119_65 == DOT || LA119_65 == DASH || ((LA119_65 >= STAR) && (LA119_65 <= RPAREN)) || ((LA119_65 >= USCORE) && (LA119_65 <= SQUOTE))) )
    	    {
    	        s = 97;
    	    }

    	    else if ( (LA119_65 == PERCENT) )
    	    {
    	        s = 98;
    	    }

    	    else if ( (LA119_65 == SLASH || ((LA119_65 >= PLUS) && (LA119_65 <= DOLLARD)) || LA119_65 == QMARK) )
    	    {
    	        s = 99;
    	    }

    	    else if ( (LA119_65 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_65 == EOF || ((LA119_65 >= CRLF) && (LA119_65 <= SP)) || LA119_65 == DQUOTE || ((LA119_65 >= LSBRAQUET) && (LA119_65 <= RSBRAQUET)) || LA119_65 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_65 == EQUAL || ((LA119_65 >= COMMA) && (LA119_65 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_65);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 55:
        
    	{
    	    ANTLR3_UINT32 LA119_92;

    	    ANTLR3_MARKER index119_92;


    		LA119_92 = LA(1);

    	 
    	    index119_92 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_92 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_92 == EOF || ((LA119_92 >= CRLF) && (LA119_92 <= SLASH)) || LA119_92 == COLON || LA119_92 == QMARK || LA119_92 == DQUOTE || ((LA119_92 >= LSBRAQUET) && (LA119_92 <= RSBRAQUET)) || LA119_92 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_92 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (((LA119_92 >= HEX_CHAR) && (LA119_92 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_92 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_92 == DOT || LA119_92 == DASH || ((LA119_92 >= STAR) && (LA119_92 <= RPAREN)) || ((LA119_92 >= USCORE) && (LA119_92 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_92 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_92 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_92 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_92 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_92 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_92);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 56:
        
    	{
    	    ANTLR3_UINT32 LA119_126;

    	    ANTLR3_MARKER index119_126;


    		LA119_126 = LA(1);

    	 
    	    index119_126 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_126 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_126 == EOF || ((LA119_126 >= CRLF) && (LA119_126 <= SLASH)) || LA119_126 == COLON || LA119_126 == QMARK || LA119_126 == DQUOTE || ((LA119_126 >= LSBRAQUET) && (LA119_126 <= RSBRAQUET)) || LA119_126 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_126 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (((LA119_126 >= HEX_CHAR) && (LA119_126 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_126 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_126 == DOT || LA119_126 == DASH || ((LA119_126 >= STAR) && (LA119_126 <= RPAREN)) || ((LA119_126 >= USCORE) && (LA119_126 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_126 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_126 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_126 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_126 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_126 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_126);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 57:
        
    	{
    	    ANTLR3_UINT32 LA119_31;

    	    ANTLR3_MARKER index119_31;


    		LA119_31 = LA(1);

    	 
    	    index119_31 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_31 == COLON) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA119_31 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_31 >= HEX_CHAR) && (LA119_31 <= COMMON_CHAR))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA119_31 == DIGIT) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA119_31 == DOT) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA119_31 == PERCENT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA119_31 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_31 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_31 == EOF || ((LA119_31 >= CRLF) && (LA119_31 <= SP)) || LA119_31 == DQUOTE || ((LA119_31 >= LSBRAQUET) && (LA119_31 <= RSBRAQUET)) || LA119_31 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_31 == SLASH || LA119_31 == AND || ((LA119_31 >= PLUS) && (LA119_31 <= DOLLARD))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA119_31 == DASH || ((LA119_31 >= STAR) && (LA119_31 <= RPAREN)) || ((LA119_31 >= USCORE) && (LA119_31 <= SQUOTE))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA119_31 == EQUAL) )
    	    {
    	        s = 56;
    	    }

    	    else if ( (LA119_31 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_31);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 58:
        
    	{
    	    ANTLR3_UINT32 LA119_146;

    	    ANTLR3_MARKER index119_146;


    		LA119_146 = LA(1);

    	 
    	    index119_146 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_146 == COLON) )
    	    {
    	        s = 141;
    	    }

    	    else if ( (LA119_146 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_146 >= HEX_CHAR) && (LA119_146 <= COMMON_CHAR))) )
    	    {
    	        s = 142;
    	    }

    	    else if ( (LA119_146 == DIGIT) )
    	    {
    	        s = 143;
    	    }

    	    else if ( (LA119_146 == DOT || LA119_146 == DASH || ((LA119_146 >= STAR) && (LA119_146 <= RPAREN)) || ((LA119_146 >= USCORE) && (LA119_146 <= SQUOTE))) )
    	    {
    	        s = 144;
    	    }

    	    else if ( (LA119_146 == PERCENT) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA119_146 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_146 == EOF || ((LA119_146 >= CRLF) && (LA119_146 <= SP)) || LA119_146 == DQUOTE || ((LA119_146 >= LSBRAQUET) && (LA119_146 <= RSBRAQUET)) || LA119_146 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_146 == SLASH || ((LA119_146 >= PLUS) && (LA119_146 <= DOLLARD)) || LA119_146 == QMARK) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA119_146 == EQUAL || ((LA119_146 >= COMMA) && (LA119_146 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_146);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 59:
        
    	{
    	    ANTLR3_UINT32 LA119_93;

    	    ANTLR3_MARKER index119_93;


    		LA119_93 = LA(1);

    	 
    	    index119_93 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_93 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_93 == EOF || ((LA119_93 >= CRLF) && (LA119_93 <= SLASH)) || LA119_93 == COLON || LA119_93 == QMARK || LA119_93 == DQUOTE || ((LA119_93 >= LSBRAQUET) && (LA119_93 <= RSBRAQUET)) || LA119_93 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_93 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (((LA119_93 >= HEX_CHAR) && (LA119_93 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_93 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_93 == DOT || LA119_93 == DASH || ((LA119_93 >= STAR) && (LA119_93 <= RPAREN)) || ((LA119_93 >= USCORE) && (LA119_93 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_93 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_93 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_93 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_93 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_93 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_93);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 60:
        
    	{
    	    ANTLR3_UINT32 LA119_58;

    	    ANTLR3_MARKER index119_58;


    		LA119_58 = LA(1);

    	 
    	    index119_58 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_58 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_58 >= HEX_CHAR) && (LA119_58 <= COMMON_CHAR))) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA119_58 == DIGIT) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA119_58 == DOT || LA119_58 == DASH || ((LA119_58 >= STAR) && (LA119_58 <= RPAREN)) || ((LA119_58 >= USCORE) && (LA119_58 <= SQUOTE))) )
    	    {
    	        s = 60;
    	    }

    	    else if ( (LA119_58 == PERCENT) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA119_58 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_58 == EQUAL) )
    	    {
    	        s = 62;
    	    }

    	    else if ( (LA119_58 == PLUS) )
    	    {
    	        s = 63;
    	    }

    	    else if ( (LA119_58 == DOLLARD) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA119_58 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_58 == SLASH || LA119_58 == COLON || LA119_58 == QMARK || ((LA119_58 >= LSBRAQUET) && (LA119_58 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_58);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 61:
        
    	{
    	    ANTLR3_UINT32 LA119_109;

    	    ANTLR3_MARKER index119_109;


    		LA119_109 = LA(1);

    	 
    	    index119_109 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_109 == EQUAL) )
    	    {
    	        s = 127;
    	    }

    	    else if ( (LA119_109 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA119_109 >= HEX_CHAR) && (LA119_109 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_109 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_109 == DOT || LA119_109 == DASH || ((LA119_109 >= STAR) && (LA119_109 <= RPAREN)) || ((LA119_109 >= USCORE) && (LA119_109 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_109 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_109 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_109 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_109 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_109 == SLASH || LA119_109 == COLON || LA119_109 == QMARK || ((LA119_109 >= LSBRAQUET) && (LA119_109 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_109 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_109);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 62:
        
    	{
    	    ANTLR3_UINT32 LA119_72;

    	    ANTLR3_MARKER index119_72;


    		LA119_72 = LA(1);

    	 
    	    index119_72 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_72 == EOF || ((LA119_72 >= CRLF) && (LA119_72 <= SLASH)) || LA119_72 == COLON || ((LA119_72 >= SEMI) && (LA119_72 <= QMARK)) || LA119_72 == DQUOTE || ((LA119_72 >= LSBRAQUET) && (LA119_72 <= RSBRAQUET)) || LA119_72 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_72 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_72 >= HEX_CHAR) && (LA119_72 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_72 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_72 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_72 == DASH || ((LA119_72 >= STAR) && (LA119_72 <= RPAREN)) || ((LA119_72 >= USCORE) && (LA119_72 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_72 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_72 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_72 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_72 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_72 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_72 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_72);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 63:
        
    	{
    	    ANTLR3_UINT32 LA119_78;

    	    ANTLR3_MARKER index119_78;


    		LA119_78 = LA(1);

    	 
    	    index119_78 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_78 >= HEX_CHAR) && (LA119_78 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_78 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_78 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (LA119_78 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_78 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_78 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_78 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_78 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_78 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_78 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_78 == EOF || ((LA119_78 >= CRLF) && (LA119_78 <= SLASH)) || LA119_78 == COLON || ((LA119_78 >= SEMI) && (LA119_78 <= QMARK)) || LA119_78 == DQUOTE || ((LA119_78 >= LSBRAQUET) && (LA119_78 <= RSBRAQUET)) || LA119_78 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_78 == DASH || ((LA119_78 >= STAR) && (LA119_78 <= RPAREN)) || ((LA119_78 >= USCORE) && (LA119_78 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	 
    		SEEK(index119_78);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 64:
        
    	{
    	    ANTLR3_UINT32 LA119_96;

    	    ANTLR3_MARKER index119_96;


    		LA119_96 = LA(1);

    	 
    	    index119_96 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_96 == COLON) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA119_96 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_96 >= HEX_CHAR) && (LA119_96 <= COMMON_CHAR))) )
    	    {
    	        s = 95;
    	    }

    	    else if ( (LA119_96 == DIGIT) )
    	    {
    	        s = 96;
    	    }

    	    else if ( (LA119_96 == DOT || LA119_96 == DASH || ((LA119_96 >= STAR) && (LA119_96 <= RPAREN)) || ((LA119_96 >= USCORE) && (LA119_96 <= SQUOTE))) )
    	    {
    	        s = 97;
    	    }

    	    else if ( (LA119_96 == PERCENT) )
    	    {
    	        s = 98;
    	    }

    	    else if ( (LA119_96 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_96 == SLASH || ((LA119_96 >= PLUS) && (LA119_96 <= DOLLARD)) || LA119_96 == QMARK) )
    	    {
    	        s = 99;
    	    }

    	    else if ( (LA119_96 == EOF || ((LA119_96 >= CRLF) && (LA119_96 <= SP)) || LA119_96 == DQUOTE || ((LA119_96 >= LSBRAQUET) && (LA119_96 <= RSBRAQUET)) || LA119_96 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_96 == EQUAL || ((LA119_96 >= COMMA) && (LA119_96 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_96);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 65:
        
    	{
    	    ANTLR3_UINT32 LA119_142;

    	    ANTLR3_MARKER index119_142;


    		LA119_142 = LA(1);

    	 
    	    index119_142 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_142 == COLON) )
    	    {
    	        s = 141;
    	    }

    	    else if ( (LA119_142 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_142 >= HEX_CHAR) && (LA119_142 <= COMMON_CHAR))) )
    	    {
    	        s = 142;
    	    }

    	    else if ( (LA119_142 == DIGIT) )
    	    {
    	        s = 143;
    	    }

    	    else if ( (LA119_142 == DOT || LA119_142 == DASH || ((LA119_142 >= STAR) && (LA119_142 <= RPAREN)) || ((LA119_142 >= USCORE) && (LA119_142 <= SQUOTE))) )
    	    {
    	        s = 144;
    	    }

    	    else if ( (LA119_142 == PERCENT) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA119_142 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_142 == EOF || ((LA119_142 >= CRLF) && (LA119_142 <= SP)) || LA119_142 == DQUOTE || ((LA119_142 >= LSBRAQUET) && (LA119_142 <= RSBRAQUET)) || LA119_142 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_142 == SLASH || ((LA119_142 >= PLUS) && (LA119_142 <= DOLLARD)) || LA119_142 == QMARK) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA119_142 == EQUAL || ((LA119_142 >= COMMA) && (LA119_142 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_142);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 66:
        
    	{
    	    ANTLR3_UINT32 LA119_56;

    	    ANTLR3_MARKER index119_56;


    		LA119_56 = LA(1);

    	 
    	    index119_56 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_56 == COLON) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA119_56 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_56 >= HEX_CHAR) && (LA119_56 <= COMMON_CHAR))) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA119_56 == DIGIT) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA119_56 == DOT) )
    	    {
    	        s = 81;
    	    }

    	    else if ( (LA119_56 == PERCENT) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA119_56 == SLASH || LA119_56 == AND || ((LA119_56 >= PLUS) && (LA119_56 <= DOLLARD))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA119_56 == DASH || ((LA119_56 >= STAR) && (LA119_56 <= RPAREN)) || ((LA119_56 >= USCORE) && (LA119_56 <= SQUOTE))) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA119_56 == EQUAL || ((LA119_56 >= COMMA) && (LA119_56 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_56 >= LSBRAQUET) && (LA119_56 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_56);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 67:
        
    	{
    	    ANTLR3_UINT32 LA119_124;

    	    ANTLR3_MARKER index119_124;


    		LA119_124 = LA(1);

    	 
    	    index119_124 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_124 == EOF || ((LA119_124 >= CRLF) && (LA119_124 <= SLASH)) || LA119_124 == COLON || ((LA119_124 >= SEMI) && (LA119_124 <= QMARK)) || LA119_124 == DQUOTE || ((LA119_124 >= LSBRAQUET) && (LA119_124 <= RSBRAQUET)) || LA119_124 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_124 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_124 >= HEX_CHAR) && (LA119_124 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_124 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_124 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_124 == DASH || ((LA119_124 >= STAR) && (LA119_124 <= RPAREN)) || ((LA119_124 >= USCORE) && (LA119_124 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_124 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_124 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_124 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_124 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_124 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_124 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_124);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 68:
        
    	{
    	    ANTLR3_UINT32 LA119_15;

    	    ANTLR3_MARKER index119_15;


    		LA119_15 = LA(1);

    	 
    	    index119_15 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_15 == DIGIT) )
    	    {
    	        s = 43;
    	    }

    	    else if ( (LA119_15 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_15 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_15 >= HEX_CHAR) && (LA119_15 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_15 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_15 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_15 == SLASH || ((LA119_15 >= AND) && (LA119_15 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_15 == DOT) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (((LA119_15 >= STAR) && (LA119_15 <= RPAREN)) || ((LA119_15 >= USCORE) && (LA119_15 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_15);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 69:
        
    	{
    	    ANTLR3_UINT32 LA119_67;

    	    ANTLR3_MARKER index119_67;


    		LA119_67 = LA(1);

    	 
    	    index119_67 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_67 == DIGIT) )
    	    {
    	        s = 102;
    	    }

    	    else if ( (LA119_67 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_67 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_67 >= HEX_CHAR) && (LA119_67 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_67 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_67 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_67 == SLASH || ((LA119_67 >= AND) && (LA119_67 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_67 == DOT) )
    	    {
    	        s = 68;
    	    }

    	    else if ( (((LA119_67 >= STAR) && (LA119_67 <= RPAREN)) || ((LA119_67 >= USCORE) && (LA119_67 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_67);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 70:
        
    	{
    	    ANTLR3_UINT32 LA119_2;

    	    ANTLR3_MARKER index119_2;


    		LA119_2 = LA(1);

    	 
    	    index119_2 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_2 == DIGIT) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA119_2 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_2 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_2 >= HEX_CHAR) && (LA119_2 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_2 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_2 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_2 == SLASH || ((LA119_2 >= AND) && (LA119_2 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_2 == DOT) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (((LA119_2 >= STAR) && (LA119_2 <= RPAREN)) || ((LA119_2 >= USCORE) && (LA119_2 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_2);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 71:
        
    	{
    	    ANTLR3_UINT32 LA119_91;

    	    ANTLR3_MARKER index119_91;


    		LA119_91 = LA(1);

    	 
    	    index119_91 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_91 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_91 >= HEX_CHAR) && (LA119_91 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_91 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_91 == DOT || LA119_91 == DASH || ((LA119_91 >= STAR) && (LA119_91 <= RPAREN)) || ((LA119_91 >= USCORE) && (LA119_91 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_91 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_91 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_91 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_91 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (LA119_91 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_91 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_91 == SLASH || LA119_91 == COLON || LA119_91 == QMARK || ((LA119_91 >= LSBRAQUET) && (LA119_91 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_91);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 72:
        
    	{
    	    ANTLR3_UINT32 LA119_122;

    	    ANTLR3_MARKER index119_122;


    		LA119_122 = LA(1);

    	 
    	    index119_122 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_122 == DIGIT) )
    	    {
    	        s = 132;
    	    }

    	    else if ( (LA119_122 == DOT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (LA119_122 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_122 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_122 >= HEX_CHAR) && (LA119_122 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_122 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_122 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_122 == SLASH || ((LA119_122 >= AND) && (LA119_122 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_122 >= STAR) && (LA119_122 <= RPAREN)) || ((LA119_122 >= USCORE) && (LA119_122 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_122);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 73:
        
    	{
    	    ANTLR3_UINT32 LA119_129;

    	    ANTLR3_MARKER index119_129;


    		LA119_129 = LA(1);

    	 
    	    index119_129 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_129 == COLON) )
    	    {
    	        s = 94;
    	    }

    	    else if ( (LA119_129 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_129 >= HEX_CHAR) && (LA119_129 <= COMMON_CHAR))) )
    	    {
    	        s = 95;
    	    }

    	    else if ( (LA119_129 == DIGIT) )
    	    {
    	        s = 96;
    	    }

    	    else if ( (LA119_129 == DOT || LA119_129 == DASH || ((LA119_129 >= STAR) && (LA119_129 <= RPAREN)) || ((LA119_129 >= USCORE) && (LA119_129 <= SQUOTE))) )
    	    {
    	        s = 97;
    	    }

    	    else if ( (LA119_129 == PERCENT) )
    	    {
    	        s = 98;
    	    }

    	    else if ( (LA119_129 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_129 == SLASH || ((LA119_129 >= PLUS) && (LA119_129 <= DOLLARD)) || LA119_129 == QMARK) )
    	    {
    	        s = 99;
    	    }

    	    else if ( (LA119_129 == EOF || ((LA119_129 >= CRLF) && (LA119_129 <= SP)) || LA119_129 == DQUOTE || ((LA119_129 >= LSBRAQUET) && (LA119_129 <= RSBRAQUET)) || LA119_129 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_129 == EQUAL || ((LA119_129 >= COMMA) && (LA119_129 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_129);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 74:
        
    	{
    	    ANTLR3_UINT32 LA119_42;

    	    ANTLR3_MARKER index119_42;


    		LA119_42 = LA(1);

    	 
    	    index119_42 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_42 == COLON) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA119_42 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_42 >= HEX_CHAR) && (LA119_42 <= COMMON_CHAR))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA119_42 == DIGIT) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA119_42 == DOT || LA119_42 == DASH || ((LA119_42 >= STAR) && (LA119_42 <= RPAREN)) || ((LA119_42 >= USCORE) && (LA119_42 <= SQUOTE))) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA119_42 == PERCENT) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA119_42 == EQUAL) )
    	    {
    	        s = 65;
    	    }

    	    else if ( (LA119_42 == SLASH || ((LA119_42 >= PLUS) && (LA119_42 <= DOLLARD)) || LA119_42 == QMARK) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA119_42 == AND || ((LA119_42 >= COMMA) && (LA119_42 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_42 >= LSBRAQUET) && (LA119_42 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_42);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 75:
        
    	{
    	    ANTLR3_UINT32 LA119_121;

    	    ANTLR3_MARKER index119_121;


    		LA119_121 = LA(1);

    	 
    	    index119_121 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_121 == COLON) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA119_121 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_121 >= HEX_CHAR) && (LA119_121 <= COMMON_CHAR))) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA119_121 == DIGIT) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA119_121 == DOT || LA119_121 == DASH || ((LA119_121 >= STAR) && (LA119_121 <= RPAREN)) || ((LA119_121 >= USCORE) && (LA119_121 <= SQUOTE))) )
    	    {
    	        s = 119;
    	    }

    	    else if ( (LA119_121 == PERCENT) )
    	    {
    	        s = 120;
    	    }

    	    else if ( (LA119_121 == EQUAL) )
    	    {
    	        s = 130;
    	    }

    	    else if ( (LA119_121 == SLASH || ((LA119_121 >= PLUS) && (LA119_121 <= DOLLARD)) || LA119_121 == QMARK) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (LA119_121 == AND || ((LA119_121 >= COMMA) && (LA119_121 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_121 >= LSBRAQUET) && (LA119_121 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_121);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 76:
        
    	{
    	    ANTLR3_UINT32 LA119_46;

    	    ANTLR3_MARKER index119_46;


    		LA119_46 = LA(1);

    	 
    	    index119_46 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_46 == DIGIT) )
    	    {
    	        s = 67;
    	    }

    	    else if ( (LA119_46 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_46 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_46 >= HEX_CHAR) && (LA119_46 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_46 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_46 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_46 == SLASH || ((LA119_46 >= AND) && (LA119_46 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_46 == DOT) )
    	    {
    	        s = 68;
    	    }

    	    else if ( (((LA119_46 >= STAR) && (LA119_46 <= RPAREN)) || ((LA119_46 >= USCORE) && (LA119_46 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_46);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 77:
        
    	{
    	    ANTLR3_UINT32 LA119_80;

    	    ANTLR3_MARKER index119_80;


    		LA119_80 = LA(1);

    	 
    	    index119_80 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_80 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_80 == EOF || ((LA119_80 >= CRLF) && (LA119_80 <= SP)) || LA119_80 == DQUOTE || ((LA119_80 >= LSBRAQUET) && (LA119_80 <= RSBRAQUET)) || LA119_80 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_80 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_80 == DOT) )
    	    {
    	        s = 81;
    	    }

    	    else if ( (((LA119_80 >= HEX_CHAR) && (LA119_80 <= COMMON_CHAR))) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA119_80 == DIGIT) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA119_80 == COLON) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA119_80 == DASH || ((LA119_80 >= STAR) && (LA119_80 <= RPAREN)) || ((LA119_80 >= USCORE) && (LA119_80 <= SQUOTE))) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA119_80 == PERCENT) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA119_80 == SLASH || LA119_80 == AND || ((LA119_80 >= PLUS) && (LA119_80 <= DOLLARD))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA119_80 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_80 == EQUAL || LA119_80 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_80);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 78:
        
    	{
    	    ANTLR3_UINT32 LA119_38;

    	    ANTLR3_MARKER index119_38;


    		LA119_38 = LA(1);

    	 
    	    index119_38 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_38 == COLON) )
    	    {
    	        s = 37;
    	    }

    	    else if ( (LA119_38 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_38 >= HEX_CHAR) && (LA119_38 <= COMMON_CHAR))) )
    	    {
    	        s = 38;
    	    }

    	    else if ( (LA119_38 == DIGIT) )
    	    {
    	        s = 39;
    	    }

    	    else if ( (LA119_38 == DOT || LA119_38 == DASH || ((LA119_38 >= STAR) && (LA119_38 <= RPAREN)) || ((LA119_38 >= USCORE) && (LA119_38 <= SQUOTE))) )
    	    {
    	        s = 40;
    	    }

    	    else if ( (LA119_38 == PERCENT) )
    	    {
    	        s = 41;
    	    }

    	    else if ( (LA119_38 == EQUAL) )
    	    {
    	        s = 65;
    	    }

    	    else if ( (LA119_38 == SLASH || ((LA119_38 >= PLUS) && (LA119_38 <= DOLLARD)) || LA119_38 == QMARK) )
    	    {
    	        s = 42;
    	    }

    	    else if ( (LA119_38 == AND || ((LA119_38 >= COMMA) && (LA119_38 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_38 >= LSBRAQUET) && (LA119_38 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_38);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 79:
        
    	{
    	    ANTLR3_UINT32 LA119_117;

    	    ANTLR3_MARKER index119_117;


    		LA119_117 = LA(1);

    	 
    	    index119_117 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_117 == COLON) )
    	    {
    	        s = 116;
    	    }

    	    else if ( (LA119_117 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_117 >= HEX_CHAR) && (LA119_117 <= COMMON_CHAR))) )
    	    {
    	        s = 117;
    	    }

    	    else if ( (LA119_117 == DIGIT) )
    	    {
    	        s = 118;
    	    }

    	    else if ( (LA119_117 == DOT || LA119_117 == DASH || ((LA119_117 >= STAR) && (LA119_117 <= RPAREN)) || ((LA119_117 >= USCORE) && (LA119_117 <= SQUOTE))) )
    	    {
    	        s = 119;
    	    }

    	    else if ( (LA119_117 == PERCENT) )
    	    {
    	        s = 120;
    	    }

    	    else if ( (LA119_117 == EQUAL) )
    	    {
    	        s = 130;
    	    }

    	    else if ( (LA119_117 == SLASH || ((LA119_117 >= PLUS) && (LA119_117 <= DOLLARD)) || LA119_117 == QMARK) )
    	    {
    	        s = 121;
    	    }

    	    else if ( (LA119_117 == AND || ((LA119_117 >= COMMA) && (LA119_117 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_117 >= LSBRAQUET) && (LA119_117 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_117);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 80:
        
    	{
    	    ANTLR3_UINT32 LA119_45;

    	    ANTLR3_MARKER index119_45;


    		LA119_45 = LA(1);

    	 
    	    index119_45 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_45 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_45 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_45 >= HEX_CHAR) && (LA119_45 <= COMMON_CHAR))) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA119_45 == DIGIT) )
    	    {
    	        s = 36;
    	    }

    	    else if ( (LA119_45 == DOT || LA119_45 == DASH || ((LA119_45 >= STAR) && (LA119_45 <= RPAREN)) || ((LA119_45 >= USCORE) && (LA119_45 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_45 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_45 == SLASH || ((LA119_45 >= AND) && (LA119_45 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_45);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 81:
        
    	{
    	    ANTLR3_UINT32 LA119_103;

    	    ANTLR3_MARKER index119_103;


    		LA119_103 = LA(1);

    	 
    	    index119_103 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_103 == DIGIT) )
    	    {
    	        s = 122;
    	    }

    	    else if ( (LA119_103 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_103 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_103 >= HEX_CHAR) && (LA119_103 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_103 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_103 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_103 == SLASH || ((LA119_103 >= AND) && (LA119_103 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_103 == DOT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (((LA119_103 >= STAR) && (LA119_103 <= RPAREN)) || ((LA119_103 >= USCORE) && (LA119_103 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_103);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 82:
        
    	{
    	    ANTLR3_UINT32 LA119_51;

    	    ANTLR3_MARKER index119_51;


    		LA119_51 = LA(1);

    	 
    	    index119_51 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_51 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_51 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_51 >= HEX_CHAR) && (LA119_51 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_51 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_51 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_51 == DASH || ((LA119_51 >= STAR) && (LA119_51 <= RPAREN)) || ((LA119_51 >= USCORE) && (LA119_51 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_51 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_51 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_51 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_51 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_51 == EOF || ((LA119_51 >= CRLF) && (LA119_51 <= SLASH)) || LA119_51 == COLON || ((LA119_51 >= SEMI) && (LA119_51 <= QMARK)) || LA119_51 == DQUOTE || ((LA119_51 >= LSBRAQUET) && (LA119_51 <= RSBRAQUET)) || LA119_51 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_51 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_51);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 83:
        
    	{
    	    ANTLR3_UINT32 LA119_125;

    	    ANTLR3_MARKER index119_125;


    		LA119_125 = LA(1);

    	 
    	    index119_125 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_125 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_125 == EOF || ((LA119_125 >= CRLF) && (LA119_125 <= SP)) || LA119_125 == DQUOTE || ((LA119_125 >= LSBRAQUET) && (LA119_125 <= RSBRAQUET)) || LA119_125 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_125 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_125 == DOT) )
    	    {
    	        s = 81;
    	    }

    	    else if ( (((LA119_125 >= HEX_CHAR) && (LA119_125 <= COMMON_CHAR))) )
    	    {
    	        s = 79;
    	    }

    	    else if ( (LA119_125 == DIGIT) )
    	    {
    	        s = 80;
    	    }

    	    else if ( (LA119_125 == COLON) )
    	    {
    	        s = 78;
    	    }

    	    else if ( (LA119_125 == DASH || ((LA119_125 >= STAR) && (LA119_125 <= RPAREN)) || ((LA119_125 >= USCORE) && (LA119_125 <= SQUOTE))) )
    	    {
    	        s = 84;
    	    }

    	    else if ( (LA119_125 == PERCENT) )
    	    {
    	        s = 82;
    	    }

    	    else if ( (LA119_125 == SLASH || LA119_125 == AND || ((LA119_125 >= PLUS) && (LA119_125 <= DOLLARD))) )
    	    {
    	        s = 83;
    	    }

    	    else if ( (LA119_125 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_125 == EQUAL || LA119_125 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_125);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 84:
        
    	{
    	    ANTLR3_UINT32 LA119_10;

    	    ANTLR3_MARKER index119_10;


    		LA119_10 = LA(1);

    	 
    	    index119_10 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_10 == COLON) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA119_10 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_10 >= HEX_CHAR) && (LA119_10 <= COMMON_CHAR))) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA119_10 == DIGIT) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA119_10 == DASH) )
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA119_10 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_10 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_10 == DOT) )
    	    {
    	        s = 13;
    	    }

    	    else if ( (((LA119_10 >= STAR) && (LA119_10 <= RPAREN)) || ((LA119_10 >= USCORE) && (LA119_10 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA119_10 == EOF || ((LA119_10 >= CRLF) && (LA119_10 <= SP)) || LA119_10 == DQUOTE || LA119_10 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_10 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_10 == SLASH || ((LA119_10 >= AND) && (LA119_10 <= COMMA))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_10);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 85:
        
    	{
    	    ANTLR3_UINT32 LA119_11;

    	    ANTLR3_MARKER index119_11;


    		LA119_11 = LA(1);

    	 
    	    index119_11 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_11 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_11 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_11 >= HEX_CHAR) && (LA119_11 <= COMMON_CHAR))) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA119_11 == DIGIT) )
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA119_11 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_11 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_11 == SLASH || ((LA119_11 >= AND) && (LA119_11 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_11 == DOT || ((LA119_11 >= STAR) && (LA119_11 <= RPAREN)) || ((LA119_11 >= USCORE) && (LA119_11 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_11);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 86:
        
    	{
    	    ANTLR3_UINT32 LA119_130;

    	    ANTLR3_MARKER index119_130;


    		LA119_130 = LA(1);

    	 
    	    index119_130 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_130 == COLON) )
    	    {
    	        s = 141;
    	    }

    	    else if ( (LA119_130 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_130 >= HEX_CHAR) && (LA119_130 <= COMMON_CHAR))) )
    	    {
    	        s = 142;
    	    }

    	    else if ( (LA119_130 == DIGIT) )
    	    {
    	        s = 143;
    	    }

    	    else if ( (LA119_130 == DOT || LA119_130 == DASH || ((LA119_130 >= STAR) && (LA119_130 <= RPAREN)) || ((LA119_130 >= USCORE) && (LA119_130 <= SQUOTE))) )
    	    {
    	        s = 144;
    	    }

    	    else if ( (LA119_130 == PERCENT) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA119_130 == SLASH || ((LA119_130 >= PLUS) && (LA119_130 <= DOLLARD)) || LA119_130 == QMARK) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA119_130 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_130 == EOF || ((LA119_130 >= CRLF) && (LA119_130 <= SP)) || LA119_130 == DQUOTE || ((LA119_130 >= LSBRAQUET) && (LA119_130 <= RSBRAQUET)) || LA119_130 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_130 == EQUAL || ((LA119_130 >= COMMA) && (LA119_130 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_130);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 87:
        
    	{
    	    ANTLR3_UINT32 LA119_62;

    	    ANTLR3_MARKER index119_62;


    		LA119_62 = LA(1);

    	 
    	    index119_62 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_62 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_62 >= HEX_CHAR) && (LA119_62 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_62 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_62 == DOT || LA119_62 == DASH || ((LA119_62 >= STAR) && (LA119_62 <= RPAREN)) || ((LA119_62 >= USCORE) && (LA119_62 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_62 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_62 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_62 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_62 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA119_62 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_62 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_62 == EOF || ((LA119_62 >= CRLF) && (LA119_62 <= SLASH)) || LA119_62 == COLON || LA119_62 == QMARK || LA119_62 == DQUOTE || ((LA119_62 >= LSBRAQUET) && (LA119_62 <= RSBRAQUET)) || LA119_62 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_62);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 88:
        
    	{
    	    ANTLR3_UINT32 LA119_135;

    	    ANTLR3_MARKER index119_135;


    		LA119_135 = LA(1);

    	 
    	    index119_135 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_135 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_135 >= HEX_CHAR) && (LA119_135 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_135 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_135 == DOT || LA119_135 == DASH || ((LA119_135 >= STAR) && (LA119_135 <= RPAREN)) || ((LA119_135 >= USCORE) && (LA119_135 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_135 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_135 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_135 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_135 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_135 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_135 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_135 == EOF || ((LA119_135 >= CRLF) && (LA119_135 <= SLASH)) || LA119_135 == COLON || LA119_135 == QMARK || LA119_135 == DQUOTE || ((LA119_135 >= LSBRAQUET) && (LA119_135 <= RSBRAQUET)) || LA119_135 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_135);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 89:
        
    	{
    	    ANTLR3_UINT32 LA119_43;

    	    ANTLR3_MARKER index119_43;


    		LA119_43 = LA(1);

    	 
    	    index119_43 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_43 == DOT) )
    	    {
    	        s = 19;
    	    }

    	    else if ( (LA119_43 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_43 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_43 >= HEX_CHAR) && (LA119_43 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_43 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_43 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_43 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_43 == SLASH || ((LA119_43 >= AND) && (LA119_43 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_43 >= STAR) && (LA119_43 <= RPAREN)) || ((LA119_43 >= USCORE) && (LA119_43 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_43);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 90:
        
    	{
    	    ANTLR3_UINT32 LA119_152;

    	    ANTLR3_MARKER index119_152;


    		LA119_152 = LA(1);

    	 
    	    index119_152 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_152 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_152 >= HEX_CHAR) && (LA119_152 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_152 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_152 == DOT || LA119_152 == DASH || ((LA119_152 >= STAR) && (LA119_152 <= RPAREN)) || ((LA119_152 >= USCORE) && (LA119_152 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_152 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_152 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_152 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_152 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_152 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_152 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_152 == EOF || ((LA119_152 >= CRLF) && (LA119_152 <= SLASH)) || LA119_152 == COLON || LA119_152 == QMARK || LA119_152 == DQUOTE || ((LA119_152 >= LSBRAQUET) && (LA119_152 <= RSBRAQUET)) || LA119_152 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_152);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 91:
        
    	{
    	    ANTLR3_UINT32 LA119_102;

    	    ANTLR3_MARKER index119_102;


    		LA119_102 = LA(1);

    	 
    	    index119_102 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_102 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_102 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_102 >= HEX_CHAR) && (LA119_102 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_102 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_102 == DOT) )
    	    {
    	        s = 68;
    	    }

    	    else if ( (LA119_102 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_102 == SLASH || ((LA119_102 >= AND) && (LA119_102 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_102 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (((LA119_102 >= STAR) && (LA119_102 <= RPAREN)) || ((LA119_102 >= USCORE) && (LA119_102 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_102);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 92:
        
    	{
    	    ANTLR3_UINT32 LA119_53;

    	    ANTLR3_MARKER index119_53;


    		LA119_53 = LA(1);

    	 
    	    index119_53 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_53 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_53 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_53 >= HEX_CHAR) && (LA119_53 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_53 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_53 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_53 == DASH || ((LA119_53 >= STAR) && (LA119_53 <= RPAREN)) || ((LA119_53 >= USCORE) && (LA119_53 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_53 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_53 == EOF || ((LA119_53 >= CRLF) && (LA119_53 <= SLASH)) || LA119_53 == COLON || ((LA119_53 >= SEMI) && (LA119_53 <= QMARK)) || LA119_53 == DQUOTE || ((LA119_53 >= LSBRAQUET) && (LA119_53 <= RSBRAQUET)) || LA119_53 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_53 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_53 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_53 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_53 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_53);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 93:
        
    	{
    	    ANTLR3_UINT32 LA119_139;

    	    ANTLR3_MARKER index119_139;


    		LA119_139 = LA(1);

    	 
    	    index119_139 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_139 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_139 >= HEX_CHAR) && (LA119_139 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_139 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_139 == DOT || LA119_139 == DASH || ((LA119_139 >= STAR) && (LA119_139 <= RPAREN)) || ((LA119_139 >= USCORE) && (LA119_139 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_139 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_139 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_139 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_139 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_139 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_139 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_139 == EOF || ((LA119_139 >= CRLF) && (LA119_139 <= SLASH)) || LA119_139 == COLON || LA119_139 == QMARK || LA119_139 == DQUOTE || ((LA119_139 >= LSBRAQUET) && (LA119_139 <= RSBRAQUET)) || LA119_139 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_139);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 94:
        
    	{
    	    ANTLR3_UINT32 LA119_54;

    	    ANTLR3_MARKER index119_54;


    		LA119_54 = LA(1);

    	 
    	    index119_54 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_54 == EQUAL) )
    	    {
    	        s = 52;
    	    }

    	    else if ( (LA119_54 == DOT) )
    	    {
    	        s = 49;
    	    }

    	    else if ( (((LA119_54 >= HEX_CHAR) && (LA119_54 <= COMMON_CHAR))) )
    	    {
    	        s = 47;
    	    }

    	    else if ( (LA119_54 == DIGIT) )
    	    {
    	        s = 48;
    	    }

    	    else if ( (LA119_54 == AND) )
    	    {
    	        s = 51;
    	    }

    	    else if ( (LA119_54 == DASH || ((LA119_54 >= STAR) && (LA119_54 <= RPAREN)) || ((LA119_54 >= USCORE) && (LA119_54 <= SQUOTE))) )
    	    {
    	        s = 55;
    	    }

    	    else if ( (LA119_54 == PERCENT) )
    	    {
    	        s = 50;
    	    }

    	    else if ( (LA119_54 == EOF || ((LA119_54 >= CRLF) && (LA119_54 <= SLASH)) || LA119_54 == COLON || ((LA119_54 >= SEMI) && (LA119_54 <= QMARK)) || LA119_54 == DQUOTE || ((LA119_54 >= LSBRAQUET) && (LA119_54 <= RSBRAQUET)) || LA119_54 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_54 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_54 == PLUS) )
    	    {
    	        s = 53;
    	    }

    	    else if ( (LA119_54 == DOLLARD) )
    	    {
    	        s = 54;
    	    }

    	    else if ( (LA119_54 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_54);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 95:
        
    	{
    	    ANTLR3_UINT32 LA119_94;

    	    ANTLR3_MARKER index119_94;


    		LA119_94 = LA(1);

    	 
    	    index119_94 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA119_94 >= HEX_CHAR) && (LA119_94 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_94 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_94 == DOT || LA119_94 == DASH || ((LA119_94 >= STAR) && (LA119_94 <= RPAREN)) || ((LA119_94 >= USCORE) && (LA119_94 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_94 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_94 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_94 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_94 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (LA119_94 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_94 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_94 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_94 == EOF || ((LA119_94 >= CRLF) && (LA119_94 <= SLASH)) || LA119_94 == COLON || LA119_94 == QMARK || LA119_94 == DQUOTE || ((LA119_94 >= LSBRAQUET) && (LA119_94 <= RSBRAQUET)) || LA119_94 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_94);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 96:
        
    	{
    	    ANTLR3_UINT32 LA119_138;

    	    ANTLR3_MARKER index119_138;


    		LA119_138 = LA(1);

    	 
    	    index119_138 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_138 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_138 >= HEX_CHAR) && (LA119_138 <= COMMON_CHAR))) )
    	    {
    	        s = 134;
    	    }

    	    else if ( (LA119_138 == DIGIT) )
    	    {
    	        s = 135;
    	    }

    	    else if ( (LA119_138 == DOT || LA119_138 == DASH || ((LA119_138 >= STAR) && (LA119_138 <= RPAREN)) || ((LA119_138 >= USCORE) && (LA119_138 <= SQUOTE))) )
    	    {
    	        s = 136;
    	    }

    	    else if ( (LA119_138 == PERCENT) )
    	    {
    	        s = 137;
    	    }

    	    else if ( (LA119_138 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_138 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_138 == PLUS) )
    	    {
    	        s = 138;
    	    }

    	    else if ( (LA119_138 == DOLLARD) )
    	    {
    	        s = 139;
    	    }

    	    else if ( (LA119_138 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	    else if ( (LA119_138 == EOF || ((LA119_138 >= CRLF) && (LA119_138 <= SLASH)) || LA119_138 == COLON || LA119_138 == QMARK || LA119_138 == DQUOTE || ((LA119_138 >= LSBRAQUET) && (LA119_138 <= RSBRAQUET)) || LA119_138 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	 
    		SEEK(index119_138);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 97:
        
    	{
    	    ANTLR3_UINT32 LA119_132;

    	    ANTLR3_MARKER index119_132;


    		LA119_132 = LA(1);

    	 
    	    index119_132 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_132 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_132 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_132 >= HEX_CHAR) && (LA119_132 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_132 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_132 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_132 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_132 == SLASH || ((LA119_132 >= AND) && (LA119_132 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_132 == DOT) )
    	    {
    	        s = 123;
    	    }

    	    else if ( (((LA119_132 >= STAR) && (LA119_132 <= RPAREN)) || ((LA119_132 >= USCORE) && (LA119_132 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_132);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 98:
        
    	{
    	    ANTLR3_UINT32 LA119_148;

    	    ANTLR3_MARKER index119_148;


    		LA119_148 = LA(1);

    	 
    	    index119_148 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_148 == DIGIT) )
    	    {
    	        s = 151;
    	    }

    	    else if ( (LA119_148 == COLON) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA119_148 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_148 >= HEX_CHAR) && (LA119_148 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_148 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_148 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_148 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_148 == DOT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (LA119_148 == EOF || ((LA119_148 >= CRLF) && (LA119_148 <= SP)) || LA119_148 == DQUOTE || LA119_148 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_148 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_148 == SLASH || ((LA119_148 >= AND) && (LA119_148 <= COMMA))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (((LA119_148 >= STAR) && (LA119_148 <= RPAREN)) || ((LA119_148 >= USCORE) && (LA119_148 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_148);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 99:
        
    	{
    	    ANTLR3_UINT32 LA119_89;

    	    ANTLR3_MARKER index119_89;


    		LA119_89 = LA(1);

    	 
    	    index119_89 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_89 == AND) )
    	    {
    	        s = 91;
    	    }

    	    else if ( (LA119_89 == EOF || ((LA119_89 >= CRLF) && (LA119_89 <= SLASH)) || LA119_89 == COLON || LA119_89 == QMARK || LA119_89 == DQUOTE || ((LA119_89 >= LSBRAQUET) && (LA119_89 <= RSBRAQUET)) || LA119_89 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_89 == PLUS) )
    	    {
    	        s = 92;
    	    }

    	    else if ( (((LA119_89 >= HEX_CHAR) && (LA119_89 <= COMMON_CHAR))) )
    	    {
    	        s = 87;
    	    }

    	    else if ( (LA119_89 == DIGIT) )
    	    {
    	        s = 88;
    	    }

    	    else if ( (LA119_89 == DOT || LA119_89 == DASH || ((LA119_89 >= STAR) && (LA119_89 <= RPAREN)) || ((LA119_89 >= USCORE) && (LA119_89 <= SQUOTE))) )
    	    {
    	        s = 89;
    	    }

    	    else if ( (LA119_89 == PERCENT) )
    	    {
    	        s = 90;
    	    }

    	    else if ( (LA119_89 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_89 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_89 == DOLLARD) )
    	    {
    	        s = 93;
    	    }

    	    else if ( (LA119_89 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_89);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 100:
        
    	{
    	    ANTLR3_UINT32 LA119_59;

    	    ANTLR3_MARKER index119_59;


    		LA119_59 = LA(1);

    	 
    	    index119_59 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_59 == EQUAL) )
    	    {
    	        s = 62;
    	    }

    	    else if ( (LA119_59 == PLUS) )
    	    {
    	        s = 63;
    	    }

    	    else if ( (((LA119_59 >= HEX_CHAR) && (LA119_59 <= COMMON_CHAR))) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA119_59 == DIGIT) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA119_59 == DOT || LA119_59 == DASH || ((LA119_59 >= STAR) && (LA119_59 <= RPAREN)) || ((LA119_59 >= USCORE) && (LA119_59 <= SQUOTE))) )
    	    {
    	        s = 60;
    	    }

    	    else if ( (LA119_59 == PERCENT) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA119_59 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_59 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_59 == DOLLARD) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA119_59 == SLASH || LA119_59 == COLON || LA119_59 == QMARK || ((LA119_59 >= LSBRAQUET) && (LA119_59 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_59 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_59);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 101:
        
    	{
    	    ANTLR3_UINT32 LA119_110;

    	    ANTLR3_MARKER index119_110;


    		LA119_110 = LA(1);

    	 
    	    index119_110 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_110 == EQUAL) )
    	    {
    	        s = 127;
    	    }

    	    else if ( (LA119_110 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA119_110 >= HEX_CHAR) && (LA119_110 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_110 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_110 == DOT || LA119_110 == DASH || ((LA119_110 >= STAR) && (LA119_110 <= RPAREN)) || ((LA119_110 >= USCORE) && (LA119_110 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_110 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_110 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_110 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_110 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_110 == SLASH || LA119_110 == COLON || LA119_110 == QMARK || ((LA119_110 >= LSBRAQUET) && (LA119_110 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_110 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_110);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 102:
        
    	{
    	    ANTLR3_UINT32 LA119_12;

    	    ANTLR3_MARKER index119_12;


    		LA119_12 = LA(1);

    	 
    	    index119_12 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_12 == COLON) )
    	    {
    	        s = 29;
    	    }

    	    else if ( (LA119_12 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_12 >= HEX_CHAR) && (LA119_12 <= COMMON_CHAR))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA119_12 == DIGIT) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (LA119_12 == DOT) )
    	    {
    	        s = 32;
    	    }

    	    else if ( (LA119_12 == PERCENT) )
    	    {
    	        s = 33;
    	    }

    	    else if ( (LA119_12 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_12 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_12 == EOF || ((LA119_12 >= CRLF) && (LA119_12 <= SP)) || LA119_12 == DQUOTE || ((LA119_12 >= LSBRAQUET) && (LA119_12 <= RSBRAQUET)) || LA119_12 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_12 == SLASH || LA119_12 == AND || ((LA119_12 >= PLUS) && (LA119_12 <= DOLLARD))) )
    	    {
    	        s = 34;
    	    }

    	    else if ( (LA119_12 == DASH || ((LA119_12 >= STAR) && (LA119_12 <= RPAREN)) || ((LA119_12 >= USCORE) && (LA119_12 <= SQUOTE))) )
    	    {
    	        s = 35;
    	    }

    	    else if ( (LA119_12 == EQUAL || LA119_12 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_12);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 103:
        
    	{
    	    ANTLR3_UINT32 LA119_18;

    	    ANTLR3_MARKER index119_18;


    		LA119_18 = LA(1);

    	 
    	    index119_18 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_18 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_18 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_18 >= HEX_CHAR) && (LA119_18 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_18 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_18 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_18 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_18 == SLASH || ((LA119_18 >= AND) && (LA119_18 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_18 == DOT || ((LA119_18 >= STAR) && (LA119_18 <= RPAREN)) || ((LA119_18 >= USCORE) && (LA119_18 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_18);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 104:
        
    	{
    	    ANTLR3_UINT32 LA119_52;

    	    ANTLR3_MARKER index119_52;


    		LA119_52 = LA(1);

    	 
    	    index119_52 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_52 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_52 >= HEX_CHAR) && (LA119_52 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_52 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_52 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_52 == DASH || ((LA119_52 >= STAR) && (LA119_52 <= RPAREN)) || ((LA119_52 >= USCORE) && (LA119_52 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_52 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_52 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_52 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_52 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_52 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_52 == SLASH || LA119_52 == COLON || ((LA119_52 >= LSBRAQUET) && (LA119_52 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_52 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_52);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 105:
        
    	{
    	    ANTLR3_UINT32 LA119_143;

    	    ANTLR3_MARKER index119_143;


    		LA119_143 = LA(1);

    	 
    	    index119_143 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_143 == COLON) )
    	    {
    	        s = 141;
    	    }

    	    else if ( (LA119_143 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_143 >= HEX_CHAR) && (LA119_143 <= COMMON_CHAR))) )
    	    {
    	        s = 142;
    	    }

    	    else if ( (LA119_143 == DIGIT) )
    	    {
    	        s = 143;
    	    }

    	    else if ( (LA119_143 == DOT || LA119_143 == DASH || ((LA119_143 >= STAR) && (LA119_143 <= RPAREN)) || ((LA119_143 >= USCORE) && (LA119_143 <= SQUOTE))) )
    	    {
    	        s = 144;
    	    }

    	    else if ( (LA119_143 == PERCENT) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA119_143 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_143 == EOF || ((LA119_143 >= CRLF) && (LA119_143 <= SP)) || LA119_143 == DQUOTE || ((LA119_143 >= LSBRAQUET) && (LA119_143 <= RSBRAQUET)) || LA119_143 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_143 == SLASH || ((LA119_143 >= PLUS) && (LA119_143 <= DOLLARD)) || LA119_143 == QMARK) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA119_143 == EQUAL || ((LA119_143 >= COMMA) && (LA119_143 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_143);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 106:
        
    	{
    	    ANTLR3_UINT32 LA119_153;

    	    ANTLR3_MARKER index119_153;


    		LA119_153 = LA(1);

    	 
    	    index119_153 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_153 == COLON) )
    	    {
    	        s = 141;
    	    }

    	    else if ( (LA119_153 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_153 >= HEX_CHAR) && (LA119_153 <= COMMON_CHAR))) )
    	    {
    	        s = 142;
    	    }

    	    else if ( (LA119_153 == DIGIT) )
    	    {
    	        s = 143;
    	    }

    	    else if ( (LA119_153 == DOT || LA119_153 == DASH || ((LA119_153 >= STAR) && (LA119_153 <= RPAREN)) || ((LA119_153 >= USCORE) && (LA119_153 <= SQUOTE))) )
    	    {
    	        s = 144;
    	    }

    	    else if ( (LA119_153 == PERCENT) )
    	    {
    	        s = 145;
    	    }

    	    else if ( (LA119_153 == AND) )
    	    {
    	        s = 100;
    	    }

    	    else if ( (LA119_153 == EOF || ((LA119_153 >= CRLF) && (LA119_153 <= SP)) || LA119_153 == DQUOTE || ((LA119_153 >= LSBRAQUET) && (LA119_153 <= RSBRAQUET)) || LA119_153 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_153 == SLASH || ((LA119_153 >= PLUS) && (LA119_153 <= DOLLARD)) || LA119_153 == QMARK) )
    	    {
    	        s = 146;
    	    }

    	    else if ( (LA119_153 == EQUAL || ((LA119_153 >= COMMA) && (LA119_153 <= SEMI))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	 
    		SEEK(index119_153);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 107:
        
    	{
    	    ANTLR3_UINT32 LA119_44;

    	    ANTLR3_MARKER index119_44;


    		LA119_44 = LA(1);

    	 
    	    index119_44 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_44 == COLON) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA119_44 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_44 >= HEX_CHAR) && (LA119_44 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_44 == DIGIT) )
    	    {
    	        s = 44;
    	    }

    	    else if ( (LA119_44 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_44 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_44 == SLASH || ((LA119_44 >= AND) && (LA119_44 <= QMARK))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_44 == DOT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (((LA119_44 >= STAR) && (LA119_44 <= RPAREN)) || ((LA119_44 >= USCORE) && (LA119_44 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_44);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 108:
        
    	{
    	    ANTLR3_UINT32 LA119_107;

    	    ANTLR3_MARKER index119_107;


    		LA119_107 = LA(1);

    	 
    	    index119_107 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_107 == EQUAL) )
    	    {
    	        s = 62;
    	    }

    	    else if ( (LA119_107 == PLUS) )
    	    {
    	        s = 63;
    	    }

    	    else if ( (((LA119_107 >= HEX_CHAR) && (LA119_107 <= COMMON_CHAR))) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA119_107 == DIGIT) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA119_107 == DOT || LA119_107 == DASH || ((LA119_107 >= STAR) && (LA119_107 <= RPAREN)) || ((LA119_107 >= USCORE) && (LA119_107 <= SQUOTE))) )
    	    {
    	        s = 60;
    	    }

    	    else if ( (LA119_107 == PERCENT) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA119_107 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_107 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_107 == DOLLARD) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA119_107 == SLASH || LA119_107 == COLON || LA119_107 == QMARK || ((LA119_107 >= LSBRAQUET) && (LA119_107 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_107 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_107);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 109:
        
    	{
    	    ANTLR3_UINT32 LA119_140;

    	    ANTLR3_MARKER index119_140;


    		LA119_140 = LA(1);

    	 
    	    index119_140 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_140 == EQUAL) )
    	    {
    	        s = 127;
    	    }

    	    else if ( (LA119_140 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA119_140 >= HEX_CHAR) && (LA119_140 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_140 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_140 == DOT || LA119_140 == DASH || ((LA119_140 >= STAR) && (LA119_140 <= RPAREN)) || ((LA119_140 >= USCORE) && (LA119_140 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_140 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_140 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_140 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_140 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_140 == SLASH || LA119_140 == COLON || LA119_140 == QMARK || ((LA119_140 >= LSBRAQUET) && (LA119_140 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_140 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_140);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 110:
        
    	{
    	    ANTLR3_UINT32 LA119_63;

    	    ANTLR3_MARKER index119_63;


    		LA119_63 = LA(1);

    	 
    	    index119_63 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_63 == EQUAL) )
    	    {
    	        s = 62;
    	    }

    	    else if ( (LA119_63 == PLUS) )
    	    {
    	        s = 63;
    	    }

    	    else if ( (((LA119_63 >= HEX_CHAR) && (LA119_63 <= COMMON_CHAR))) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA119_63 == DIGIT) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA119_63 == DOT || LA119_63 == DASH || ((LA119_63 >= STAR) && (LA119_63 <= RPAREN)) || ((LA119_63 >= USCORE) && (LA119_63 <= SQUOTE))) )
    	    {
    	        s = 60;
    	    }

    	    else if ( (LA119_63 == PERCENT) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA119_63 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_63 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_63 == DOLLARD) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA119_63 == SLASH || LA119_63 == COLON || LA119_63 == QMARK || ((LA119_63 >= LSBRAQUET) && (LA119_63 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_63 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_63);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 111:
        
    	{
    	    ANTLR3_UINT32 LA119_113;

    	    ANTLR3_MARKER index119_113;


    		LA119_113 = LA(1);

    	 
    	    index119_113 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_113 == EQUAL) )
    	    {
    	        s = 127;
    	    }

    	    else if ( (LA119_113 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA119_113 >= HEX_CHAR) && (LA119_113 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_113 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_113 == DOT || LA119_113 == DASH || ((LA119_113 >= STAR) && (LA119_113 <= RPAREN)) || ((LA119_113 >= USCORE) && (LA119_113 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_113 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_113 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_113 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_113 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_113 == SLASH || LA119_113 == COLON || LA119_113 == QMARK || ((LA119_113 >= LSBRAQUET) && (LA119_113 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_113 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_113);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 112:
        
    	{
    	    ANTLR3_UINT32 LA119_64;

    	    ANTLR3_MARKER index119_64;


    		LA119_64 = LA(1);

    	 
    	    index119_64 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_64 == EQUAL) )
    	    {
    	        s = 62;
    	    }

    	    else if ( (LA119_64 == PLUS) )
    	    {
    	        s = 63;
    	    }

    	    else if ( (((LA119_64 >= HEX_CHAR) && (LA119_64 <= COMMON_CHAR))) )
    	    {
    	        s = 58;
    	    }

    	    else if ( (LA119_64 == DIGIT) )
    	    {
    	        s = 59;
    	    }

    	    else if ( (LA119_64 == DOT || LA119_64 == DASH || ((LA119_64 >= STAR) && (LA119_64 <= RPAREN)) || ((LA119_64 >= USCORE) && (LA119_64 <= SQUOTE))) )
    	    {
    	        s = 60;
    	    }

    	    else if ( (LA119_64 == PERCENT) )
    	    {
    	        s = 61;
    	    }

    	    else if ( (LA119_64 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_64 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_64 == DOLLARD) )
    	    {
    	        s = 64;
    	    }

    	    else if ( (LA119_64 == SLASH || LA119_64 == COLON || LA119_64 == QMARK || ((LA119_64 >= LSBRAQUET) && (LA119_64 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_64 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_64);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 113:
        
    	{
    	    ANTLR3_UINT32 LA119_114;

    	    ANTLR3_MARKER index119_114;


    		LA119_114 = LA(1);

    	 
    	    index119_114 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_114 == EQUAL) )
    	    {
    	        s = 127;
    	    }

    	    else if ( (LA119_114 == PLUS) )
    	    {
    	        s = 113;
    	    }

    	    else if ( (((LA119_114 >= HEX_CHAR) && (LA119_114 <= COMMON_CHAR))) )
    	    {
    	        s = 109;
    	    }

    	    else if ( (LA119_114 == DIGIT) )
    	    {
    	        s = 110;
    	    }

    	    else if ( (LA119_114 == DOT || LA119_114 == DASH || ((LA119_114 >= STAR) && (LA119_114 <= RPAREN)) || ((LA119_114 >= USCORE) && (LA119_114 <= SQUOTE))) )
    	    {
    	        s = 111;
    	    }

    	    else if ( (LA119_114 == PERCENT) )
    	    {
    	        s = 112;
    	    }

    	    else if ( (LA119_114 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_114 == AND) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 24;
    	    }

    	    else if ( (LA119_114 == DOLLARD) )
    	    {
    	        s = 114;
    	    }

    	    else if ( (LA119_114 == SLASH || LA119_114 == COLON || LA119_114 == QMARK || ((LA119_114 >= LSBRAQUET) && (LA119_114 <= RSBRAQUET))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_114 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_114);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 114:
        
    	{
    	    ANTLR3_UINT32 LA119_133;

    	    ANTLR3_MARKER index119_133;


    		LA119_133 = LA(1);

    	 
    	    index119_133 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_133 == DIGIT) )
    	    {
    	        s = 148;
    	    }

    	    else if ( (LA119_133 == COLON) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA119_133 == EOF || ((LA119_133 >= CRLF) && (LA119_133 <= SP)) || LA119_133 == DQUOTE || LA119_133 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_133 == SEMI) )
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA119_133 == QMARK) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA119_133 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (((LA119_133 >= HEX_CHAR) && (LA119_133 <= COMMON_CHAR))) )
    	    {
    	        s = 17;
    	    }

    	    else if ( (LA119_133 == DASH) )
    	    {
    	        s = 18;
    	    }

    	    else if ( (LA119_133 == PERCENT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA119_133 == SLASH || ((LA119_133 >= AND) && (LA119_133 <= COMMA))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA119_133 == DOT) )
    	    {
    	        s = 45;
    	    }

    	    else if ( (((LA119_133 >= STAR) && (LA119_133 <= RPAREN)) || ((LA119_133 >= USCORE) && (LA119_133 <= SQUOTE))) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 3;
    	    }

    	 
    		SEEK(index119_133);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 115:
        
    	{
    	    ANTLR3_UINT32 LA119_74;

    	    ANTLR3_MARKER index119_74;


    		LA119_74 = LA(1);

    	 
    	    index119_74 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA119_74 == EOF || ((LA119_74 >= CRLF) && (LA119_74 <= SLASH)) || LA119_74 == COLON || ((LA119_74 >= SEMI) && (LA119_74 <= QMARK)) || LA119_74 == DQUOTE || ((LA119_74 >= LSBRAQUET) && (LA119_74 <= RSBRAQUET)) || LA119_74 == RAQUOT) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA119_74 == DOT) )
    	    {
    	        s = 70;
    	    }

    	    else if ( (((LA119_74 >= HEX_CHAR) && (LA119_74 <= COMMON_CHAR))) )
    	    {
    	        s = 71;
    	    }

    	    else if ( (LA119_74 == DIGIT) )
    	    {
    	        s = 72;
    	    }

    	    else if ( (LA119_74 == AND) )
    	    {
    	        s = 73;
    	    }

    	    else if ( (LA119_74 == DASH || ((LA119_74 >= STAR) && (LA119_74 <= RPAREN)) || ((LA119_74 >= USCORE) && (LA119_74 <= SQUOTE))) )
    	    {
    	        s = 74;
    	    }

    	    else if ( (LA119_74 == PERCENT) )
    	    {
    	        s = 75;
    	    }

    	    else if ( (LA119_74 == AT) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA119_74 == PLUS) )
    	    {
    	        s = 76;
    	    }

    	    else if ( (LA119_74 == EQUAL) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 25;
    	    }

    	    else if ( (LA119_74 == DOLLARD) )
    	    {
    	        s = 77;
    	    }

    	    else if ( (LA119_74 == COMMA) && (synpred10_belle_sip_message(ctx)))
    	    {
    	        s = 28;
    	    }

    	 
    		SEEK(index119_74);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"1455:33: ( ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] )";
    EXCEPTION->decisionNum  = 119;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 119
 */
static
ANTLR3_CYCLIC_DFA cdfa119
    =	{
	    119,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1455:33: ( ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] )",	
	    (CDFA_SPECIAL_FUNC) dfa119_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa119_eot,	    /* EOT table			    */
	    dfa119_eof,	    /* EOF table			    */
	    dfa119_min,	    /* Minimum tokens for each state    */
	    dfa119_max,	    /* Maximum tokens for each state    */
	    dfa119_accept,	/* Accept table			    */
	    dfa119_special,	/* Special transition states	    */
	    dfa119_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 119
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1456:4: ( uri_parameters[$uri::current] )?
 */
static const ANTLR3_INT32 dfa120_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa120_eof[7] =
    {
	4, 4, -1, -1, -1, 4, 4
    };
static const ANTLR3_INT32 dfa120_min[7] =
    {
	4, 4, 5, -1, -1, 4, 5
    };
static const ANTLR3_INT32 dfa120_max[7] =
    {
	32, 32, 5, -1, -1, 32, 32
    };
static const ANTLR3_INT32 dfa120_accept[7] =
    {
	-1, -1, -1, 1, 2, -1, -1
    };
static const ANTLR3_INT32 dfa120_special[7] =
    {	
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa120_T_empty	    NULL

static const ANTLR3_INT32 dfa120_T0[] =
    {
	6
    };static const ANTLR3_INT32 dfa120_T1[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 4
    };static const ANTLR3_INT32 dfa120_T2[] =
    {
	2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 4, 4, -1, 4
    };static const ANTLR3_INT32 dfa120_T3[] =
    {
	2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };static const ANTLR3_INT32 dfa120_T4[] =
    {
	2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa120_transitions[] =
{
    dfa120_T4, dfa120_T2, dfa120_T0, dfa120_T_empty, dfa120_T_empty, dfa120_T3, 
    dfa120_T1	
};


/* Declare tracking structure for Cyclic DFA 120
 */
static
ANTLR3_CYCLIC_DFA cdfa120
    =	{
	    120,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1456:4: ( uri_parameters[$uri::current] )?",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa120_eot,	    /* EOT table			    */
	    dfa120_eof,	    /* EOF table			    */
	    dfa120_min,	    /* Minimum tokens for each state    */
	    dfa120_max,	    /* Maximum tokens for each state    */
	    dfa120_accept,	/* Accept table			    */
	    dfa120_special,	/* Special transition states	    */
	    dfa120_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 120
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 1494:7: ( ( semi uri_parameter ) | ( ( lws )? SEMI ) )+
 */
static const ANTLR3_INT32 dfa128_eot[19] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };
static const ANTLR3_INT32 dfa128_eof[19] =
    {
	1, -1, 1, -1, 7, 1, 1, -1, 7, -1, -1, 7, 10, 7, 10, 10, 10, 10, -1
    };
static const ANTLR3_INT32 dfa128_min[19] =
    {
	4, -1, 4, 5, 4, 4, 5, -1, 4, 5, -1, 4, 4, 5, 4, 4, 4, 4, 5
    };
static const ANTLR3_INT32 dfa128_max[19] =
    {
	32, -1, 32, 5, 38, 32, 32, -1, 38, 5, -1, 38, 38, 38, 38, 38, 38, 38, 38
    };
static const ANTLR3_INT32 dfa128_accept[19] =
    {
	-1, 3, -1, -1, -1, -1, -1, 2, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa128_special[19] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa128_T_empty	    NULL

static const ANTLR3_INT32 dfa128_T0[] =
    {
	9, 11, 10, 10, 10, 10, -1, 10, -1, 10, 10, -1, 7, -1, 10, -1, -1, 10, 10, 
	10, -1, 10, 10, 10, -1, 10, 10, -1, 7, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T1[] =
    {
	10, -1, 7, 7, -1, -1, -1, -1, 7, -1, -1, -1, -1, 7, -1, -1, 7, 7, 7, -1, 
	-1, -1, 7, 7, 7, 7, -1, -1, -1, -1, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa128_T2[] =
    {
	3, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1
    };static const ANTLR3_INT32 dfa128_T3[] =
    {
	9, 11, 10, 10, 10, 10, -1, 10, -1, 10, 10, -1, 7, -1, 10, -1, -1, 10, 10, 
	10, -1, 10, 10, 10, -1, 12, 12, -1, 7, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T4[] =
    {
	18, 10, 10, 10, 10, 10, -1, 10, 10, 10, 10, -1, 10, 10, 10, 10, -1, 10, 
	10, 10, -1, 10, 10, 10, -1, 10, 10, -1, 10, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T5[] =
    {
	13, 10, 10, 10, 10, -1, 10, -1, 10, 10, -1, 7, -1, 10, -1, -1, 10, 10, 
	10, -1, 10, 10, 10, -1, 10, 10, -1, 7, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T6[] =
    {
	6
    };static const ANTLR3_INT32 dfa128_T7[] =
    {
	3, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 1, 1, -1, 1
    };static const ANTLR3_INT32 dfa128_T8[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 1
    };static const ANTLR3_INT32 dfa128_T9[] =
    {
	10, 10, 10, 10, 16, 10, -1, 10, 10, 10, 10, -1, 10, 10, 10, 10, -1, 10, 
	10, 10, -1, 10, 10, 10, -1, 10, 10, -1, 10, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T10[] =
    {
	3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, -1, 1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1
    };static const ANTLR3_INT32 dfa128_T11[] =
    {
	13
    };static const ANTLR3_INT32 dfa128_T12[] =
    {
	10, 10, 10, 15, 10, 10, -1, 10, 10, 10, 10, -1, 10, 10, 10, 10, -1, 10, 
	10, 10, -1, 10, 10, 10, -1, 10, 10, -1, 10, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T13[] =
    {
	10, 10, 10, 17, 10, 10, -1, 10, 10, 10, 10, -1, 10, 10, 10, 10, -1, 10, 
	10, 10, -1, 10, 10, 10, -1, 10, 10, -1, 10, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T14[] =
    {
	10, 10, 14, 10, 10, 10, -1, 10, 10, 10, 10, -1, 10, 10, 10, 10, -1, 10, 
	10, 10, -1, 10, 10, 10, -1, 12, 12, -1, 10, -1, -1, 10, 10, 10, 10
    };static const ANTLR3_INT32 dfa128_T15[] =
    {
	9, 8, 10, 10, 10, 10, -1, 10, -1, 10, 10, -1, 7, 7, 10, 7, -1, 10, 10, 
	10, -1, 10, 10, 10, -1, 10, 10, -1, 7, -1, -1, 10, 10, 10, 10
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa128_transitions[] =
{
    dfa128_T10, dfa128_T_empty, dfa128_T7, dfa128_T6, dfa128_T15, dfa128_T2, 
    dfa128_T8, dfa128_T_empty, dfa128_T3, dfa128_T11, dfa128_T_empty, dfa128_T0, 
    dfa128_T14, dfa128_T5, dfa128_T12, dfa128_T9, dfa128_T13, dfa128_T4, 
    dfa128_T1	
};


/* Declare tracking structure for Cyclic DFA 128
 */
static
ANTLR3_CYCLIC_DFA cdfa128
    =	{
	    128,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()+ loopback of 1494:7: ( ( semi uri_parameter ) | ( ( lws )? SEMI ) )+",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa128_eot,	    /* EOT table			    */
	    dfa128_eof,	    /* EOF table			    */
	    dfa128_min,	    /* Minimum tokens for each state    */
	    dfa128_max,	    /* Maximum tokens for each state    */
	    dfa128_accept,	/* Accept table			    */
	    dfa128_special,	/* Special transition states	    */
	    dfa128_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 128
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1497:1: other_param : ( pname | ( pname EQUAL pvalue ) );
 */
static const ANTLR3_INT32 dfa129_eot[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa129_eof[11] =
    {
	-1, 8, 8, 8, 8, 8, -1, -1, -1, -1, 8
    };
static const ANTLR3_INT32 dfa129_min[11] =
    {
	6, 4, 4, 4, 4, 4, 7, -1, -1, 7, 4
    };
static const ANTLR3_INT32 dfa129_max[11] =
    {
	38, 38, 38, 38, 38, 38, 29, -1, -1, 29, 38
    };
static const ANTLR3_INT32 dfa129_accept[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, 2, 1, -1, -1
    };
static const ANTLR3_INT32 dfa129_special[11] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa129_T_empty	    NULL

static const ANTLR3_INT32 dfa129_T0[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 9
    };static const ANTLR3_INT32 dfa129_T1[] =
    {
	8, 8, 4, 3, 1, 4, -1, 4, 7, 4, 4, -1, 8, 8, 5, 8, -1, 5, 5, 5, -1, 4, 4, 
	6, -1, 2, 2, -1, 8, -1, -1, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa129_T2[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 10
    };static const ANTLR3_INT32 dfa129_T3[] =
    {
	4, 3, 1, 4, -1, 4, -1, 4, 4, -1, -1, -1, 5, -1, -1, 5, 5, 5, -1, 4, 4, 
	6, -1, 2, 2, -1, -1, -1, -1, 5, 5, 5, 5
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa129_transitions[] =
{
    dfa129_T3, dfa129_T1, dfa129_T1, dfa129_T1, dfa129_T1, dfa129_T1, dfa129_T0, 
    dfa129_T_empty, dfa129_T_empty, dfa129_T2, dfa129_T1	
};


/* Declare tracking structure for Cyclic DFA 129
 */
static
ANTLR3_CYCLIC_DFA cdfa129
    =	{
	    129,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1497:1: other_param : ( pname | ( pname EQUAL pvalue ) );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa129_eot,	    /* EOT table			    */
	    dfa129_eof,	    /* EOF table			    */
	    dfa129_min,	    /* Minimum tokens for each state    */
	    dfa129_max,	    /* Maximum tokens for each state    */
	    dfa129_accept,	/* Accept table			    */
	    dfa129_special,	/* Special transition states	    */
	    dfa129_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 129
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 1559:21: ( domainlabel DOT )*
 */
static const ANTLR3_INT32 dfa138_eot[17] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa138_eof[17] =
    {
	-1, 9, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9
    };
static const ANTLR3_INT32 dfa138_min[17] =
    {
	7, 4, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 4, 4
    };
static const ANTLR3_INT32 dfa138_max[17] =
    {
	30, 32, -1, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, 32, 32
    };
static const ANTLR3_INT32 dfa138_accept[17] =
    {
	-1, -1, 1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, -1
    };
static const ANTLR3_INT32 dfa138_special[17] =
    {	
	-1, 0, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa138_T_empty	    NULL

static const ANTLR3_INT32 dfa138_T0[] =
    {
	8, 7, 5, 16, 3, 4, -1, -1, -1, -1, -1, 12, 11, 6, 14, 13, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, 15, -1, 10
    };static const ANTLR3_INT32 dfa138_T1[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 15, 15
    };static const ANTLR3_INT32 dfa138_T2[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 1, 1
    };static const ANTLR3_INT32 dfa138_T3[] =
    {
	8, 7, 5, 2, -1, 4, -1, -1, -1, -1, -1, 12, 11, 6, -1, 13, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 2, 2, -1, 10
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa138_transitions[] =
{
    dfa138_T2, dfa138_T0, dfa138_T_empty, dfa138_T3, dfa138_T_empty, dfa138_T_empty, 
    dfa138_T_empty, dfa138_T_empty, dfa138_T_empty, dfa138_T_empty, dfa138_T_empty, 
    dfa138_T_empty, dfa138_T_empty, dfa138_T_empty, dfa138_T1, dfa138_T0, 
    dfa138_T0	
};

static ANTLR3_INT32 dfa138_sst(pbelle_sip_messageParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA138_1;

    	    ANTLR3_MARKER index138_1;


    		LA138_1 = LA(1);

    	 
    	    index138_1 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA138_1 == DOT) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA138_1 == COLON) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA138_1 == SLASH) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA138_1 == QMARK) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA138_1 == SP) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA138_1 == CRLF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA138_1 == EOF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA138_1 == RAQUOT) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA138_1 == SEMI) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA138_1 == COMMA) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA138_1 == DQUOTE) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA138_1 == DASH) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA138_1 >= HEX_CHAR) && (LA138_1 <= COMMON_CHAR))) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA138_1 == DIGIT) )
    	    {
    	        s = 16;
    	    }

    	 
    		SEEK(index138_1);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 1:
        
    	{
    	    ANTLR3_UINT32 LA138_16;

    	    ANTLR3_MARKER index138_16;


    		LA138_16 = LA(1);

    	 
    	    index138_16 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA138_16 >= HEX_CHAR) && (LA138_16 <= COMMON_CHAR))) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA138_16 == DIGIT) )
    	    {
    	        s = 16;
    	    }

    	    else if ( (LA138_16 == DASH) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (LA138_16 == DOT) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA138_16 == COLON) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA138_16 == SLASH) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA138_16 == QMARK) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA138_16 == SP) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA138_16 == CRLF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA138_16 == EOF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA138_16 == RAQUOT) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA138_16 == SEMI) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA138_16 == COMMA) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA138_16 == DQUOTE) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 13;
    	    }

    	 
    		SEEK(index138_16);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 2:
        
    	{
    	    ANTLR3_UINT32 LA138_3;

    	    ANTLR3_MARKER index138_3;


    		LA138_3 = LA(1);

    	 
    	    index138_3 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA138_3 == COLON) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA138_3 == SLASH) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA138_3 == QMARK) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA138_3 == SP) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA138_3 == CRLF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA138_3 == EOF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA138_3 == RAQUOT) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA138_3 == SEMI) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA138_3 == COMMA) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA138_3 == DQUOTE) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA138_3 == DIGIT || ((LA138_3 >= HEX_CHAR) && (LA138_3 <= COMMON_CHAR))) )
    	    {
    	        s = 2;
    	    }

    	 
    		SEEK(index138_3);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
        case 3:
        
    	{
    	    ANTLR3_UINT32 LA138_15;

    	    ANTLR3_MARKER index138_15;


    		LA138_15 = LA(1);

    	 
    	    index138_15 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA138_15 == DOT) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA138_15 == COLON) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA138_15 == SLASH) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA138_15 == QMARK) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA138_15 == SP) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA138_15 == CRLF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA138_15 == EOF) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA138_15 == RAQUOT) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 10;
    	    }

    	    else if ( (LA138_15 == SEMI) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 11;
    	    }

    	    else if ( (LA138_15 == COMMA) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 12;
    	    }

    	    else if ( (LA138_15 == DQUOTE) && (synpred12_belle_sip_message(ctx)))
    	    {
    	        s = 13;
    	    }

    	    else if ( (LA138_15 == DASH) )
    	    {
    	        s = 14;
    	    }

    	    else if ( (((LA138_15 >= HEX_CHAR) && (LA138_15 <= COMMON_CHAR))) )
    	    {
    	        s = 15;
    	    }

    	    else if ( (LA138_15 == DIGIT) )
    	    {
    	        s = 16;
    	    }

    	 
    		SEEK(index138_15);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()* loopback of 1559:21: ( domainlabel DOT )*";
    EXCEPTION->decisionNum  = 138;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 138
 */
static
ANTLR3_CYCLIC_DFA cdfa138
    =	{
	    138,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 1559:21: ( domainlabel DOT )*",	
	    (CDFA_SPECIAL_FUNC) dfa138_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa138_eot,	    /* EOT table			    */
	    dfa138_eof,	    /* EOF table			    */
	    dfa138_min,	    /* Minimum tokens for each state    */
	    dfa138_max,	    /* Maximum tokens for each state    */
	    dfa138_accept,	/* Accept table			    */
	    dfa138_special,	/* Special transition states	    */
	    dfa138_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 138
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1567:1: hexpart : ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? );
 */
static const ANTLR3_INT32 dfa148_eot[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa148_eof[10] =
    {
	-1, 4, -1, -1, -1, -1, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa148_min[10] =
    {
	7, 4, -1, 7, -1, -1, 4, 4, 4, 4
    };
static const ANTLR3_INT32 dfa148_max[10] =
    {
	29, 29, -1, 29, -1, -1, 29, 29, 29, 29
    };
static const ANTLR3_INT32 dfa148_accept[10] =
    {
	-1, -1, 3, -1, 1, 2, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa148_special[10] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa148_T_empty	    NULL

static const ANTLR3_INT32 dfa148_T0[] =
    {
	4, 4, -1, 7, -1, 3, -1, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, 7
    };static const ANTLR3_INT32 dfa148_T1[] =
    {
	4, 4, -1, 7, 4, 3, -1, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, 7
    };static const ANTLR3_INT32 dfa148_T2[] =
    {
	1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 1
    };static const ANTLR3_INT32 dfa148_T3[] =
    {
	6, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 7
    };static const ANTLR3_INT32 dfa148_T4[] =
    {
	4, 4, -1, 1, -1, 3, -1, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, 1
    };static const ANTLR3_INT32 dfa148_T5[] =
    {
	4, 4, -1, 9, 4, 3, -1, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, 7
    };static const ANTLR3_INT32 dfa148_T6[] =
    {
	4, 4, -1, 8, 4, 3, -1, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, 7
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa148_transitions[] =
{
    dfa148_T2, dfa148_T4, dfa148_T_empty, dfa148_T3, dfa148_T_empty, dfa148_T_empty, 
    dfa148_T6, dfa148_T0, dfa148_T5, dfa148_T1	
};


/* Declare tracking structure for Cyclic DFA 148
 */
static
ANTLR3_CYCLIC_DFA cdfa148
    =	{
	    148,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1567:1: hexpart : ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa148_eot,	    /* EOT table			    */
	    dfa148_eof,	    /* EOF table			    */
	    dfa148_min,	    /* Minimum tokens for each state    */
	    dfa148_max,	    /* Maximum tokens for each state    */
	    dfa148_accept,	/* Accept table			    */
	    dfa148_special,	/* Special transition states	    */
	    dfa148_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 148
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1619:1: lws : ( ( ( SP )* CRLF ( SP )+ ) | ( SP )+ );
 */
static const ANTLR3_INT32 dfa175_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa175_eof[5] =
    {
	-1, 3, -1, -1, -1
    };
static const ANTLR3_INT32 dfa175_min[5] =
    {
	4, 4, -1, -1, 4
    };
static const ANTLR3_INT32 dfa175_max[5] =
    {
	5, 40, -1, -1, 38
    };
static const ANTLR3_INT32 dfa175_accept[5] =
    {
	-1, -1, 1, 2, -1
    };
static const ANTLR3_INT32 dfa175_special[5] =
    {	
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa175_T_empty	    NULL

static const ANTLR3_INT32 dfa175_T0[] =
    {
	4, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa175_T1[] =
    {
	3, 2, -1, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 
	-1, -1, -1, 3, 3, 3, 3, -1, -1, -1, -1, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa175_T2[] =
    {
	2, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa175_transitions[] =
{
    dfa175_T2, dfa175_T0, dfa175_T_empty, dfa175_T_empty, dfa175_T1	
};


/* Declare tracking structure for Cyclic DFA 175
 */
static
ANTLR3_CYCLIC_DFA cdfa175
    =	{
	    175,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1619:1: lws : ( ( ( SP )* CRLF ( SP )+ ) | ( SP )+ );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa175_eot,	    /* EOT table			    */
	    dfa175_eof,	    /* EOF table			    */
	    dfa175_min,	    /* Minimum tokens for each state    */
	    dfa175_max,	    /* Maximum tokens for each state    */
	    dfa175_accept,	/* Accept table			    */
	    dfa175_special,	/* Special transition states	    */
	    dfa175_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 175
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */ 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start message
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:99:1: message returns [belle_sip_message_t* ret] : message_raw[&($message::message_length)] ;
 */
static belle_sip_message_t*
message(pbelle_sip_messageParser ctx)
{   
    belle_sip_message_t* ret = NULL;

    belle_sip_message_t* message_raw1;
    #undef	RETURN_TYPE_message_raw1
    #define	RETURN_TYPE_message_raw1 belle_sip_message_t*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_messageTop = pbelle_sip_messageParser_messagePush(ctx);
    ret=NULL;
    message_raw1 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:102:3: ( message_raw[&($message::message_length)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:102:5: message_raw[&($message::message_length)]
        {
            FOLLOWPUSH(FOLLOW_message_raw_in_message76);
            message_raw1=message_raw(ctx, &(	(SCOPE_TOP(message))->message_length));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessageEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_messagePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=message_raw1;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessageEx; /* Prevent compiler warnings */
    rulemessageEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_messagePop(ctx);

    return ret;
}
/* $ANTLR end message */

/** 
 * $ANTLR start message_raw
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:104:1: message_raw[size_t* length] returns [belle_sip_message_t* ret] : ( common_request | common_response );
 */
static belle_sip_message_t*
message_raw(pbelle_sip_messageParser ctx, size_t* length)
{   
    belle_sip_message_t* ret = NULL;

    belle_sip_message_t* common_request2;
    #undef	RETURN_TYPE_common_request2
    #define	RETURN_TYPE_common_request2 belle_sip_message_t*

    belle_sip_message_t* common_response3;
    #undef	RETURN_TYPE_common_response3
    #define	RETURN_TYPE_common_response3 belle_sip_message_t*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_message_rawTop = pbelle_sip_messageParser_message_rawPush(ctx);
    	(SCOPE_TOP(message_raw))->message_length=length;ret=NULL;
    common_request2 = NULL;
    common_response3 = NULL;

    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:107:2: ( common_request | common_response )
            
            ANTLR3_UINT32 alt1;

            alt1=2;

            alt1 = cdfa1.predict(ctx, RECOGNIZER, ISTREAM, &cdfa1);
            if  (HASEXCEPTION())
            {
                goto rulemessage_rawEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_message_rawPop(ctx);

                return ret;
            }
            switch (alt1) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:107:5: common_request
        	    {
        	        FOLLOWPUSH(FOLLOW_common_request_in_message_raw107);
        	        common_request2=common_request(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_rawEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pbelle_sip_messageParser_message_rawPop(ctx);

        	            return ret;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            ret= common_request2;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:108:7: common_response
        	    {
        	        FOLLOWPUSH(FOLLOW_common_response_in_message_raw118);
        	        common_response3=common_response(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemessage_rawEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pbelle_sip_messageParser_message_rawPop(ctx);

        	            return ret;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            ret= common_response3;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_rawEx; /* Prevent compiler warnings */
    rulemessage_rawEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_message_rawPop(ctx);

    return ret;
}
/* $ANTLR end message_raw */

/** 
 * $ANTLR start request
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:110:1: request returns [belle_sip_request_t* ret=NULL] : common_request ;
 */
static belle_sip_request_t*
request(pbelle_sip_messageParser ctx)
{   
    belle_sip_request_t* ret = NULL;

    belle_sip_message_t* common_request4;
    #undef	RETURN_TYPE_common_request4
    #define	RETURN_TYPE_common_request4 belle_sip_message_t*

    /* Initialize rule variables
     */


    common_request4 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:111:3: ( common_request )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:111:4: common_request
        {
            FOLLOWPUSH(FOLLOW_common_request_in_request135);
            common_request4=common_request(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=BELLE_SIP_REQUEST(common_request4);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerequestEx; /* Prevent compiler warnings */
    rulerequestEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end request */

/** 
 * $ANTLR start common_request
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:114:1: common_request returns [belle_sip_message_t* ret] : ( ( (~ ( CRLF ) )* sip_version CRLF )=> request_line | ( (~ ( CRLF ) )* http_version CRLF )=> http_request_line ) ( message_header[BELLE_SIP_MESSAGE($common_request::current)] )+ last_crlf= CRLF ;
 */
static belle_sip_message_t*
common_request(pbelle_sip_messageParser ctx)
{   
    belle_sip_message_t* ret = NULL;

    pANTLR3_COMMON_TOKEN    last_crlf;
    belle_sip_request_t* request_line5;
    #undef	RETURN_TYPE_request_line5
    #define	RETURN_TYPE_request_line5 belle_sip_request_t*

    belle_http_request_t * http_request_line6;
    #undef	RETURN_TYPE_http_request_line6
    #define	RETURN_TYPE_http_request_line6 belle_http_request_t *

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_common_requestTop = pbelle_sip_messageParser_common_requestPush(ctx);
    ret=	(SCOPE_TOP(common_request))->current=NULL; 
    last_crlf       = NULL;
    request_line5 = NULL;
    http_request_line6 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:2: ( ( ( (~ ( CRLF ) )* sip_version CRLF )=> request_line | ( (~ ( CRLF ) )* http_version CRLF )=> http_request_line ) ( message_header[BELLE_SIP_MESSAGE($common_request::current)] )+ last_crlf= CRLF )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:6: ( ( (~ ( CRLF ) )* sip_version CRLF )=> request_line | ( (~ ( CRLF ) )* http_version CRLF )=> http_request_line ) ( message_header[BELLE_SIP_MESSAGE($common_request::current)] )+ last_crlf= CRLF
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:6: ( ( (~ ( CRLF ) )* sip_version CRLF )=> request_line | ( (~ ( CRLF ) )* http_version CRLF )=> http_request_line )
            {
                int alt2=2;
                switch ( LA(1) ) 
                {
                case HEX_CHAR:
                case COMMON_CHAR:
                	{

                		{
                		    int LA2_1 = LA(2);
                		    if ( (synpred1_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=1;
                		    }
                		    else if ( (synpred2_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sip_messageParser_common_requestPop(ctx);

                		            return ret;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 2;
                		        EXCEPTION->state        = 1;


                		        goto rulecommon_requestEx;
                		    }
                		}
                	}
                    break;
                case DIGIT:
                	{

                		{
                		    int LA2_2 = LA(2);
                		    if ( (synpred1_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=1;
                		    }
                		    else if ( (synpred2_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sip_messageParser_common_requestPop(ctx);

                		            return ret;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 2;
                		        EXCEPTION->state        = 2;


                		        goto rulecommon_requestEx;
                		    }
                		}
                	}
                    break;
                case DOT:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{

                		{
                		    int LA2_3 = LA(2);
                		    if ( (synpred1_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=1;
                		    }
                		    else if ( (synpred2_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sip_messageParser_common_requestPop(ctx);

                		            return ret;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 2;
                		        EXCEPTION->state        = 3;


                		        goto rulecommon_requestEx;
                		    }
                		}
                	}
                    break;
                case PERCENT:
                	{

                		{
                		    int LA2_4 = LA(2);
                		    if ( (synpred1_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=1;
                		    }
                		    else if ( (synpred2_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sip_messageParser_common_requestPop(ctx);

                		            return ret;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 2;
                		        EXCEPTION->state        = 4;


                		        goto rulecommon_requestEx;
                		    }
                		}
                	}
                    break;
                case PLUS:
                	{

                		{
                		    int LA2_5 = LA(2);
                		    if ( (synpred1_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=1;
                		    }
                		    else if ( (synpred2_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sip_messageParser_common_requestPop(ctx);

                		            return ret;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 2;
                		        EXCEPTION->state        = 5;


                		        goto rulecommon_requestEx;
                		    }
                		}
                	}
                    break;
                case BQUOTE:
                	{

                		{
                		    int LA2_6 = LA(2);
                		    if ( (synpred1_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=1;
                		    }
                		    else if ( (synpred2_belle_sip_message(ctx)) ) 
                		    {
                		        alt2=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sip_messageParser_common_requestPop(ctx);

                		            return ret;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 2;
                		        EXCEPTION->state        = 6;


                		        goto rulecommon_requestEx;
                		    }
                		}
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        pbelle_sip_messageParser_common_requestPop(ctx);

                        return ret;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 2;
                    EXCEPTION->state        = 0;


                    goto rulecommon_requestEx;
                }

                switch (alt2) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:9: ( (~ ( CRLF ) )* sip_version CRLF )=> request_line
            	    {
            	        FOLLOWPUSH(FOLLOW_request_line_in_common_request188);
            	        request_line5=request_line(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommon_requestEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_common_requestPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            ret=	(SCOPE_TOP(common_request))->current=BELLE_SIP_MESSAGE(request_line5);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:118:8: ( (~ ( CRLF ) )* http_version CRLF )=> http_request_line
            	    {
            	        FOLLOWPUSH(FOLLOW_http_request_line_in_common_request216);
            	        http_request_line6=http_request_line(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommon_requestEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_common_requestPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            ret=	(SCOPE_TOP(common_request))->current=BELLE_SIP_MESSAGE(http_request_line6);
            	        }

            	    }
            	    break;

                }
            }
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:119:3: ( message_header[BELLE_SIP_MESSAGE($common_request::current)] )+
            {
                int cnt3=0;

                for (;;)
                {
                    int alt3=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case DOT:
            	case PLUS:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case PERCENT:
            	case BQUOTE:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt3=1;
            		}
            	    break;

            	}

            	switch (alt3) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:119:3: message_header[BELLE_SIP_MESSAGE($common_request::current)]
            	        {
            	            FOLLOWPUSH(FOLLOW_message_header_in_common_request223);
            	            message_header(ctx, BELLE_SIP_MESSAGE(	(SCOPE_TOP(common_request))->current));

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecommon_requestEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_common_requestPop(ctx);

            	                return ret;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt3 >= 1 )
            		{
            		    goto loop3;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    pbelle_sip_messageParser_common_requestPop(ctx);

            		    return ret;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulecommon_requestEx;
            	}
            	cnt3++;
                }
                loop3: ;	/* Jump to here if this rule does not match */
            }
            last_crlf = (pANTLR3_COMMON_TOKEN) MATCHT(CRLF, &FOLLOW_CRLF_in_common_request229); 
            if  (HASEXCEPTION())
            {
                goto rulecommon_requestEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_common_requestPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                *(	(SCOPE_TOP(message_raw))->message_length)=last_crlf->user1;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommon_requestEx; /* Prevent compiler warnings */
    rulecommon_requestEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_common_requestPop(ctx);

    return ret;
}
/* $ANTLR end common_request */

/** 
 * $ANTLR start request_line
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:121:1: request_line returns [belle_sip_request_t* ret=NULL] : method SP ( uri | generic_uri ) SP sip_version CRLF ;
 */
static belle_sip_request_t*
request_line(pbelle_sip_messageParser ctx)
{   
    belle_sip_request_t* ret = NULL;

    belle_sip_messageParser_method_return method7;
    #undef	RETURN_TYPE_method7
    #define	RETURN_TYPE_method7 belle_sip_messageParser_method_return

    belle_sip_uri_t* uri8;
    #undef	RETURN_TYPE_uri8
    #define	RETURN_TYPE_uri8 belle_sip_uri_t*

    belle_generic_uri_t* generic_uri9;
    #undef	RETURN_TYPE_generic_uri9
    #define	RETURN_TYPE_generic_uri9 belle_generic_uri_t*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_request_lineTop = pbelle_sip_messageParser_request_linePush(ctx);
    	(SCOPE_TOP(request_line))->current= belle_sip_request_new(); ret=	(SCOPE_TOP(request_line))->current; 
    uri8 = NULL;
    generic_uri9 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:124:2: ( method SP ( uri | generic_uri ) SP sip_version CRLF )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:124:6: method SP ( uri | generic_uri ) SP sip_version CRLF
        {
            FOLLOWPUSH(FOLLOW_method_in_request_line261);
            method7=method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_request_linePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_request_set_method(	(SCOPE_TOP(request_line))->current,(const char*)((STRSTREAM->toStringTT(STRSTREAM, method7.start, method7.stop))->chars));
            }
             MATCHT(SP, &FOLLOW_SP_in_request_line271); 
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_request_linePop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:126:6: ( uri | generic_uri )
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                case HEX_CHAR:
                case COMMON_CHAR:
                	{

                		{
                		    int LA4_1 = LA(2);
                		    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) ) 
                		    {
                		        alt4=1;
                		    }
                		    else if ( (ANTLR3_TRUE) ) 
                		    {
                		        alt4=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sip_messageParser_request_linePop(ctx);

                		            return ret;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 4;
                		        EXCEPTION->state        = 1;


                		        goto rulerequest_lineEx;
                		    }
                		}
                	}
                    break;
                case DIGIT:
                case DOT:
                case PLUS:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case PERCENT:
                case BQUOTE:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt4=1;
                	}
                    break;
                case SLASH:
                	{
                		alt4=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        pbelle_sip_messageParser_request_linePop(ctx);

                        return ret;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 4;
                    EXCEPTION->state        = 0;


                    goto rulerequest_lineEx;
                }

                switch (alt4) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:126:8: uri
            	    {
            	        FOLLOWPUSH(FOLLOW_uri_in_request_line281);
            	        uri8=uri(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerequest_lineEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_request_linePop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_request_set_uri(	(SCOPE_TOP(request_line))->current,uri8);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:128:7: generic_uri
            	    {
            	        FOLLOWPUSH(FOLLOW_generic_uri_in_request_line301);
            	        generic_uri9=generic_uri(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerequest_lineEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_request_linePop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_request_set_absolute_uri(	(SCOPE_TOP(request_line))->current,generic_uri9);
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(SP, &FOLLOW_SP_in_request_line319); 
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_request_linePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sip_version_in_request_line327);
            sip_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_request_linePop(ctx);

                return ret;
            }
             MATCHT(CRLF, &FOLLOW_CRLF_in_request_line335); 
            if  (HASEXCEPTION())
            {
                goto rulerequest_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_request_linePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerequest_lineEx; /* Prevent compiler warnings */
    rulerequest_lineEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(request_line))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_request_linePop(ctx);

    return ret;
}
/* $ANTLR end request_line */

/** 
 * $ANTLR start sip_version
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:139:1: sip_version : {...}? generic_version ;
 */
static void
sip_version(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:140:2: ({...}? generic_version )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:140:5: {...}? generic_version
        {
            if ( !((IS_TOKEN(SIP/))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(SIP/)";
                    EXCEPTION->ruleName	 = (void *)"sip_version";


            }
            FOLLOWPUSH(FOLLOW_generic_version_in_sip_version357);
            generic_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_versionEx; /* Prevent compiler warnings */
    rulesip_versionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sip_version */

/** 
 * $ANTLR start generic_version
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:143:1: generic_version : ( alpha )+ SLASH DIGIT DOT DIGIT ;
 */
static void
generic_version(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:143:16: ( ( alpha )+ SLASH DIGIT DOT DIGIT )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:143:18: ( alpha )+ SLASH DIGIT DOT DIGIT
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:143:18: ( alpha )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( LA(1) ) 
            	{
            	case HEX_CHAR:
            	case COMMON_CHAR:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:143:18: alpha
            	        {
            	            FOLLOWPUSH(FOLLOW_alpha_in_generic_version366);
            	            alpha(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulegeneric_versionEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulegeneric_versionEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }
             MATCHT(SLASH, &FOLLOW_SLASH_in_generic_version369); 
            if  (HASEXCEPTION())
            {
                goto rulegeneric_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_generic_version371); 
            if  (HASEXCEPTION())
            {
                goto rulegeneric_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DOT, &FOLLOW_DOT_in_generic_version373); 
            if  (HASEXCEPTION())
            {
                goto rulegeneric_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_generic_version375); 
            if  (HASEXCEPTION())
            {
                goto rulegeneric_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulegeneric_versionEx; /* Prevent compiler warnings */
    rulegeneric_versionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end generic_version */

/** 
 * $ANTLR start message_header
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:145:1: message_header[belle_sip_message_t* message] : ( header_extension_base[(BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_request_t) ||BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_response_t)) ] ) CRLF ;
 */
static void
message_header(pbelle_sip_messageParser ctx, belle_sip_message_t* message)
{   
    belle_sip_header_t* header_extension_base10;
    #undef	RETURN_TYPE_header_extension_base10
    #define	RETURN_TYPE_header_extension_base10 belle_sip_header_t*

    /* Initialize rule variables
     */


    header_extension_base10 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:147:2: ( ( header_extension_base[(BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_request_t) ||BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_response_t)) ] ) CRLF )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:147:15: ( header_extension_base[(BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_request_t) ||BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_response_t)) ] ) CRLF
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:147:15: ( header_extension_base[(BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_request_t) ||BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_response_t)) ] )
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:191:19: header_extension_base[(BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_request_t) ||BELLE_SIP_OBJECT_IS_INSTANCE_OF($message,belle_http_response_t)) ]
            {
                FOLLOWPUSH(FOLLOW_header_extension_base_in_message_header451);
                header_extension_base10=header_extension_base(ctx, (BELLE_SIP_OBJECT_IS_INSTANCE_OF(message,belle_http_request_t) ||BELLE_SIP_OBJECT_IS_INSTANCE_OF(message,belle_http_response_t)));

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulemessage_headerEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                if ( BACKTRACKING==0 ) 
                {

                                        belle_sip_header_t* lheader = BELLE_SIP_HEADER(header_extension_base10);
                                        do {
                                          if (lheader == NULL) break; /*sanity check*/
                                          
                                          belle_sip_message_add_header(message,lheader);
                                          }
                                        while((lheader=belle_sip_header_get_next(lheader)) != NULL); 
                }

            }

             MATCHT(CRLF, &FOLLOW_CRLF_in_message_header475); 
            if  (HASEXCEPTION())
            {
                goto rulemessage_headerEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_headerEx; /* Prevent compiler warnings */
    rulemessage_headerEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end message_header */

/** 
 * $ANTLR start method
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:214:1: method : extension_method ;
 */
static belle_sip_messageParser_method_return
method(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_method_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:214:9: ( extension_method )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:214:81: extension_method
        {
            FOLLOWPUSH(FOLLOW_extension_method_in_method522);
            extension_method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemethodEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemethodEx; /* Prevent compiler warnings */
    rulemethodEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end method */

/** 
 * $ANTLR start extension_method
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:216:1: extension_method : token ;
 */
static void
extension_method(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:217:2: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:217:6: token
        {
            FOLLOWPUSH(FOLLOW_token_in_extension_method536);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextension_methodEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextension_methodEx; /* Prevent compiler warnings */
    ruleextension_methodEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end extension_method */

/** 
 * $ANTLR start common_response
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:219:1: common_response returns [belle_sip_message_t* ret=NULL] : ( ( sip_version (~ ( CRLF ) )* CRLF )=> status_line | ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line ) ( ( message_header[BELLE_SIP_MESSAGE($ret)] )+ last_crlf= CRLF )? ;
 */
static belle_sip_message_t*
common_response(pbelle_sip_messageParser ctx)
{   
    belle_sip_message_t* ret = NULL;

    pANTLR3_COMMON_TOKEN    last_crlf;
    belle_sip_response_t* status_line11;
    #undef	RETURN_TYPE_status_line11
    #define	RETURN_TYPE_status_line11 belle_sip_response_t*

    belle_http_response_t* http_status_line12;
    #undef	RETURN_TYPE_http_status_line12
    #define	RETURN_TYPE_http_status_line12 belle_http_response_t*

    /* Initialize rule variables
     */


    last_crlf       = NULL;
    status_line11 = NULL;
    http_status_line12 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:3: ( ( ( sip_version (~ ( CRLF ) )* CRLF )=> status_line | ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line ) ( ( message_header[BELLE_SIP_MESSAGE($ret)] )+ last_crlf= CRLF )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:7: ( ( sip_version (~ ( CRLF ) )* CRLF )=> status_line | ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line ) ( ( message_header[BELLE_SIP_MESSAGE($ret)] )+ last_crlf= CRLF )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:7: ( ( sip_version (~ ( CRLF ) )* CRLF )=> status_line | ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line )
            {
                int alt6=2;
                alt6 = cdfa6.predict(ctx, RECOGNIZER, ISTREAM, &cdfa6);
                if  (HASEXCEPTION())
                {
                    goto rulecommon_responseEx;
                }
                if (HASFAILED())
                {
                    return ret;
                }
                switch (alt6) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:11: ( sip_version (~ ( CRLF ) )* CRLF )=> status_line
            	    {
            	        FOLLOWPUSH(FOLLOW_status_line_in_common_response573);
            	        status_line11=status_line(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommon_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            ret=BELLE_SIP_MESSAGE(status_line11);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:221:11: ( http_version (~ ( CRLF ) )* CRLF )=> http_status_line
            	    {
            	        FOLLOWPUSH(FOLLOW_http_status_line_in_common_response604);
            	        http_status_line12=http_status_line(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommon_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            ret=BELLE_SIP_MESSAGE(http_status_line12);
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:222:3: ( ( message_header[BELLE_SIP_MESSAGE($ret)] )+ last_crlf= CRLF )?
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                    case DIGIT:
                    case DOT:
                    case PLUS:
                    case DASH:
                    case STAR:
                    case LPAREN:
                    case RPAREN:
                    case PERCENT:
                    case BQUOTE:
                    case HEX_CHAR:
                    case COMMON_CHAR:
                    case USCORE:
                    case EMARK:
                    case TILDE:
                    case SQUOTE:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:222:4: ( message_header[BELLE_SIP_MESSAGE($ret)] )+ last_crlf= CRLF
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:222:4: ( message_header[BELLE_SIP_MESSAGE($ret)] )+
            	        {
            	            int cnt7=0;

            	            for (;;)
            	            {
            	                int alt7=2;
            	        	switch ( LA(1) ) 
            	        	{
            	        	case DIGIT:
            	        	case DOT:
            	        	case PLUS:
            	        	case DASH:
            	        	case STAR:
            	        	case LPAREN:
            	        	case RPAREN:
            	        	case PERCENT:
            	        	case BQUOTE:
            	        	case HEX_CHAR:
            	        	case COMMON_CHAR:
            	        	case USCORE:
            	        	case EMARK:
            	        	case TILDE:
            	        	case SQUOTE:
            	        		{
            	        			alt7=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt7) 
            	        	{
            	        	    case 1:
            	        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:222:4: message_header[BELLE_SIP_MESSAGE($ret)]
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_message_header_in_common_response612);
            	        	            message_header(ctx, BELLE_SIP_MESSAGE(ret));

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulecommon_responseEx;
            	        	            }
            	        	            if (HASFAILED())
            	        	            {
            	        	                return ret;
            	        	            }

            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt7 >= 1 )
            	        		{
            	        		    goto loop7;
            	        		}
            	        		if (BACKTRACKING>0)
            	        		{
            	        		    FAILEDFLAG = ANTLR3_TRUE;
            	        		    return ret;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulecommon_responseEx;
            	        	}
            	        	cnt7++;
            	            }
            	            loop7: ;	/* Jump to here if this rule does not match */
            	        }
            	        last_crlf = (pANTLR3_COMMON_TOKEN) MATCHT(CRLF, &FOLLOW_CRLF_in_common_response618); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommon_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            *(	(SCOPE_TOP(message_raw))->message_length)=last_crlf->user1;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommon_responseEx; /* Prevent compiler warnings */
    rulecommon_responseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end common_response */

/** 
 * $ANTLR start response
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:224:1: response returns [belle_sip_response_t* ret=NULL] : common_response ;
 */
static belle_sip_response_t*
response(pbelle_sip_messageParser ctx)
{   
    belle_sip_response_t* ret = NULL;

    belle_sip_message_t* common_response13;
    #undef	RETURN_TYPE_common_response13
    #define	RETURN_TYPE_common_response13 belle_sip_message_t*

    /* Initialize rule variables
     */


    common_response13 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:225:2: ( common_response )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:225:6: common_response
        {
            FOLLOWPUSH(FOLLOW_common_response_in_response642);
            common_response13=common_response(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleresponseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=BELLE_SIP_RESPONSE(common_response13);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleresponseEx; /* Prevent compiler warnings */
    ruleresponseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end response */

/** 
 * $ANTLR start status_line
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:227:1: status_line returns [belle_sip_response_t* ret=NULL] : sip_version SP status_code SP reason_phrase CRLF ;
 */
static belle_sip_response_t*
status_line(pbelle_sip_messageParser ctx)
{   
    belle_sip_response_t* ret = NULL;

    belle_sip_messageParser_status_code_return status_code14;
    #undef	RETURN_TYPE_status_code14
    #define	RETURN_TYPE_status_code14 belle_sip_messageParser_status_code_return

    belle_sip_messageParser_reason_phrase_return reason_phrase15;
    #undef	RETURN_TYPE_reason_phrase15
    #define	RETURN_TYPE_reason_phrase15 belle_sip_messageParser_reason_phrase_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_status_lineTop = pbelle_sip_messageParser_status_linePush(ctx);
    ret= belle_sip_response_new(); 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:230:2: ( sip_version SP status_code SP reason_phrase CRLF )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:230:6: sip_version SP status_code SP reason_phrase CRLF
        {
            FOLLOWPUSH(FOLLOW_sip_version_in_status_line673);
            sip_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }
             MATCHT(SP, &FOLLOW_SP_in_status_line680); 
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_status_code_in_status_line682);
            status_code14=status_code(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_response_set_status_code(ret,atoi((char*)(STRSTREAM->toStringTT(STRSTREAM, status_code14.start, status_code14.stop))->chars));
            }
             MATCHT(SP, &FOLLOW_SP_in_status_line690); 
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_reason_phrase_in_status_line692);
            reason_phrase15=reason_phrase(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_response_set_reason_phrase(ret,(char*)(STRSTREAM->toStringTT(STRSTREAM, reason_phrase15.start, reason_phrase15.stop))->chars);
            }
             MATCHT(CRLF, &FOLLOW_CRLF_in_status_line700); 
            if  (HASEXCEPTION())
            {
                goto rulestatus_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_status_linePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatus_lineEx; /* Prevent compiler warnings */
    rulestatus_lineEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref( ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_status_linePop(ctx);

    return ret;
}
/* $ANTLR end status_line */

/** 
 * $ANTLR start status_code
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:242:1: status_code : extension_code ;
 */
static belle_sip_messageParser_status_code_return
status_code(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_status_code_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:243:2: ( extension_code )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:243:4: extension_code
        {
            FOLLOWPUSH(FOLLOW_extension_code_in_status_code724);
            extension_code(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestatus_codeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestatus_codeEx; /* Prevent compiler warnings */
    rulestatus_codeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end status_code */

/** 
 * $ANTLR start extension_code
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:245:1: extension_code : DIGIT DIGIT DIGIT ;
 */
static void
extension_code(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:246:2: ( DIGIT DIGIT DIGIT )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:246:6: DIGIT DIGIT DIGIT
        {
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_extension_code737); 
            if  (HASEXCEPTION())
            {
                goto ruleextension_codeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_extension_code739); 
            if  (HASEXCEPTION())
            {
                goto ruleextension_codeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_extension_code741); 
            if  (HASEXCEPTION())
            {
                goto ruleextension_codeEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleextension_codeEx; /* Prevent compiler warnings */
    ruleextension_codeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end extension_code */

/** 
 * $ANTLR start reason_phrase
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:247:1: reason_phrase : (~ ( CRLF ) )* ;
 */
static belle_sip_messageParser_reason_phrase_return
reason_phrase(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_reason_phrase_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:248:2: ( (~ ( CRLF ) )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:248:6: (~ ( CRLF ) )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:248:6: (~ ( CRLF ) )*

            for (;;)
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                case SP:
                case SLASH:
                case DIGIT:
                case DOT:
                case COLON:
                case AT:
                case AND:
                case EQUAL:
                case PLUS:
                case DOLLARD:
                case COMMA:
                case SEMI:
                case QMARK:
                case DASH:
                case DQUOTE:
                case BSLASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case OCTET:
                case LSBRAQUET:
                case RSBRAQUET:
                case PERCENT:
                case BQUOTE:
                case HEX_CHAR:
                case COMMON_CHAR:
                case LAQUOT:
                case RAQUOT:
                case LBRACE:
                case RBRACE:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                case HTAB:
                case OR:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:248:6: ~ ( CRLF )
            	    {
            	        if ( ((LA(1) >= SP) && (LA(1) <= OR)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_reason_phrase754;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_reason_phrase754);    goto rulereason_phraseEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereason_phraseEx; /* Prevent compiler warnings */
    rulereason_phraseEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end reason_phrase */

/** 
 * $ANTLR start http_request
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:253:1: http_request returns [belle_http_request_t* ret=NULL] : common_request ;
 */
static belle_http_request_t*
http_request(pbelle_sip_messageParser ctx)
{   
    belle_http_request_t* ret = NULL;

    belle_sip_message_t* common_request16;
    #undef	RETURN_TYPE_common_request16
    #define	RETURN_TYPE_common_request16 belle_sip_message_t*

    /* Initialize rule variables
     */


    common_request16 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:254:3: ( common_request )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:254:4: common_request
        {
            FOLLOWPUSH(FOLLOW_common_request_in_http_request777);
            common_request16=common_request(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_requestEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=BELLE_HTTP_REQUEST(common_request16);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehttp_requestEx; /* Prevent compiler warnings */
    rulehttp_requestEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end http_request */

/** 
 * $ANTLR start http_request_line
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:256:1: http_request_line returns [belle_http_request_t *ret=NULL] : method SP ( generic_uri )=> generic_uri SP http_version CRLF ;
 */
static belle_http_request_t *
http_request_line(pbelle_sip_messageParser ctx)
{   
    belle_http_request_t * ret = NULL;

    belle_sip_messageParser_method_return method17;
    #undef	RETURN_TYPE_method17
    #define	RETURN_TYPE_method17 belle_sip_messageParser_method_return

    belle_generic_uri_t* generic_uri18;
    #undef	RETURN_TYPE_generic_uri18
    #define	RETURN_TYPE_generic_uri18 belle_generic_uri_t*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_http_request_lineTop = pbelle_sip_messageParser_http_request_linePush(ctx);
    	(SCOPE_TOP(http_request_line))->current= belle_http_request_new(); ret=	(SCOPE_TOP(http_request_line))->current; 
    generic_uri18 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:259:3: ( method SP ( generic_uri )=> generic_uri SP http_version CRLF )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:259:5: method SP ( generic_uri )=> generic_uri SP http_version CRLF
        {
            FOLLOWPUSH(FOLLOW_method_in_http_request_line805);
            method17=method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_request_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_http_request_linePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_http_request_set_method(	(SCOPE_TOP(http_request_line))->current,(const char*)((STRSTREAM->toStringTT(STRSTREAM, method17.start, method17.stop))->chars));
            }
             MATCHT(SP, &FOLLOW_SP_in_http_request_line814); 
            if  (HASEXCEPTION())
            {
                goto rulehttp_request_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_http_request_linePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_generic_uri_in_http_request_line825);
            generic_uri18=generic_uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_request_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_http_request_linePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_http_request_set_uri(	(SCOPE_TOP(http_request_line))->current,generic_uri18);
            }
             MATCHT(SP, &FOLLOW_SP_in_http_request_line833); 
            if  (HASEXCEPTION())
            {
                goto rulehttp_request_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_http_request_linePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_http_version_in_http_request_line840);
            http_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_request_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_http_request_linePop(ctx);

                return ret;
            }
             MATCHT(CRLF, &FOLLOW_CRLF_in_http_request_line842); 
            if  (HASEXCEPTION())
            {
                goto rulehttp_request_lineEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_http_request_linePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehttp_request_lineEx; /* Prevent compiler warnings */
    rulehttp_request_lineEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(http_request_line))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_http_request_linePop(ctx);

    return ret;
}
/* $ANTLR end http_request_line */

/** 
 * $ANTLR start http_version
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:271:1: http_version : {...}? generic_version ;
 */
static void
http_version(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:271:13: ({...}? generic_version )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:271:16: {...}? generic_version
        {
            if ( !((IS_TOKEN(HTTP/))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(HTTP/)";
                    EXCEPTION->ruleName	 = (void *)"http_version";


            }
            FOLLOWPUSH(FOLLOW_generic_version_in_http_version859);
            generic_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehttp_versionEx; /* Prevent compiler warnings */
    rulehttp_versionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end http_version */

/** 
 * $ANTLR start http_response
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:273:1: http_response returns [belle_http_response_t* ret=NULL] : common_response ;
 */
static belle_http_response_t*
http_response(pbelle_sip_messageParser ctx)
{   
    belle_http_response_t* ret = NULL;

    belle_sip_message_t* common_response19;
    #undef	RETURN_TYPE_common_response19
    #define	RETURN_TYPE_common_response19 belle_sip_message_t*

    /* Initialize rule variables
     */


    common_response19 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:274:3: ( common_response )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:274:7: common_response
        {
            FOLLOWPUSH(FOLLOW_common_response_in_http_response876);
            common_response19=common_response(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_responseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=BELLE_HTTP_RESPONSE(common_response19);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehttp_responseEx; /* Prevent compiler warnings */
    rulehttp_responseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end http_response */

/** 
 * $ANTLR start http_status_line
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:276:1: http_status_line returns [belle_http_response_t* ret] : http_version SP status_code SP reason_phrase CRLF ;
 */
static belle_http_response_t*
http_status_line(pbelle_sip_messageParser ctx)
{   
    belle_http_response_t* ret = NULL;

    belle_sip_messageParser_status_code_return status_code20;
    #undef	RETURN_TYPE_status_code20
    #define	RETURN_TYPE_status_code20 belle_sip_messageParser_status_code_return

    belle_sip_messageParser_reason_phrase_return reason_phrase21;
    #undef	RETURN_TYPE_reason_phrase21
    #define	RETURN_TYPE_reason_phrase21 belle_sip_messageParser_reason_phrase_return

    /* Initialize rule variables
     */


    ret= belle_http_response_new();  
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:278:3: ( http_version SP status_code SP reason_phrase CRLF )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:278:7: http_version SP status_code SP reason_phrase CRLF
        {
            FOLLOWPUSH(FOLLOW_http_version_in_http_status_line906);
            http_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_status_lineEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
             MATCHT(SP, &FOLLOW_SP_in_http_status_line914); 
            if  (HASEXCEPTION())
            {
                goto rulehttp_status_lineEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_status_code_in_http_status_line916);
            status_code20=status_code(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_status_lineEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_http_response_set_status_code(ret,atoi((char*)(STRSTREAM->toStringTT(STRSTREAM, status_code20.start, status_code20.stop))->chars));
            }
             MATCHT(SP, &FOLLOW_SP_in_http_status_line925); 
            if  (HASEXCEPTION())
            {
                goto rulehttp_status_lineEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_reason_phrase_in_http_status_line927);
            reason_phrase21=reason_phrase(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehttp_status_lineEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_http_response_set_reason_phrase(ret,(char*)(STRSTREAM->toStringTT(STRSTREAM, reason_phrase21.start, reason_phrase21.stop))->chars);
            }
             MATCHT(CRLF, &FOLLOW_CRLF_in_http_status_line936); 
            if  (HASEXCEPTION())
            {
                goto rulehttp_status_lineEx;
            }
            if (HASFAILED())
            {
                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehttp_status_lineEx; /* Prevent compiler warnings */
    rulehttp_status_lineEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref( ret);
	       ret=NULL;

	}


    }
    else
    {
    }

    return ret;
}
/* $ANTLR end http_status_line */

/** 
 * $ANTLR start opaque_part_for_from_to_contact_addr_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:300:1: opaque_part_for_from_to_contact_addr_spec : uric_no_slash_for_from_to_contact_addr_spec ( uric_for_from_to_contact_addr_spec )* ;
 */
static belle_sip_messageParser_opaque_part_for_from_to_contact_addr_spec_return
opaque_part_for_from_to_contact_addr_spec(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_opaque_part_for_from_to_contact_addr_spec_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:301:2: ( uric_no_slash_for_from_to_contact_addr_spec ( uric_for_from_to_contact_addr_spec )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:301:5: uric_no_slash_for_from_to_contact_addr_spec ( uric_for_from_to_contact_addr_spec )*
        {
            FOLLOWPUSH(FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec966);
            uric_no_slash_for_from_to_contact_addr_spec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaque_part_for_from_to_contact_addr_specEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:301:49: ( uric_for_from_to_contact_addr_spec )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                case SLASH:
                case DIGIT:
                case DOT:
                case COLON:
                case AT:
                case AND:
                case EQUAL:
                case PLUS:
                case DOLLARD:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case PERCENT:
                case HEX_CHAR:
                case COMMON_CHAR:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:301:49: uric_for_from_to_contact_addr_spec
            	    {
            	        FOLLOWPUSH(FOLLOW_uric_for_from_to_contact_addr_spec_in_opaque_part_for_from_to_contact_addr_spec968);
            	        uric_for_from_to_contact_addr_spec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleopaque_part_for_from_to_contact_addr_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleopaque_part_for_from_to_contact_addr_specEx; /* Prevent compiler warnings */
    ruleopaque_part_for_from_to_contact_addr_specEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end opaque_part_for_from_to_contact_addr_spec */

/** 
 * $ANTLR start opaque_part
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:302:1: opaque_part : uric_no_slash ( uric )* ;
 */
static belle_sip_messageParser_opaque_part_return
opaque_part(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_opaque_part_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:303:2: ( uric_no_slash ( uric )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:303:5: uric_no_slash ( uric )*
        {
            FOLLOWPUSH(FOLLOW_uric_no_slash_in_opaque_part978);
            uric_no_slash(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaque_partEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:303:19: ( uric )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                case SLASH:
                case DIGIT:
                case DOT:
                case COLON:
                case AT:
                case AND:
                case EQUAL:
                case PLUS:
                case DOLLARD:
                case COMMA:
                case SEMI:
                case QMARK:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case PERCENT:
                case HEX_CHAR:
                case COMMON_CHAR:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:303:19: uric
            	    {
            	        FOLLOWPUSH(FOLLOW_uric_in_opaque_part980);
            	        uric(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleopaque_partEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleopaque_partEx; /* Prevent compiler warnings */
    ruleopaque_partEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end opaque_part */

/** 
 * $ANTLR start uric_no_slash_for_from_to_contact_addr_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:305:1: uric_no_slash_for_from_to_contact_addr_spec : ( unreserved | escaped | COLON | AT | AND | EQUAL | PLUS | DOLLARD );
 */
static void
uric_no_slash_for_from_to_contact_addr_spec(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:2: ( unreserved | escaped | COLON | AT | AND | EQUAL | PLUS | DOLLARD )
            
            ANTLR3_UINT32 alt12;

            alt12=8;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case DOT:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt12=1;
            	}
                break;
            case PERCENT:
            	{
            		alt12=2;
            	}
                break;
            case COLON:
            	{
            		alt12=3;
            	}
                break;
            case AT:
            	{
            		alt12=4;
            	}
                break;
            case AND:
            	{
            		alt12=5;
            	}
                break;
            case EQUAL:
            	{
            		alt12=6;
            	}
                break;
            case PLUS:
            	{
            		alt12=7;
            	}
                break;
            case DOLLARD:
            	{
            		alt12=8;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
            }

            switch (alt12) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:4: unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_unreserved_in_uric_no_slash_for_from_to_contact_addr_spec991);
        	        unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:17: escaped
        	    {
        	        FOLLOWPUSH(FOLLOW_escaped_in_uric_no_slash_for_from_to_contact_addr_spec995);
        	        escaped(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:28: COLON
        	    {
        	         MATCHT(COLON, &FOLLOW_COLON_in_uric_no_slash_for_from_to_contact_addr_spec1000); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:36: AT
        	    {
        	         MATCHT(AT, &FOLLOW_AT_in_uric_no_slash_for_from_to_contact_addr_spec1004); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 5:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:40: AND
        	    {
        	         MATCHT(AND, &FOLLOW_AND_in_uric_no_slash_for_from_to_contact_addr_spec1007); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 6:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:46: EQUAL
        	    {
        	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_uric_no_slash_for_from_to_contact_addr_spec1011); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 7:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:54: PLUS
        	    {
        	         MATCHT(PLUS, &FOLLOW_PLUS_in_uric_no_slash_for_from_to_contact_addr_spec1015); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 8:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:306:61: DOLLARD
        	    {
        	         MATCHT(DOLLARD, &FOLLOW_DOLLARD_in_uric_no_slash_for_from_to_contact_addr_spec1019); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slash_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleuric_no_slash_for_from_to_contact_addr_specEx; /* Prevent compiler warnings */
    ruleuric_no_slash_for_from_to_contact_addr_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end uric_no_slash_for_from_to_contact_addr_spec */

/** 
 * $ANTLR start uric_no_slash
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:307:1: uric_no_slash : ( COMMA | SEMI | QMARK | uric_no_slash_for_from_to_contact_addr_spec );
 */
static void
uric_no_slash(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:308:2: ( COMMA | SEMI | QMARK | uric_no_slash_for_from_to_contact_addr_spec )
            
            ANTLR3_UINT32 alt13;

            alt13=4;

            switch ( LA(1) ) 
            {
            case COMMA:
            	{
            		alt13=1;
            	}
                break;
            case SEMI:
            	{
            		alt13=2;
            	}
                break;
            case QMARK:
            	{
            		alt13=3;
            	}
                break;
            case DIGIT:
            case DOT:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case PERCENT:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt13=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto ruleuric_no_slashEx;
            }

            switch (alt13) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:308:3: COMMA
        	    {
        	         MATCHT(COMMA, &FOLLOW_COMMA_in_uric_no_slash1027); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slashEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:308:11: SEMI
        	    {
        	         MATCHT(SEMI, &FOLLOW_SEMI_in_uric_no_slash1031); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slashEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:308:18: QMARK
        	    {
        	         MATCHT(QMARK, &FOLLOW_QMARK_in_uric_no_slash1035); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slashEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:308:27: uric_no_slash_for_from_to_contact_addr_spec
        	    {
        	        FOLLOWPUSH(FOLLOW_uric_no_slash_for_from_to_contact_addr_spec_in_uric_no_slash1040);
        	        uric_no_slash_for_from_to_contact_addr_spec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_no_slashEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleuric_no_slashEx; /* Prevent compiler warnings */
    ruleuric_no_slashEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end uric_no_slash */

/** 
 * $ANTLR start scheme
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:2: scheme : alpha ( alphanum | PLUS | DASH | DOT )* ;
 */
static belle_sip_messageParser_scheme_return
scheme(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_scheme_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:8: ( alpha ( alphanum | PLUS | DASH | DOT )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:10: alpha ( alphanum | PLUS | DASH | DOT )*
        {
            FOLLOWPUSH(FOLLOW_alpha_in_scheme1067);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleschemeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:16: ( alphanum | PLUS | DASH | DOT )*

            for (;;)
            {
                int alt14=5;
                switch ( LA(1) ) 
                {
                case DIGIT:
                case HEX_CHAR:
                case COMMON_CHAR:
                	{
                		alt14=1;
                	}
                    break;
                case PLUS:
                	{
                		alt14=2;
                	}
                    break;
                case DASH:
                	{
                		alt14=3;
                	}
                    break;
                case DOT:
                	{
                		alt14=4;
                	}
                    break;

                }

                switch (alt14) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:18: alphanum
            	    {
            	        FOLLOWPUSH(FOLLOW_alphanum_in_scheme1071);
            	        alphanum(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:29: PLUS
            	    {
            	         MATCHT(PLUS, &FOLLOW_PLUS_in_scheme1075); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 3:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:36: DASH
            	    {
            	         MATCHT(DASH, &FOLLOW_DASH_in_scheme1079); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 4:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:310:43: DOT
            	    {
            	         MATCHT(DOT, &FOLLOW_DOT_in_scheme1083); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleschemeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleschemeEx; /* Prevent compiler warnings */
    ruleschemeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end scheme */

/** 
 * $ANTLR start generic_uri_for_from_to_contact_addr_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:314:1: generic_uri_for_from_to_contact_addr_spec returns [belle_generic_uri_t* ret=NULL] : scheme COLON opaque_part_for_from_to_contact_addr_spec ;
 */
static belle_generic_uri_t*
generic_uri_for_from_to_contact_addr_spec(pbelle_sip_messageParser ctx)
{   
    belle_generic_uri_t* ret = NULL;

    belle_sip_messageParser_scheme_return scheme22;
    #undef	RETURN_TYPE_scheme22
    #define	RETURN_TYPE_scheme22 belle_sip_messageParser_scheme_return

    belle_sip_messageParser_opaque_part_for_from_to_contact_addr_spec_return opaque_part_for_from_to_contact_addr_spec23;
    #undef	RETURN_TYPE_opaque_part_for_from_to_contact_addr_spec23
    #define	RETURN_TYPE_opaque_part_for_from_to_contact_addr_spec23 belle_sip_messageParser_opaque_part_for_from_to_contact_addr_spec_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specTop = pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPush(ctx);
     	(SCOPE_TOP(generic_uri_for_from_to_contact_addr_spec))->current= ret = belle_generic_uri_new(); 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:317:4: ( scheme COLON opaque_part_for_from_to_contact_addr_spec )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:317:6: scheme COLON opaque_part_for_from_to_contact_addr_spec
        {
            FOLLOWPUSH(FOLLOW_scheme_in_generic_uri_for_from_to_contact_addr_spec1117);
            scheme22=scheme(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegeneric_uri_for_from_to_contact_addr_specEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_generic_uri_set_scheme(	(SCOPE_TOP(generic_uri_for_from_to_contact_addr_spec))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, scheme22.start, scheme22.stop))->chars);
            }
             MATCHT(COLON, &FOLLOW_COLON_in_generic_uri_for_from_to_contact_addr_spec1126); 
            if  (HASEXCEPTION())
            {
                goto rulegeneric_uri_for_from_to_contact_addr_specEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_opaque_part_for_from_to_contact_addr_spec_in_generic_uri_for_from_to_contact_addr_spec1129);
            opaque_part_for_from_to_contact_addr_spec23=opaque_part_for_from_to_contact_addr_spec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegeneric_uri_for_from_to_contact_addr_specEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_generic_uri_set_opaque_part(	(SCOPE_TOP(generic_uri_for_from_to_contact_addr_spec))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, opaque_part_for_from_to_contact_addr_spec23.start, opaque_part_for_from_to_contact_addr_spec23.stop))->chars) ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulegeneric_uri_for_from_to_contact_addr_specEx; /* Prevent compiler warnings */
    rulegeneric_uri_for_from_to_contact_addr_specEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(generic_uri))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_generic_uri_for_from_to_contact_addr_specPop(ctx);

    return ret;
}
/* $ANTLR end generic_uri_for_from_to_contact_addr_spec */

/** 
 * $ANTLR start generic_uri
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:328:1: generic_uri returns [belle_generic_uri_t* ret=NULL] : ( hier_part[$generic_uri::current] | ( scheme COLON ( opaque_part | hier_part[$generic_uri::current] ) ) );
 */
static belle_generic_uri_t*
generic_uri(pbelle_sip_messageParser ctx)
{   
    belle_generic_uri_t* ret = NULL;

    belle_sip_messageParser_scheme_return scheme24;
    #undef	RETURN_TYPE_scheme24
    #define	RETURN_TYPE_scheme24 belle_sip_messageParser_scheme_return

    belle_sip_messageParser_opaque_part_return opaque_part25;
    #undef	RETURN_TYPE_opaque_part25
    #define	RETURN_TYPE_opaque_part25 belle_sip_messageParser_opaque_part_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_generic_uriTop = pbelle_sip_messageParser_generic_uriPush(ctx);
     	(SCOPE_TOP(generic_uri))->current= ret = belle_generic_uri_new(); 
    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:331:4: ( hier_part[$generic_uri::current] | ( scheme COLON ( opaque_part | hier_part[$generic_uri::current] ) ) )
            
            ANTLR3_UINT32 alt16;

            alt16=2;

            switch ( LA(1) ) 
            {
            case SLASH:
            	{
            		alt16=1;
            	}
                break;
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		alt16=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_generic_uriPop(ctx);

                    return ret;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto rulegeneric_uriEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:331:7: hier_part[$generic_uri::current]
        	    {
        	        FOLLOWPUSH(FOLLOW_hier_part_in_generic_uri1171);
        	        hier_part(ctx, 	(SCOPE_TOP(generic_uri))->current);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneric_uriEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            pbelle_sip_messageParser_generic_uriPop(ctx);

        	            return ret;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:332:9: ( scheme COLON ( opaque_part | hier_part[$generic_uri::current] ) )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:332:9: ( scheme COLON ( opaque_part | hier_part[$generic_uri::current] ) )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:332:10: scheme COLON ( opaque_part | hier_part[$generic_uri::current] )
        	        {
        	            FOLLOWPUSH(FOLLOW_scheme_in_generic_uri1183);
        	            scheme24=scheme(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulegeneric_uriEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                pbelle_sip_messageParser_generic_uriPop(ctx);

        	                return ret;
        	            }
        	            if ( BACKTRACKING==0 ) 
        	            {
        	                belle_generic_uri_set_scheme(	(SCOPE_TOP(generic_uri))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, scheme24.start, scheme24.stop))->chars);
        	            }
        	             MATCHT(COLON, &FOLLOW_COLON_in_generic_uri1196); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulegeneric_uriEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                pbelle_sip_messageParser_generic_uriPop(ctx);

        	                return ret;
        	            }

        	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:333:15: ( opaque_part | hier_part[$generic_uri::current] )
        	            {
        	                int alt15=2;
        	                switch ( LA(1) ) 
        	                {
        	                case DIGIT:
        	                case DOT:
        	                case COLON:
        	                case AT:
        	                case AND:
        	                case EQUAL:
        	                case PLUS:
        	                case DOLLARD:
        	                case COMMA:
        	                case SEMI:
        	                case QMARK:
        	                case DASH:
        	                case STAR:
        	                case LPAREN:
        	                case RPAREN:
        	                case PERCENT:
        	                case HEX_CHAR:
        	                case COMMON_CHAR:
        	                case USCORE:
        	                case EMARK:
        	                case TILDE:
        	                case SQUOTE:
        	                	{
        	                		alt15=1;
        	                	}
        	                    break;
        	                case SLASH:
        	                	{
        	                		alt15=2;
        	                	}
        	                    break;

        	                default:
        	                    if (BACKTRACKING>0)
        	                    {
        	                        FAILEDFLAG = ANTLR3_TRUE;
        	                        pbelle_sip_messageParser_generic_uriPop(ctx);

        	                        return ret;
        	                    }
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"";
        	                    EXCEPTION->decisionNum  = 15;
        	                    EXCEPTION->state        = 0;


        	                    goto rulegeneric_uriEx;
        	                }

        	                switch (alt15) 
        	                {
        	            	case 1:
        	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:333:16: opaque_part
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_opaque_part_in_generic_uri1200);
        	            	        opaque_part25=opaque_part(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulegeneric_uriEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            pbelle_sip_messageParser_generic_uriPop(ctx);

        	            	            return ret;
        	            	        }
        	            	        if ( BACKTRACKING==0 ) 
        	            	        {
        	            	            belle_generic_uri_set_opaque_part(	(SCOPE_TOP(generic_uri))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, opaque_part25.start, opaque_part25.stop))->chars) ;
        	            	        }

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:334:11: hier_part[$generic_uri::current]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_hier_part_in_generic_uri1214);
        	            	        hier_part(ctx, 	(SCOPE_TOP(generic_uri))->current);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulegeneric_uriEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            pbelle_sip_messageParser_generic_uriPop(ctx);

        	            	            return ret;
        	            	        }

        	            	    }
        	            	    break;

        	                }
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulegeneric_uriEx; /* Prevent compiler warnings */
    rulegeneric_uriEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(generic_uri))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_generic_uriPop(ctx);

    return ret;
}
/* $ANTLR end generic_uri */

/** 
 * $ANTLR start hier_part
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:343:1: hier_part[belle_generic_uri_t* uri] returns [belle_generic_uri_t* ret=NULL] : ( ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] ) | ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? ) | ( path_segments[uri] ) ) ( QMARK query )? ;
 */
static belle_generic_uri_t*
hier_part(pbelle_sip_messageParser ctx, belle_generic_uri_t* uri)
{   
    belle_generic_uri_t* ret = NULL;

    belle_sip_messageParser_query_return query26;
    #undef	RETURN_TYPE_query26
    #define	RETURN_TYPE_query26 belle_sip_messageParser_query_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:344:1: ( ( ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] ) | ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? ) | ( path_segments[uri] ) ) ( QMARK query )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:344:5: ( ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] ) | ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? ) | ( path_segments[uri] ) ) ( QMARK query )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:344:5: ( ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] ) | ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? ) | ( path_segments[uri] ) )
            {
                int alt18=3;
                alt18 = cdfa18.predict(ctx, RECOGNIZER, ISTREAM, &cdfa18);
                if  (HASEXCEPTION())
                {
                    goto rulehier_partEx;
                }
                if (HASFAILED())
                {
                    return ret;
                }
                switch (alt18) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:345:2: ( SLASH SLASH path_segments[NULL] )=> ( SLASH SLASH path_segments[uri] )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:345:37: ( SLASH SLASH path_segments[uri] )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:345:39: SLASH SLASH path_segments[uri]
            	        {
            	             MATCHT(SLASH, &FOLLOW_SLASH_in_hier_part1263); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehier_partEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ret;
            	            }
            	             MATCHT(SLASH, &FOLLOW_SLASH_in_hier_part1265); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehier_partEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ret;
            	            }
            	            FOLLOWPUSH(FOLLOW_path_segments_in_hier_part1267);
            	            path_segments(ctx, uri);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehier_partEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ret;
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:3: ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )=> ( SLASH SLASH authority[uri] ( path_segments[uri] )? )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:57: ( SLASH SLASH authority[uri] ( path_segments[uri] )? )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:59: SLASH SLASH authority[uri] ( path_segments[uri] )?
            	        {
            	             MATCHT(SLASH, &FOLLOW_SLASH_in_hier_part1295); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehier_partEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ret;
            	            }
            	             MATCHT(SLASH, &FOLLOW_SLASH_in_hier_part1297); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehier_partEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ret;
            	            }
            	            FOLLOWPUSH(FOLLOW_authority_in_hier_part1299);
            	            authority(ctx, uri);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehier_partEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ret;
            	            }

            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:86: ( path_segments[uri] )?
            	            {
            	                int alt17=2;
            	                switch ( LA(1) ) 
            	                {
            	                    case SLASH:
            	                    	{
            	                    		alt17=1;
            	                    	}
            	                        break;
            	                }

            	                switch (alt17) 
            	                {
            	            	case 1:
            	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:87: path_segments[uri]
            	            	    {
            	            	        FOLLOWPUSH(FOLLOW_path_segments_in_hier_part1303);
            	            	        path_segments(ctx, uri);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto rulehier_partEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            return ret;
            	            	        }

            	            	    }
            	            	    break;

            	                }
            	            }

            	        }


            	    }
            	    break;
            	case 3:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:349:3: ( path_segments[uri] )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:349:3: ( path_segments[uri] )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:349:5: path_segments[uri]
            	        {
            	            FOLLOWPUSH(FOLLOW_path_segments_in_hier_part1319);
            	            path_segments(ctx, uri);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehier_partEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ret;
            	            }

            	        }


            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:350:3: ( QMARK query )?
            {
                int alt19=2;
                switch ( LA(1) ) 
                {
                    case QMARK:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:350:4: QMARK query
            	    {
            	         MATCHT(QMARK, &FOLLOW_QMARK_in_hier_part1329); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehier_partEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_query_in_hier_part1331);
            	        query26=query(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehier_partEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {

            	                        char* unescaped_query;
            	                        unescaped_query=belle_sip_to_unescaped_string((const char *)(STRSTREAM->toStringTT(STRSTREAM, query26.start, query26.stop))->chars);
            	                        belle_generic_uri_set_query(uri,(const char*)unescaped_query);
            	                        belle_sip_free(unescaped_query);
            	                        
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehier_partEx; /* Prevent compiler warnings */
    rulehier_partEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end hier_part */

/** 
 * $ANTLR start path_segments
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:358:1: path_segments[belle_generic_uri_t* uri] : SLASH ( segment ( SLASH segment )* ) ;
 */
static belle_sip_messageParser_path_segments_return
path_segments(pbelle_sip_messageParser ctx, belle_generic_uri_t* uri)
{   
    belle_sip_messageParser_path_segments_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:359:3: ( SLASH ( segment ( SLASH segment )* ) )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:359:5: SLASH ( segment ( SLASH segment )* )
        {
             MATCHT(SLASH, &FOLLOW_SLASH_in_path_segments1360); 
            if  (HASEXCEPTION())
            {
                goto rulepath_segmentsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:359:11: ( segment ( SLASH segment )* )
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:359:12: segment ( SLASH segment )*
            {
                FOLLOWPUSH(FOLLOW_segment_in_path_segments1363);
                segment(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulepath_segmentsEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:359:20: ( SLASH segment )*

                for (;;)
                {
                    int alt20=2;
                    switch ( LA(1) ) 
                    {
                    case SLASH:
                    	{
                    		alt20=1;
                    	}
                        break;

                    }

                    switch (alt20) 
                    {
                	case 1:
                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:359:22: SLASH segment
                	    {
                	         MATCHT(SLASH, &FOLLOW_SLASH_in_path_segments1367); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulepath_segmentsEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }
                	        FOLLOWPUSH(FOLLOW_segment_in_path_segments1369);
                	        segment(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulepath_segmentsEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return retval;
                	        }

                	    }
                	    break;

                	default:
                	    goto loop20;	/* break out of the loop */
                	    break;
                    }
                }
                loop20: ; /* Jump out to here if this rule does not match */


            }

            if ( BACKTRACKING==0 ) 
            {

                  char* unescaped_path;
                  unescaped_path=belle_sip_to_unescaped_string((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                  belle_generic_uri_set_path(uri,(const char*)unescaped_path);
                  belle_sip_free(unescaped_path);
                  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepath_segmentsEx; /* Prevent compiler warnings */
    rulepath_segmentsEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end path_segments */

/** 
 * $ANTLR start segment
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:366:1: segment : ( pchar )* ( SEMI param )* ;
 */
static void
segment(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:366:8: ( ( pchar )* ( SEMI param )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:366:10: ( pchar )* ( SEMI param )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:366:10: ( pchar )*

            for (;;)
            {
                int alt21=2;
                switch ( LA(1) ) 
                {
                case DIGIT:
                case DOT:
                case COLON:
                case AT:
                case AND:
                case EQUAL:
                case PLUS:
                case DOLLARD:
                case COMMA:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case PERCENT:
                case HEX_CHAR:
                case COMMON_CHAR:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt21=1;
                	}
                    break;

                }

                switch (alt21) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:366:10: pchar
            	    {
            	        FOLLOWPUSH(FOLLOW_pchar_in_segment1383);
            	        pchar(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesegmentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop21;	/* break out of the loop */
            	    break;
                }
            }
            loop21: ; /* Jump out to here if this rule does not match */


            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:366:17: ( SEMI param )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt22=1;
                	}
                    break;

                }

                switch (alt22) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:366:19: SEMI param
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_segment1388); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesegmentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_param_in_segment1390);
            	        param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesegmentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesegmentEx; /* Prevent compiler warnings */
    rulesegmentEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end segment */

/** 
 * $ANTLR start param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:367:1: param : ( pchar )* ;
 */
static void
param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:367:6: ( ( pchar )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:367:8: ( pchar )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:367:8: ( pchar )*

            for (;;)
            {
                int alt23=2;
                switch ( LA(1) ) 
                {
                case DIGIT:
                case DOT:
                case COLON:
                case AT:
                case AND:
                case EQUAL:
                case PLUS:
                case DOLLARD:
                case COMMA:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case PERCENT:
                case HEX_CHAR:
                case COMMON_CHAR:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt23=1;
                	}
                    break;

                }

                switch (alt23) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:367:8: pchar
            	    {
            	        FOLLOWPUSH(FOLLOW_pchar_in_param1399);
            	        pchar(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamEx; /* Prevent compiler warnings */
    ruleparamEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end param */

/** 
 * $ANTLR start pchar
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:1: pchar : ( unreserved | escaped | COLON | AT | AND | EQUAL | PLUS | DOLLARD | COMMA );
 */
static void
pchar(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:6: ( unreserved | escaped | COLON | AT | AND | EQUAL | PLUS | DOLLARD | COMMA )
            
            ANTLR3_UINT32 alt24;

            alt24=9;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case DOT:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt24=1;
            	}
                break;
            case PERCENT:
            	{
            		alt24=2;
            	}
                break;
            case COLON:
            	{
            		alt24=3;
            	}
                break;
            case AT:
            	{
            		alt24=4;
            	}
                break;
            case AND:
            	{
            		alt24=5;
            	}
                break;
            case EQUAL:
            	{
            		alt24=6;
            	}
                break;
            case PLUS:
            	{
            		alt24=7;
            	}
                break;
            case DOLLARD:
            	{
            		alt24=8;
            	}
                break;
            case COMMA:
            	{
            		alt24=9;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto rulepcharEx;
            }

            switch (alt24) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:9: unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_unreserved_in_pchar1407);
        	        unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:22: escaped
        	    {
        	        FOLLOWPUSH(FOLLOW_escaped_in_pchar1411);
        	        escaped(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:32: COLON
        	    {
        	         MATCHT(COLON, &FOLLOW_COLON_in_pchar1415); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:40: AT
        	    {
        	         MATCHT(AT, &FOLLOW_AT_in_pchar1419); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 5:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:45: AND
        	    {
        	         MATCHT(AND, &FOLLOW_AND_in_pchar1423); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 6:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:51: EQUAL
        	    {
        	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_pchar1427); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 7:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:59: PLUS
        	    {
        	         MATCHT(PLUS, &FOLLOW_PLUS_in_pchar1431); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 8:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:66: DOLLARD
        	    {
        	         MATCHT(DOLLARD, &FOLLOW_DOLLARD_in_pchar1435); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 9:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:368:76: COMMA
        	    {
        	         MATCHT(COMMA, &FOLLOW_COMMA_in_pchar1439); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulepcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulepcharEx; /* Prevent compiler warnings */
    rulepcharEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end pchar */

/** 
 * $ANTLR start query
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:370:1: query : ( uric )+ ;
 */
static belle_sip_messageParser_query_return
query(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_query_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:370:6: ( ( uric )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:370:8: ( uric )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:370:8: ( uric )+
            {
                int cnt25=0;

                for (;;)
                {
                    int alt25=2;
            	switch ( LA(1) ) 
            	{
            	case SLASH:
            	case DIGIT:
            	case DOT:
            	case COLON:
            	case AT:
            	case AND:
            	case EQUAL:
            	case PLUS:
            	case DOLLARD:
            	case COMMA:
            	case SEMI:
            	case QMARK:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case PERCENT:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt25=1;
            		}
            	    break;

            	}

            	switch (alt25) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:370:8: uric
            	        {
            	            FOLLOWPUSH(FOLLOW_uric_in_query1446);
            	            uric(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulequeryEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt25 >= 1 )
            		{
            		    goto loop25;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulequeryEx;
            	}
            	cnt25++;
                }
                loop25: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequeryEx; /* Prevent compiler warnings */
    rulequeryEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end query */

/** 
 * $ANTLR start uric
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:371:1: uric : ( reserved | unreserved | escaped );
 */
static void
uric(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:371:5: ( reserved | unreserved | escaped )
            
            ANTLR3_UINT32 alt26;

            alt26=3;

            switch ( LA(1) ) 
            {
            case SLASH:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            case COMMA:
            case SEMI:
            case QMARK:
            	{
            		alt26=1;
            	}
                break;
            case DIGIT:
            case DOT:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt26=2;
            	}
                break;
            case PERCENT:
            	{
            		alt26=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto ruleuricEx;
            }

            switch (alt26) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:371:7: reserved
        	    {
        	        FOLLOWPUSH(FOLLOW_reserved_in_uric1453);
        	        reserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuricEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:371:18: unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_unreserved_in_uric1457);
        	        unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuricEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:371:31: escaped
        	    {
        	        FOLLOWPUSH(FOLLOW_escaped_in_uric1461);
        	        escaped(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuricEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleuricEx; /* Prevent compiler warnings */
    ruleuricEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end uric */

/** 
 * $ANTLR start uric_for_from_to_contact_addr_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:373:1: uric_for_from_to_contact_addr_spec : ( reserved_for_from_to_contact_addr_spec | unreserved | escaped );
 */
static void
uric_for_from_to_contact_addr_spec(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:373:35: ( reserved_for_from_to_contact_addr_spec | unreserved | escaped )
            
            ANTLR3_UINT32 alt27;

            alt27=3;

            switch ( LA(1) ) 
            {
            case SLASH:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            	{
            		alt27=1;
            	}
                break;
            case DIGIT:
            case DOT:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt27=2;
            	}
                break;
            case PERCENT:
            	{
            		alt27=3;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruleuric_for_from_to_contact_addr_specEx;
            }

            switch (alt27) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:373:37: reserved_for_from_to_contact_addr_spec
        	    {
        	        FOLLOWPUSH(FOLLOW_reserved_for_from_to_contact_addr_spec_in_uric_for_from_to_contact_addr_spec1468);
        	        reserved_for_from_to_contact_addr_spec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:373:78: unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_unreserved_in_uric_for_from_to_contact_addr_spec1472);
        	        unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:373:91: escaped
        	    {
        	        FOLLOWPUSH(FOLLOW_escaped_in_uric_for_from_to_contact_addr_spec1476);
        	        escaped(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleuric_for_from_to_contact_addr_specEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleuric_for_from_to_contact_addr_specEx; /* Prevent compiler warnings */
    ruleuric_for_from_to_contact_addr_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end uric_for_from_to_contact_addr_spec */

/** 
 * $ANTLR start authority
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:375:1: authority[belle_generic_uri_t* uri] : ( ( authority_userinfo[NULL] )=> authority_userinfo[uri] )? authority_hostport[uri] ;
 */
static void
authority(pbelle_sip_messageParser ctx, belle_generic_uri_t* uri)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:376:1: ( ( ( authority_userinfo[NULL] )=> authority_userinfo[uri] )? authority_hostport[uri] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:377:3: ( ( authority_userinfo[NULL] )=> authority_userinfo[uri] )? authority_hostport[uri]
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:377:3: ( ( authority_userinfo[NULL] )=> authority_userinfo[uri] )?
            {
                int alt28=2;
                alt28 = cdfa28.predict(ctx, RECOGNIZER, ISTREAM, &cdfa28);
                if  (HASEXCEPTION())
                {
                    goto ruleauthorityEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt28) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:377:4: ( authority_userinfo[NULL] )=> authority_userinfo[uri]
            	    {
            	        FOLLOWPUSH(FOLLOW_authority_userinfo_in_authority1524);
            	        authority_userinfo(ctx, uri);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthorityEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_authority_hostport_in_authority1530);
            authority_hostport(ctx, uri);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthorityEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauthorityEx; /* Prevent compiler warnings */
    ruleauthorityEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);

	}


    }
    else
    {
    }

    return ;
}
/* $ANTLR end authority */

/** 
 * $ANTLR start authority_userinfo
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:384:1: authority_userinfo[belle_generic_uri_t* uri] : authority_user ( COLON authority_password )? AT ;
 */
static void
authority_userinfo(pbelle_sip_messageParser ctx, belle_generic_uri_t* uri)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_authority_userinfoTop = pbelle_sip_messageParser_authority_userinfoPush(ctx);
    	(SCOPE_TOP(authority_userinfo))->current=uri;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:387:8: ( authority_user ( COLON authority_password )? AT )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:387:11: authority_user ( COLON authority_password )? AT
        {
            FOLLOWPUSH(FOLLOW_authority_user_in_authority_userinfo1573);
            authority_user(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthority_userinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_authority_userinfoPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:387:26: ( COLON authority_password )?
            {
                int alt29=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt29=1;
                    	}
                        break;
                }

                switch (alt29) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:387:28: COLON authority_password
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_authority_userinfo1577); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_userinfoEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_authority_userinfoPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_authority_password_in_authority_userinfo1579);
            	        authority_password(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_userinfoEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_authority_userinfoPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(AT, &FOLLOW_AT_in_authority_userinfo1585); 
            if  (HASEXCEPTION())
            {
                goto ruleauthority_userinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_authority_userinfoPop(ctx);

                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauthority_userinfoEx; /* Prevent compiler warnings */
    ruleauthority_userinfoEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_authority_userinfoPop(ctx);

    return ;
}
/* $ANTLR end authority_userinfo */

/** 
 * $ANTLR start authority_user
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:388:1: authority_user : ( unreserved | escaped | user_unreserved )+ ;
 */
static belle_sip_messageParser_authority_user_return
authority_user(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_authority_user_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:388:27: ( ( unreserved | escaped | user_unreserved )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:388:31: ( unreserved | escaped | user_unreserved )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:388:31: ( unreserved | escaped | user_unreserved )+
            {
                int cnt30=0;

                for (;;)
                {
                    int alt30=4;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case DOT:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt30=1;
            		}
            	    break;
            	case PERCENT:
            		{
            			alt30=2;
            		}
            	    break;
            	case SLASH:
            	case AND:
            	case EQUAL:
            	case PLUS:
            	case DOLLARD:
            	case COMMA:
            	case SEMI:
            	case QMARK:
            		{
            			alt30=3;
            		}
            	    break;

            	}

            	switch (alt30) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:388:33: unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_unreserved_in_authority_user1608);
            	            unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleauthority_userEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:388:47: escaped
            	        {
            	            FOLLOWPUSH(FOLLOW_escaped_in_authority_user1613);
            	            escaped(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleauthority_userEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:388:57: user_unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_user_unreserved_in_authority_user1617);
            	            user_unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleauthority_userEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt30 >= 1 )
            		{
            		    goto loop30;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleauthority_userEx;
            	}
            	cnt30++;
                }
                loop30: ;	/* Jump to here if this rule does not match */
            }
            if ( BACKTRACKING==0 ) 
            {

                                                                                  char* unescaped_username;
                                                                                  unescaped_username=belle_sip_to_unescaped_string((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                                                                                  belle_generic_uri_set_user(	(SCOPE_TOP(authority_userinfo))->current,unescaped_username);
                                                                                  belle_sip_free(unescaped_username);
                                                                                  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauthority_userEx; /* Prevent compiler warnings */
    ruleauthority_userEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end authority_user */

/** 
 * $ANTLR start authority_password
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:1: authority_password : ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )* ;
 */
static belle_sip_messageParser_authority_password_return
authority_password(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_authority_password_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:27: ( ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:31: ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:31: ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )*

            for (;;)
            {
                int alt31=8;
                switch ( LA(1) ) 
                {
                case DIGIT:
                case DOT:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case HEX_CHAR:
                case COMMON_CHAR:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt31=1;
                	}
                    break;
                case PERCENT:
                	{
                		alt31=2;
                	}
                    break;
                case AND:
                	{
                		alt31=3;
                	}
                    break;
                case EQUAL:
                	{
                		alt31=4;
                	}
                    break;
                case PLUS:
                	{
                		alt31=5;
                	}
                    break;
                case DOLLARD:
                	{
                		alt31=6;
                	}
                    break;
                case COMMA:
                	{
                		alt31=7;
                	}
                    break;

                }

                switch (alt31) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:33: unreserved
            	    {
            	        FOLLOWPUSH(FOLLOW_unreserved_in_authority_password1641);
            	        unreserved(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_passwordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:46: escaped
            	    {
            	        FOLLOWPUSH(FOLLOW_escaped_in_authority_password1645);
            	        escaped(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_passwordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 3:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:56: AND
            	    {
            	         MATCHT(AND, &FOLLOW_AND_in_authority_password1649); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_passwordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 4:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:62: EQUAL
            	    {
            	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_authority_password1653); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_passwordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 5:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:70: PLUS
            	    {
            	         MATCHT(PLUS, &FOLLOW_PLUS_in_authority_password1657); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_passwordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 6:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:77: DOLLARD
            	    {
            	         MATCHT(DOLLARD, &FOLLOW_DOLLARD_in_authority_password1661); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_passwordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 7:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:395:87: COMMA
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_authority_password1665); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_passwordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop31;	/* break out of the loop */
            	    break;
                }
            }
            loop31: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {

                                                                                              char* unescaped_userpasswd;
                                                                                              unescaped_userpasswd=belle_sip_to_unescaped_string((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                                                                                              belle_generic_uri_set_user_password(	(SCOPE_TOP(authority_userinfo))->current,unescaped_userpasswd);
                                                                                              belle_sip_free(unescaped_userpasswd);
                                                                                              
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauthority_passwordEx; /* Prevent compiler warnings */
    ruleauthority_passwordEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end authority_password */

/** 
 * $ANTLR start authority_hostport
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:401:1: authority_hostport[belle_generic_uri_t* uri] : host ( COLON port )? ;
 */
static void
authority_hostport(pbelle_sip_messageParser ctx, belle_generic_uri_t* uri)
{   
    belle_sip_messageParser_port_return port27;
    #undef	RETURN_TYPE_port27
    #define	RETURN_TYPE_port27 belle_sip_messageParser_port_return

    const char* host28;
    #undef	RETURN_TYPE_host28
    #define	RETURN_TYPE_host28 const char*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_authority_hostportTop = pbelle_sip_messageParser_authority_hostportPush(ctx);
    	(SCOPE_TOP(authority_hostport))->current=uri;
    host28 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:404:9: ( host ( COLON port )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:404:13: host ( COLON port )?
        {
            FOLLOWPUSH(FOLLOW_host_in_authority_hostport1698);
            host28=host(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthority_hostportEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_authority_hostportPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:404:18: ( COLON port )?
            {
                int alt32=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt32=1;
                    	}
                        break;
                }

                switch (alt32) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:404:20: COLON port
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_authority_hostport1702); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_hostportEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_authority_hostportPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_port_in_authority_hostport1704);
            	        port27=port(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthority_hostportEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_authority_hostportPop(ctx);

            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_generic_uri_set_port(	(SCOPE_TOP(authority_hostport))->current,port27.ret);
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_generic_uri_set_host(	(SCOPE_TOP(authority_hostport))->current,host28);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauthority_hostportEx; /* Prevent compiler warnings */
    ruleauthority_hostportEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_authority_hostportPop(ctx);

    return ;
}
/* $ANTLR end authority_hostport */

/** 
 * $ANTLR start generic_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:410:1: generic_param[belle_sip_parameters_t* object] returns [belle_sip_param_pair_t* ret=NULL] : token ( equal gen_value )? ;
 */
static belle_sip_param_pair_t*
generic_param(pbelle_sip_messageParser ctx, belle_sip_parameters_t* object)
{   
    belle_sip_param_pair_t* ret = NULL;

    belle_sip_messageParser_gen_value_return gen_value29;
    #undef	RETURN_TYPE_gen_value29
    #define	RETURN_TYPE_gen_value29 belle_sip_messageParser_gen_value_return

    belle_sip_messageParser_token_return token30;
    #undef	RETURN_TYPE_token30
    #define	RETURN_TYPE_token30 belle_sip_messageParser_token_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_generic_paramTop = pbelle_sip_messageParser_generic_paramPush(ctx);
     	(SCOPE_TOP(generic_param))->is_value=0; 	(SCOPE_TOP(generic_param))->gen_value_string=NULL;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:413:3: ( token ( equal gen_value )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:413:8: token ( equal gen_value )?
        {
            FOLLOWPUSH(FOLLOW_token_in_generic_param1743);
            token30=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegeneric_paramEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_generic_paramPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:413:14: ( equal gen_value )?
            {
                int alt33=2;
                alt33 = cdfa33.predict(ctx, RECOGNIZER, ISTREAM, &cdfa33);
                if  (HASEXCEPTION())
                {
                    goto rulegeneric_paramEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_generic_paramPop(ctx);

                    return ret;
                }
                switch (alt33) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:413:17: equal gen_value
            	    {
            	        FOLLOWPUSH(FOLLOW_equal_in_generic_param1748);
            	        equal(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegeneric_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_generic_paramPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_gen_value_in_generic_param1750);
            	        gen_value29=gen_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegeneric_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_generic_paramPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            	(SCOPE_TOP(generic_param))->gen_value_string=(char*)((STRSTREAM->toStringTT(STRSTREAM, gen_value29.start, gen_value29.stop))->chars);
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {

                                                                     if (object == NULL) {
                                                                       ret=belle_sip_param_pair_new((const char*)((STRSTREAM->toStringTT(STRSTREAM, token30.start, token30.stop))->chars)
                                                                                                   ,	(SCOPE_TOP(generic_param))->gen_value_string);
                                                                     } else {
                                                                       belle_sip_parameters_set_parameter(object
                                                                                                         ,(const char*)((STRSTREAM->toStringTT(STRSTREAM, token30.start, token30.stop))->chars)
                                                                                                         ,	(SCOPE_TOP(generic_param))->gen_value_string);
                                                                       ret=NULL;
                                                                     }
                                                                     
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulegeneric_paramEx; /* Prevent compiler warnings */
    rulegeneric_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_generic_paramPop(ctx);

    return ret;
}
/* $ANTLR end generic_param */

/** 
 * $ANTLR start gen_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:424:1: gen_value : ( token | quoted_string );
 */
static belle_sip_messageParser_gen_value_return
gen_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_gen_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:425:3: ( token | quoted_string )
            
            ANTLR3_UINT32 alt34;

            alt34=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case DOT:
            case PLUS:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case PERCENT:
            case BQUOTE:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt34=1;
            	}
                break;
            case DQUOTE:
            	{
            		alt34=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 34;
                EXCEPTION->state        = 0;


                goto rulegen_valueEx;
            }

            switch (alt34) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:425:7: token
        	    {
        	        FOLLOWPUSH(FOLLOW_token_in_gen_value1774);
        	        token(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegen_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:425:16: quoted_string
        	    {
        	        FOLLOWPUSH(FOLLOW_quoted_string_in_gen_value1779);
        	        quoted_string(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegen_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulegen_valueEx; /* Prevent compiler warnings */
    rulegen_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end gen_value */

/** 
 * $ANTLR start quoted_string
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:427:1: quoted_string options {greedy=false; } : DQUOTE (~ ( DQUOTE | BSLASH ) | ( BSLASH . ) )* DQUOTE ;
 */
static belle_sip_messageParser_quoted_string_return
quoted_string(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_quoted_string_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:429:3: ( DQUOTE (~ ( DQUOTE | BSLASH ) | ( BSLASH . ) )* DQUOTE )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:429:5: DQUOTE (~ ( DQUOTE | BSLASH ) | ( BSLASH . ) )* DQUOTE
        {
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_quoted_string1801); 
            if  (HASEXCEPTION())
            {
                goto rulequoted_stringEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:429:12: (~ ( DQUOTE | BSLASH ) | ( BSLASH . ) )*

            for (;;)
            {
                int alt35=3;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case SLASH:
                case DIGIT:
                case DOT:
                case COLON:
                case AT:
                case AND:
                case EQUAL:
                case PLUS:
                case DOLLARD:
                case COMMA:
                case SEMI:
                case QMARK:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case OCTET:
                case LSBRAQUET:
                case RSBRAQUET:
                case PERCENT:
                case BQUOTE:
                case HEX_CHAR:
                case COMMON_CHAR:
                case LAQUOT:
                case RAQUOT:
                case LBRACE:
                case RBRACE:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                case HTAB:
                case OR:
                	{
                		alt35=1;
                	}
                    break;
                case BSLASH:
                	{
                		alt35=2;
                	}
                    break;

                }

                switch (alt35) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:429:13: ~ ( DQUOTE | BSLASH )
            	    {
            	        if ( ((LA(1) >= CRLF) && (LA(1) <= DASH)) || ((LA(1) >= STAR) && (LA(1) <= OR)) )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_quoted_string1804;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_quoted_string1804);    goto rulequoted_stringEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:429:34: ( BSLASH . )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:429:34: ( BSLASH . )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:429:35: BSLASH .
            	        {
            	             MATCHT(BSLASH, &FOLLOW_BSLASH_in_quoted_string1816); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulequoted_stringEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }
            	            MATCHANYT(); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulequoted_stringEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }


            	    }
            	    break;

            	default:
            	    goto loop35;	/* break out of the loop */
            	    break;
                }
            }
            loop35: ; /* Jump out to here if this rule does not match */

             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_quoted_string1824); 
            if  (HASEXCEPTION())
            {
                goto rulequoted_stringEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulequoted_stringEx; /* Prevent compiler warnings */
    rulequoted_stringEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end quoted_string */

/** 
 * $ANTLR start header_allow
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:457:1: header_allow returns [belle_sip_header_allow_t* ret] : {...}? token hcolon methods ;
 */
static belle_sip_header_allow_t*
header_allow(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_allow_t* ret = NULL;

    belle_sip_messageParser_methods_return methods31;
    #undef	RETURN_TYPE_methods31
    #define	RETURN_TYPE_methods31 belle_sip_messageParser_methods_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_allowTop = pbelle_sip_messageParser_header_allowPush(ctx);
    	(SCOPE_TOP(header_allow))->current= belle_sip_header_allow_new(); ret=	(SCOPE_TOP(header_allow))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:461:1: ({...}? token hcolon methods )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:461:6: {...}? token hcolon methods
        {
            if ( !((IS_TOKEN(Allow))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_allowPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Allow)";
                    EXCEPTION->ruleName	 = (void *)"header_allow";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_allow1865);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_allowEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_allowPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_allow1869);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_allowEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_allowPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_methods_in_header_allow1871);
            methods31=methods(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_allowEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_allowPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_allow_set_method(	(SCOPE_TOP(header_allow))->current,(const char*)((STRSTREAM->toStringTT(STRSTREAM, methods31.start, methods31.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_allowEx; /* Prevent compiler warnings */
    ruleheader_allowEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_allow))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_allowPop(ctx);

    return ret;
}
/* $ANTLR end header_allow */

/** 
 * $ANTLR start methods
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:468:1: methods : method ( comma method )* ;
 */
static belle_sip_messageParser_methods_return
methods(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_methods_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:468:9: ( method ( comma method )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:468:20: method ( comma method )*
        {
            FOLLOWPUSH(FOLLOW_method_in_methods1889);
            method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemethodsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:468:27: ( comma method )*

            for (;;)
            {
                int alt36=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case COMMA:
                	{
                		alt36=1;
                	}
                    break;

                }

                switch (alt36) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:468:28: comma method
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_methods1892);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethodsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_method_in_methods1894);
            	        method(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemethodsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemethodsEx; /* Prevent compiler warnings */
    rulemethodsEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end methods */

/** 
 * $ANTLR start authorization_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:469:1: authorization_token : {...}? token ;
 */
static void
authorization_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:469:20: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:469:22: {...}? token
        {
            if ( !((IS_TOKEN(Authorization))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Authorization)";
                    EXCEPTION->ruleName	 = (void *)"authorization_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_authorization_token1904);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthorization_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauthorization_tokenEx; /* Prevent compiler warnings */
    ruleauthorization_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end authorization_token */

/** 
 * $ANTLR start digest_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:470:1: digest_token : {...}? token ;
 */
static void
digest_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:470:13: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:470:15: {...}? token
        {
            if ( !((IS_TOKEN(Digest))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Digest)";
                    EXCEPTION->ruleName	 = (void *)"digest_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_digest_token1912);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_tokenEx; /* Prevent compiler warnings */
    ruledigest_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end digest_token */

/** 
 * $ANTLR start header_authorization
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:473:1: header_authorization returns [belle_sip_header_authorization_t* ret] : authorization_token hcolon credentials[$header_authorization::current] ;
 */
static belle_sip_header_authorization_t*
header_authorization(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_authorization_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_authorizationTop = pbelle_sip_messageParser_header_authorizationPush(ctx);
    	(SCOPE_TOP(header_authorization))->current= belle_sip_header_authorization_new(); ret=	(SCOPE_TOP(header_authorization))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:476:3: ( authorization_token hcolon credentials[$header_authorization::current] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:476:7: authorization_token hcolon credentials[$header_authorization::current]
        {
            FOLLOWPUSH(FOLLOW_authorization_token_in_header_authorization1944);
            authorization_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_authorization1948);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_credentials_in_header_authorization1950);
            credentials(ctx, 	(SCOPE_TOP(header_authorization))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_authorizationPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_authorizationEx; /* Prevent compiler warnings */
    ruleheader_authorizationEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_authorization))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_authorizationPop(ctx);

    return ret;
}
/* $ANTLR end header_authorization */

/** 
 * $ANTLR start credentials
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:484:1: credentials[belle_sip_header_authorization_t* header_authorization_base] : ( ( digest_token lws digest_response[header_authorization_base] ) | other_response[header_authorization_base] );
 */
static void
credentials(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:485:3: ( ( digest_token lws digest_response[header_authorization_base] ) | other_response[header_authorization_base] )
            
            ANTLR3_UINT32 alt37;

            alt37=2;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{

            		{
            		    int LA37_1 = LA(2);
            		    if ( ((IS_TOKEN(Digest))) ) 
            		    {
            		        alt37=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt37=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 1;


            		        goto rulecredentialsEx;
            		    }
            		}
            	}
                break;
            case DIGIT:
            	{

            		{
            		    int LA37_2 = LA(2);
            		    if ( ((IS_TOKEN(Digest))) ) 
            		    {
            		        alt37=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt37=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 2;


            		        goto rulecredentialsEx;
            		    }
            		}
            	}
                break;
            case DOT:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{

            		{
            		    int LA37_3 = LA(2);
            		    if ( ((IS_TOKEN(Digest))) ) 
            		    {
            		        alt37=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt37=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 3;


            		        goto rulecredentialsEx;
            		    }
            		}
            	}
                break;
            case PERCENT:
            	{

            		{
            		    int LA37_4 = LA(2);
            		    if ( ((IS_TOKEN(Digest))) ) 
            		    {
            		        alt37=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt37=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 4;


            		        goto rulecredentialsEx;
            		    }
            		}
            	}
                break;
            case PLUS:
            	{

            		{
            		    int LA37_5 = LA(2);
            		    if ( ((IS_TOKEN(Digest))) ) 
            		    {
            		        alt37=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt37=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 5;


            		        goto rulecredentialsEx;
            		    }
            		}
            	}
                break;
            case BQUOTE:
            	{

            		{
            		    int LA37_6 = LA(2);
            		    if ( ((IS_TOKEN(Digest))) ) 
            		    {
            		        alt37=1;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt37=2;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 6;


            		        goto rulecredentialsEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 37;
                EXCEPTION->state        = 0;


                goto rulecredentialsEx;
            }

            switch (alt37) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:485:7: ( digest_token lws digest_response[header_authorization_base] )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:485:7: ( digest_token lws digest_response[header_authorization_base] )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:485:8: digest_token lws digest_response[header_authorization_base]
        	        {
        	            FOLLOWPUSH(FOLLOW_digest_token_in_credentials1978);
        	            digest_token(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecredentialsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            if ( BACKTRACKING==0 ) 
        	            {
        	                belle_sip_header_authorization_set_scheme(header_authorization_base,"Digest");
        	            }
        	            FOLLOWPUSH(FOLLOW_lws_in_credentials1990);
        	            lws(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecredentialsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_digest_response_in_credentials1992);
        	            digest_response(ctx, header_authorization_base);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulecredentialsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:487:24: other_response[header_authorization_base]
        	    {
        	        FOLLOWPUSH(FOLLOW_other_response_in_credentials2019);
        	        other_response(ctx, header_authorization_base);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecredentialsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecredentialsEx; /* Prevent compiler warnings */
    rulecredentialsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end credentials */

/** 
 * $ANTLR start digest_response
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:488:1: digest_response[belle_sip_header_authorization_t* header_authorization_base] : dig_resp[header_authorization_base] ( comma dig_resp[header_authorization_base] )* ;
 */
static void
digest_response(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:489:3: ( dig_resp[header_authorization_base] ( comma dig_resp[header_authorization_base] )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:489:7: dig_resp[header_authorization_base] ( comma dig_resp[header_authorization_base] )*
        {
            FOLLOWPUSH(FOLLOW_dig_resp_in_digest_response2036);
            dig_resp(ctx, header_authorization_base);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:489:43: ( comma dig_resp[header_authorization_base] )*

            for (;;)
            {
                int alt38=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case COMMA:
                	{
                		alt38=1;
                	}
                    break;

                }

                switch (alt38) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:489:44: comma dig_resp[header_authorization_base]
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_digest_response2040);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledigest_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_dig_resp_in_digest_response2042);
            	        dig_resp(ctx, header_authorization_base);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledigest_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop38;	/* break out of the loop */
            	    break;
                }
            }
            loop38: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_responseEx; /* Prevent compiler warnings */
    ruledigest_responseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end digest_response */

/** 
 * $ANTLR start dig_resp
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:490:1: dig_resp[belle_sip_header_authorization_t* header_authorization_base] : ( username | realm | nonce | digest_uri[header_authorization_base] | dresponse | algorithm | cnonce | opaque | message_qop | nonce_count | auth_param[header_authorization_base] );
 */
static void
dig_resp(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    char* username32;
    #undef	RETURN_TYPE_username32
    #define	RETURN_TYPE_username32 char*

    char* realm33;
    #undef	RETURN_TYPE_realm33
    #define	RETURN_TYPE_realm33 char*

    char* nonce34;
    #undef	RETURN_TYPE_nonce34
    #define	RETURN_TYPE_nonce34 char*

    char* dresponse35;
    #undef	RETURN_TYPE_dresponse35
    #define	RETURN_TYPE_dresponse35 char*

    const char* algorithm36;
    #undef	RETURN_TYPE_algorithm36
    #define	RETURN_TYPE_algorithm36 const char*

    char* cnonce37;
    #undef	RETURN_TYPE_cnonce37
    #define	RETURN_TYPE_cnonce37 char*

    char* opaque38;
    #undef	RETURN_TYPE_opaque38
    #define	RETURN_TYPE_opaque38 char*

    const char* message_qop39;
    #undef	RETURN_TYPE_message_qop39
    #define	RETURN_TYPE_message_qop39 const char*

    const char* nonce_count40;
    #undef	RETURN_TYPE_nonce_count40
    #define	RETURN_TYPE_nonce_count40 const char*

    /* Initialize rule variables
     */


    username32 = NULL;
    realm33 = NULL;
    nonce34 = NULL;
    dresponse35 = NULL;
    algorithm36 = NULL;
    cnonce37 = NULL;
    opaque38 = NULL;
    message_qop39 = NULL;
    nonce_count40 = NULL;

    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:491:3: ( username | realm | nonce | digest_uri[header_authorization_base] | dresponse | algorithm | cnonce | opaque | message_qop | nonce_count | auth_param[header_authorization_base] )
            
            ANTLR3_UINT32 alt39;

            alt39=11;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{

            		{
            		    int LA39_1 = LA(2);
            		    if ( ((IS_TOKEN(username))) ) 
            		    {
            		        alt39=1;
            		    }
            		    else if ( ((IS_TOKEN(realm))) ) 
            		    {
            		        alt39=2;
            		    }
            		    else if ( ((IS_TOKEN(nonce))) ) 
            		    {
            		        alt39=3;
            		    }
            		    else if ( ((IS_TOKEN(uri))) ) 
            		    {
            		        alt39=4;
            		    }
            		    else if ( ((IS_TOKEN(response))) ) 
            		    {
            		        alt39=5;
            		    }
            		    else if ( ((IS_TOKEN(algorithm))) ) 
            		    {
            		        alt39=6;
            		    }
            		    else if ( ((IS_TOKEN(cnonce))) ) 
            		    {
            		        alt39=7;
            		    }
            		    else if ( ((IS_TOKEN(opaque))) ) 
            		    {
            		        alt39=8;
            		    }
            		    else if ( ((IS_TOKEN(qop))) ) 
            		    {
            		        alt39=9;
            		    }
            		    else if ( ((IS_TOKEN(nc))) ) 
            		    {
            		        alt39=10;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt39=11;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 1;


            		        goto ruledig_respEx;
            		    }
            		}
            	}
                break;
            case DIGIT:
            	{

            		{
            		    int LA39_2 = LA(2);
            		    if ( ((IS_TOKEN(username))) ) 
            		    {
            		        alt39=1;
            		    }
            		    else if ( ((IS_TOKEN(realm))) ) 
            		    {
            		        alt39=2;
            		    }
            		    else if ( ((IS_TOKEN(nonce))) ) 
            		    {
            		        alt39=3;
            		    }
            		    else if ( ((IS_TOKEN(uri))) ) 
            		    {
            		        alt39=4;
            		    }
            		    else if ( ((IS_TOKEN(response))) ) 
            		    {
            		        alt39=5;
            		    }
            		    else if ( ((IS_TOKEN(algorithm))) ) 
            		    {
            		        alt39=6;
            		    }
            		    else if ( ((IS_TOKEN(cnonce))) ) 
            		    {
            		        alt39=7;
            		    }
            		    else if ( ((IS_TOKEN(opaque))) ) 
            		    {
            		        alt39=8;
            		    }
            		    else if ( ((IS_TOKEN(qop))) ) 
            		    {
            		        alt39=9;
            		    }
            		    else if ( ((IS_TOKEN(nc))) ) 
            		    {
            		        alt39=10;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt39=11;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 2;


            		        goto ruledig_respEx;
            		    }
            		}
            	}
                break;
            case DOT:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{

            		{
            		    int LA39_3 = LA(2);
            		    if ( ((IS_TOKEN(username))) ) 
            		    {
            		        alt39=1;
            		    }
            		    else if ( ((IS_TOKEN(realm))) ) 
            		    {
            		        alt39=2;
            		    }
            		    else if ( ((IS_TOKEN(nonce))) ) 
            		    {
            		        alt39=3;
            		    }
            		    else if ( ((IS_TOKEN(uri))) ) 
            		    {
            		        alt39=4;
            		    }
            		    else if ( ((IS_TOKEN(response))) ) 
            		    {
            		        alt39=5;
            		    }
            		    else if ( ((IS_TOKEN(algorithm))) ) 
            		    {
            		        alt39=6;
            		    }
            		    else if ( ((IS_TOKEN(cnonce))) ) 
            		    {
            		        alt39=7;
            		    }
            		    else if ( ((IS_TOKEN(opaque))) ) 
            		    {
            		        alt39=8;
            		    }
            		    else if ( ((IS_TOKEN(qop))) ) 
            		    {
            		        alt39=9;
            		    }
            		    else if ( ((IS_TOKEN(nc))) ) 
            		    {
            		        alt39=10;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt39=11;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 3;


            		        goto ruledig_respEx;
            		    }
            		}
            	}
                break;
            case PERCENT:
            	{

            		{
            		    int LA39_4 = LA(2);
            		    if ( ((IS_TOKEN(username))) ) 
            		    {
            		        alt39=1;
            		    }
            		    else if ( ((IS_TOKEN(realm))) ) 
            		    {
            		        alt39=2;
            		    }
            		    else if ( ((IS_TOKEN(nonce))) ) 
            		    {
            		        alt39=3;
            		    }
            		    else if ( ((IS_TOKEN(uri))) ) 
            		    {
            		        alt39=4;
            		    }
            		    else if ( ((IS_TOKEN(response))) ) 
            		    {
            		        alt39=5;
            		    }
            		    else if ( ((IS_TOKEN(algorithm))) ) 
            		    {
            		        alt39=6;
            		    }
            		    else if ( ((IS_TOKEN(cnonce))) ) 
            		    {
            		        alt39=7;
            		    }
            		    else if ( ((IS_TOKEN(opaque))) ) 
            		    {
            		        alt39=8;
            		    }
            		    else if ( ((IS_TOKEN(qop))) ) 
            		    {
            		        alt39=9;
            		    }
            		    else if ( ((IS_TOKEN(nc))) ) 
            		    {
            		        alt39=10;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt39=11;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 4;


            		        goto ruledig_respEx;
            		    }
            		}
            	}
                break;
            case PLUS:
            	{

            		{
            		    int LA39_5 = LA(2);
            		    if ( ((IS_TOKEN(username))) ) 
            		    {
            		        alt39=1;
            		    }
            		    else if ( ((IS_TOKEN(realm))) ) 
            		    {
            		        alt39=2;
            		    }
            		    else if ( ((IS_TOKEN(nonce))) ) 
            		    {
            		        alt39=3;
            		    }
            		    else if ( ((IS_TOKEN(uri))) ) 
            		    {
            		        alt39=4;
            		    }
            		    else if ( ((IS_TOKEN(response))) ) 
            		    {
            		        alt39=5;
            		    }
            		    else if ( ((IS_TOKEN(algorithm))) ) 
            		    {
            		        alt39=6;
            		    }
            		    else if ( ((IS_TOKEN(cnonce))) ) 
            		    {
            		        alt39=7;
            		    }
            		    else if ( ((IS_TOKEN(opaque))) ) 
            		    {
            		        alt39=8;
            		    }
            		    else if ( ((IS_TOKEN(qop))) ) 
            		    {
            		        alt39=9;
            		    }
            		    else if ( ((IS_TOKEN(nc))) ) 
            		    {
            		        alt39=10;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt39=11;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 5;


            		        goto ruledig_respEx;
            		    }
            		}
            	}
                break;
            case BQUOTE:
            	{

            		{
            		    int LA39_6 = LA(2);
            		    if ( ((IS_TOKEN(username))) ) 
            		    {
            		        alt39=1;
            		    }
            		    else if ( ((IS_TOKEN(realm))) ) 
            		    {
            		        alt39=2;
            		    }
            		    else if ( ((IS_TOKEN(nonce))) ) 
            		    {
            		        alt39=3;
            		    }
            		    else if ( ((IS_TOKEN(uri))) ) 
            		    {
            		        alt39=4;
            		    }
            		    else if ( ((IS_TOKEN(response))) ) 
            		    {
            		        alt39=5;
            		    }
            		    else if ( ((IS_TOKEN(algorithm))) ) 
            		    {
            		        alt39=6;
            		    }
            		    else if ( ((IS_TOKEN(cnonce))) ) 
            		    {
            		        alt39=7;
            		    }
            		    else if ( ((IS_TOKEN(opaque))) ) 
            		    {
            		        alt39=8;
            		    }
            		    else if ( ((IS_TOKEN(qop))) ) 
            		    {
            		        alt39=9;
            		    }
            		    else if ( ((IS_TOKEN(nc))) ) 
            		    {
            		        alt39=10;
            		    }
            		    else if ( (ANTLR3_TRUE) ) 
            		    {
            		        alt39=11;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 6;


            		        goto ruledig_respEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto ruledig_respEx;
            }

            switch (alt39) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:491:7: username
        	    {
        	        FOLLOWPUSH(FOLLOW_username_in_dig_resp2068);
        	        username32=username(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_username(header_authorization_base,username32);
        	                             belle_sip_free(username32);
        	                           
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:494:5: realm
        	    {
        	        FOLLOWPUSH(FOLLOW_realm_in_dig_resp2076);
        	        realm33=realm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_realm(header_authorization_base,(char*)realm33);
        	                             belle_sip_free(realm33);
        	                       
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:497:5: nonce
        	    {
        	        FOLLOWPUSH(FOLLOW_nonce_in_dig_resp2085);
        	        nonce34=nonce(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_nonce(header_authorization_base,(char*)nonce34);
        	                             belle_sip_free(nonce34);
        	                       
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:500:5: digest_uri[header_authorization_base]
        	    {
        	        FOLLOWPUSH(FOLLOW_digest_uri_in_dig_resp2093);
        	        digest_uri(ctx, header_authorization_base);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 5:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:501:5: dresponse
        	    {
        	        FOLLOWPUSH(FOLLOW_dresponse_in_dig_resp2100);
        	        dresponse35=dresponse(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             belle_sip_header_authorization_set_response(header_authorization_base,(char*)dresponse35);
        	                             belle_sip_free(dresponse35);
        	                           
        	        }

        	    }
        	    break;
        	case 6:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:504:5: algorithm
        	    {
        	        FOLLOWPUSH(FOLLOW_algorithm_in_dig_resp2109);
        	        algorithm36=algorithm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                            belle_sip_header_authorization_set_algorithm(header_authorization_base,(char*)algorithm36);
        	                           
        	        }

        	    }
        	    break;
        	case 7:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:507:5: cnonce
        	    {
        	        FOLLOWPUSH(FOLLOW_cnonce_in_dig_resp2119);
        	        cnonce37=cnonce(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_cnonce(header_authorization_base,(char*)cnonce37);
        	                        belle_sip_free(cnonce37);
        	                       
        	        }

        	    }
        	    break;
        	case 8:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:511:5: opaque
        	    {
        	        FOLLOWPUSH(FOLLOW_opaque_in_dig_resp2126);
        	        opaque38=opaque(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_opaque(header_authorization_base,(char*)opaque38);
        	                        belle_sip_free(opaque38);
        	                       
        	        }

        	    }
        	    break;
        	case 9:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:515:5: message_qop
        	    {
        	        FOLLOWPUSH(FOLLOW_message_qop_in_dig_resp2134);
        	        message_qop39=message_qop(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_qop(header_authorization_base,message_qop39);
        	                       
        	        }

        	    }
        	    break;
        	case 10:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:518:5: nonce_count
        	    {
        	        FOLLOWPUSH(FOLLOW_nonce_count_in_dig_resp2141);
        	        nonce_count40=nonce_count(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                        belle_sip_header_authorization_set_nonce_count(header_authorization_base,atoi((char*)nonce_count40));
        	                       
        	        }

        	    }
        	    break;
        	case 11:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:521:5: auth_param[header_authorization_base]
        	    {
        	        FOLLOWPUSH(FOLLOW_auth_param_in_dig_resp2149);
        	        auth_param(ctx, header_authorization_base);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledig_respEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledig_respEx; /* Prevent compiler warnings */
    ruledig_respEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end dig_resp */

/** 
 * $ANTLR start username_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:523:1: username_token : {...}? token ;
 */
static void
username_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:523:15: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:523:17: {...}? token
        {
            if ( !((IS_TOKEN(username))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(username)";
                    EXCEPTION->ruleName	 = (void *)"username_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_username_token2162);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusername_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleusername_tokenEx; /* Prevent compiler warnings */
    ruleusername_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end username_token */

/** 
 * $ANTLR start username
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:524:1: username returns [char* ret=NULL] : username_token equal username_value ;
 */
static char*
username(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_username_value_return username_value41;
    #undef	RETURN_TYPE_username_value41
    #define	RETURN_TYPE_username_value41 belle_sip_messageParser_username_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:525:3: ( username_token equal username_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:525:7: username_token equal username_value
        {
            FOLLOWPUSH(FOLLOW_username_token_in_username2187);
            username_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusernameEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_username2191);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusernameEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_username_value_in_username2193);
            username_value41=username_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusernameEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, username_value41.start, username_value41.stop))->chars);
                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleusernameEx; /* Prevent compiler warnings */
    ruleusernameEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end username */

/** 
 * $ANTLR start username_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:529:1: username_value : quoted_string ;
 */
static belle_sip_messageParser_username_value_return
username_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_username_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:529:19: ( quoted_string )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:529:22: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_username_value2207);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusername_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleusername_valueEx; /* Prevent compiler warnings */
    ruleusername_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end username_value */

/** 
 * $ANTLR start uri_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:531:1: uri_token : {...}? token ;
 */
static void
uri_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:531:10: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:531:12: {...}? token
        {
            if ( !((IS_TOKEN(uri))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(uri)";
                    EXCEPTION->ruleName	 = (void *)"uri_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_uri_token2216);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuri_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuri_tokenEx; /* Prevent compiler warnings */
    ruleuri_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end uri_token */

/** 
 * $ANTLR start digest_uri
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:532:1: digest_uri[belle_sip_header_authorization_t* header_authorization_base] : uri_token equal DQUOTE uri DQUOTE ;
 */
static void
digest_uri(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    belle_sip_uri_t* uri42;
    #undef	RETURN_TYPE_uri42
    #define	RETURN_TYPE_uri42 belle_sip_uri_t*

    /* Initialize rule variables
     */


    uri42 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:533:3: ( uri_token equal DQUOTE uri DQUOTE )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:533:7: uri_token equal DQUOTE uri DQUOTE
        {
            FOLLOWPUSH(FOLLOW_uri_token_in_digest_uri2237);
            uri_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_equal_in_digest_uri2241);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_digest_uri2243); 
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_uri_in_digest_uri2245);
            uri42=uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_digest_uri2247); 
            if  (HASEXCEPTION())
            {
                goto ruledigest_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_authorization_set_uri(header_authorization_base,uri42);
                   
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_uriEx; /* Prevent compiler warnings */
    ruledigest_uriEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end digest_uri */

/** 
 * $ANTLR start message_qop
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:542:1: message_qop returns [const char* ret=NULL] : {...}? token equal qop_value ;
 */
static const char*
message_qop(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_qop_value_return qop_value43;
    #undef	RETURN_TYPE_qop_value43
    #define	RETURN_TYPE_qop_value43 belle_sip_messageParser_qop_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:543:3: ({...}? token equal qop_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:543:7: {...}? token equal qop_value
        {
            if ( !((IS_TOKEN(qop))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(qop)";
                    EXCEPTION->ruleName	 = (void *)"message_qop";


            }
            FOLLOWPUSH(FOLLOW_token_in_message_qop2281);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessage_qopEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_message_qop2284);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessage_qopEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_qop_value_in_message_qop2287);
            qop_value43=qop_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemessage_qopEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= (const char*)(STRSTREAM->toStringTT(STRSTREAM, qop_value43.start, qop_value43.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_qopEx; /* Prevent compiler warnings */
    rulemessage_qopEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end message_qop */

/** 
 * $ANTLR start qop_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:545:1: qop_value : token ;
 */
static belle_sip_messageParser_qop_value_return
qop_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_qop_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:546:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:546:6: token
        {
            FOLLOWPUSH(FOLLOW_token_in_qop_value2300);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleqop_valueEx; /* Prevent compiler warnings */
    ruleqop_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end qop_value */

/** 
 * $ANTLR start cnonce
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:548:1: cnonce returns [char* ret=NULL] : {...}? token equal cnonce_value ;
 */
static char*
cnonce(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_cnonce_value_return cnonce_value44;
    #undef	RETURN_TYPE_cnonce_value44
    #define	RETURN_TYPE_cnonce_value44 belle_sip_messageParser_cnonce_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:549:3: ({...}? token equal cnonce_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:549:7: {...}? token equal cnonce_value
        {
            if ( !((IS_TOKEN(cnonce))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(cnonce)";
                    EXCEPTION->ruleName	 = (void *)"cnonce";


            }
            FOLLOWPUSH(FOLLOW_token_in_cnonce2330);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_cnonce2334);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_cnonce_value_in_cnonce2336);
            cnonce_value44=cnonce_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                                              ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, cnonce_value44.start, cnonce_value44.stop))->chars);
                                                              
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecnonceEx; /* Prevent compiler warnings */
    rulecnonceEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end cnonce */

/** 
 * $ANTLR start cnonce_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:552:1: cnonce_value : nonce_value ;
 */
static belle_sip_messageParser_cnonce_value_return
cnonce_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_cnonce_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:553:3: ( nonce_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:553:7: nonce_value
        {
            FOLLOWPUSH(FOLLOW_nonce_value_in_cnonce_value2355);
            nonce_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecnonce_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecnonce_valueEx; /* Prevent compiler warnings */
    rulecnonce_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end cnonce_value */

/** 
 * $ANTLR start nonce_count
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:554:1: nonce_count returns [const char* ret=NULL] : {...}? token equal nc_value ;
 */
static const char*
nonce_count(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_nc_value_return nc_value45;
    #undef	RETURN_TYPE_nc_value45
    #define	RETURN_TYPE_nc_value45 belle_sip_messageParser_nc_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:555:3: ({...}? token equal nc_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:555:7: {...}? token equal nc_value
        {
            if ( !((IS_TOKEN(nc))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(nc)";
                    EXCEPTION->ruleName	 = (void *)"nonce_count";


            }
            FOLLOWPUSH(FOLLOW_token_in_nonce_count2379);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_countEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_nonce_count2383);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_countEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_nc_value_in_nonce_count2385);
            nc_value45=nc_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_countEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(char*)(STRSTREAM->toStringTT(STRSTREAM, nc_value45.start, nc_value45.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenonce_countEx; /* Prevent compiler warnings */
    rulenonce_countEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end nonce_count */

/** 
 * $ANTLR start nc_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:556:1: nc_value : huit_lhex ;
 */
static belle_sip_messageParser_nc_value_return
nc_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_nc_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:557:3: ( huit_lhex )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:557:7: huit_lhex
        {
            FOLLOWPUSH(FOLLOW_huit_lhex_in_nc_value2408);
            huit_lhex(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenc_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenc_valueEx; /* Prevent compiler warnings */
    rulenc_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end nc_value */

/** 
 * $ANTLR start dresponse
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:558:1: dresponse returns [char* ret=NULL] : {...}? token equal request_digest ;
 */
static char*
dresponse(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_request_digest_return request_digest46;
    #undef	RETURN_TYPE_request_digest46
    #define	RETURN_TYPE_request_digest46 belle_sip_messageParser_request_digest_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:559:3: ({...}? token equal request_digest )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:559:7: {...}? token equal request_digest
        {
            if ( !((IS_TOKEN(response))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(response)";
                    EXCEPTION->ruleName	 = (void *)"dresponse";


            }
            FOLLOWPUSH(FOLLOW_token_in_dresponse2434);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledresponseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_dresponse2438);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledresponseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_request_digest_in_dresponse2440);
            request_digest46=request_digest(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledresponseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, request_digest46.start, request_digest46.stop))->chars);
                                     
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledresponseEx; /* Prevent compiler warnings */
    ruledresponseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end dresponse */

/** 
 * $ANTLR start request_digest
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:562:1: request_digest : quoted_string ;
 */
static belle_sip_messageParser_request_digest_return
request_digest(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_request_digest_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:563:3: ( quoted_string )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:563:7: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_request_digest2456);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequest_digestEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerequest_digestEx; /* Prevent compiler warnings */
    rulerequest_digestEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end request_digest */

/** 
 * $ANTLR start huit_lhex
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:565:1: huit_lhex : ( hexdigit )+ ;
 */
static void
huit_lhex(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:566:3: ( ( hexdigit )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:566:5: ( hexdigit )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:566:5: ( hexdigit )+
            {
                int cnt40=0;

                for (;;)
                {
                    int alt40=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt40=1;
            		}
            	    break;

            	}

            	switch (alt40) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:566:5: hexdigit
            	        {
            	            FOLLOWPUSH(FOLLOW_hexdigit_in_huit_lhex2467);
            	            hexdigit(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehuit_lhexEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt40 >= 1 )
            		{
            		    goto loop40;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehuit_lhexEx;
            	}
            	cnt40++;
                }
                loop40: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehuit_lhexEx; /* Prevent compiler warnings */
    rulehuit_lhexEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end huit_lhex */

/** 
 * $ANTLR start auth_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:568:1: auth_param[belle_sip_header_authorization_t* header_authorization_base] : auth_param_name equal auth_param_value ;
 */
static void
auth_param(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    belle_sip_messageParser_auth_param_name_return auth_param_name47;
    #undef	RETURN_TYPE_auth_param_name47
    #define	RETURN_TYPE_auth_param_name47 belle_sip_messageParser_auth_param_name_return

    belle_sip_messageParser_auth_param_value_return auth_param_value48;
    #undef	RETURN_TYPE_auth_param_value48
    #define	RETURN_TYPE_auth_param_value48 belle_sip_messageParser_auth_param_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:569:3: ( auth_param_name equal auth_param_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:569:7: auth_param_name equal auth_param_value
        {
            FOLLOWPUSH(FOLLOW_auth_param_name_in_auth_param2490);
            auth_param_name47=auth_param_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_equal_in_auth_param2492);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_auth_param_value_in_auth_param2515);
            auth_param_value48=auth_param_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_parameters_set_parameter(BELLE_SIP_PARAMETERS(header_authorization_base)
                                                                                         ,(char*)(STRSTREAM->toStringTT(STRSTREAM, auth_param_name47.start, auth_param_name47.stop))->chars
                                                                                         ,(char*)(STRSTREAM->toStringTT(STRSTREAM, auth_param_value48.start, auth_param_value48.stop))->chars);
                                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_paramEx; /* Prevent compiler warnings */
    ruleauth_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end auth_param */

/** 
 * $ANTLR start auth_param_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:575:1: auth_param_value : ( token | quoted_string );
 */
static belle_sip_messageParser_auth_param_value_return
auth_param_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_auth_param_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:575:18: ( token | quoted_string )
            
            ANTLR3_UINT32 alt41;

            alt41=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case DOT:
            case PLUS:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case PERCENT:
            case BQUOTE:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt41=1;
            	}
                break;
            case DQUOTE:
            	{
            		alt41=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 41;
                EXCEPTION->state        = 0;


                goto ruleauth_param_valueEx;
            }

            switch (alt41) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:575:20: token
        	    {
        	        FOLLOWPUSH(FOLLOW_token_in_auth_param_value2535);
        	        token(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleauth_param_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:575:28: quoted_string
        	    {
        	        FOLLOWPUSH(FOLLOW_quoted_string_in_auth_param_value2539);
        	        quoted_string(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleauth_param_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_param_valueEx; /* Prevent compiler warnings */
    ruleauth_param_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end auth_param_value */

/** 
 * $ANTLR start auth_param_name
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:576:1: auth_param_name : token ;
 */
static belle_sip_messageParser_auth_param_name_return
auth_param_name(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_auth_param_name_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:577:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:577:7: token
        {
            FOLLOWPUSH(FOLLOW_token_in_auth_param_name2564);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_param_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_param_nameEx; /* Prevent compiler warnings */
    ruleauth_param_nameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end auth_param_name */

/** 
 * $ANTLR start other_response
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:578:1: other_response[belle_sip_header_authorization_t* header_authorization_base] : auth_scheme lws auth_param[header_authorization_base] ( comma auth_param[header_authorization_base] )* ;
 */
static void
other_response(pbelle_sip_messageParser ctx, belle_sip_header_authorization_t* header_authorization_base)
{   
    belle_sip_messageParser_auth_scheme_return auth_scheme49;
    #undef	RETURN_TYPE_auth_scheme49
    #define	RETURN_TYPE_auth_scheme49 belle_sip_messageParser_auth_scheme_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:579:3: ( auth_scheme lws auth_param[header_authorization_base] ( comma auth_param[header_authorization_base] )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:579:7: auth_scheme lws auth_param[header_authorization_base] ( comma auth_param[header_authorization_base] )*
        {
            FOLLOWPUSH(FOLLOW_auth_scheme_in_other_response2581);
            auth_scheme49=auth_scheme(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_authorization_set_scheme(header_authorization_base,(const char*)(STRSTREAM->toStringTT(STRSTREAM, auth_scheme49.start, auth_scheme49.stop))->chars);
            }
            FOLLOWPUSH(FOLLOW_lws_in_other_response2591);
            lws(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_auth_param_in_other_response2593);
            auth_param(ctx, header_authorization_base);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_responseEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:581:22: ( comma auth_param[header_authorization_base] )*

            for (;;)
            {
                int alt42=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case COMMA:
                	{
                		alt42=1;
                	}
                    break;

                }

                switch (alt42) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:581:23: comma auth_param[header_authorization_base]
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_other_response2618);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_auth_param_in_other_response2620);
            	        auth_param(ctx, header_authorization_base);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_responseEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_responseEx; /* Prevent compiler warnings */
    ruleother_responseEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end other_response */

/** 
 * $ANTLR start auth_scheme
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:583:1: auth_scheme : token ;
 */
static belle_sip_messageParser_auth_scheme_return
auth_scheme(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_auth_scheme_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:584:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:584:7: token
        {
            FOLLOWPUSH(FOLLOW_token_in_auth_scheme2642);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauth_schemeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleauth_schemeEx; /* Prevent compiler warnings */
    ruleauth_schemeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end auth_scheme */

/** 
 * $ANTLR start nonce_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:595:1: nonce_value : quoted_string ;
 */
static belle_sip_messageParser_nonce_value_return
nonce_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_nonce_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:595:21: ( quoted_string )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:595:24: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_nonce_value2660);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonce_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenonce_valueEx; /* Prevent compiler warnings */
    rulenonce_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end nonce_value */

/** 
 * $ANTLR start call_id_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:603:1: call_id_token : {...}? token ;
 */
static void
call_id_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:603:14: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:603:16: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Call-ID,i))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Call-ID,i)";
                    EXCEPTION->ruleName	 = (void *)"call_id_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_call_id_token2672);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecall_id_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecall_id_tokenEx; /* Prevent compiler warnings */
    rulecall_id_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end call_id_token */

/** 
 * $ANTLR start header_call_id
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:605:1: header_call_id returns [belle_sip_header_call_id_t* ret=NULL] : call_id_token hcolon call_id ;
 */
static belle_sip_header_call_id_t*
header_call_id(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_call_id_t* ret = NULL;

    belle_sip_messageParser_call_id_return call_id50;
    #undef	RETURN_TYPE_call_id50
    #define	RETURN_TYPE_call_id50 belle_sip_messageParser_call_id_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_call_idTop = pbelle_sip_messageParser_header_call_idPush(ctx);
    	(SCOPE_TOP(header_call_id))->current= belle_sip_header_call_id_new(); ret=	(SCOPE_TOP(header_call_id))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:608:3: ( call_id_token hcolon call_id )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:608:6: call_id_token hcolon call_id
        {
            FOLLOWPUSH(FOLLOW_call_id_token_in_header_call_id2702);
            call_id_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_call_idEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_call_idPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_call_id2706);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_call_idEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_call_idPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_call_id_in_header_call_id2708);
            call_id50=call_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_call_idEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_call_idPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_call_id_set_call_id(	(SCOPE_TOP(header_call_id))->current,(const char*) (STRSTREAM->toStringTT(STRSTREAM, call_id50.start, call_id50.stop))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_call_idEx; /* Prevent compiler warnings */
    ruleheader_call_idEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_call_id))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_call_idPop(ctx);

    return ret;
}
/* $ANTLR end header_call_id */

/** 
 * $ANTLR start call_id
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:615:1: call_id : word ( AT word )? ;
 */
static belle_sip_messageParser_call_id_return
call_id(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_call_id_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:616:3: ( word ( AT word )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:616:7: word ( AT word )?
        {
            FOLLOWPUSH(FOLLOW_word_in_call_id2731);
            word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecall_idEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:616:12: ( AT word )?
            {
                int alt43=2;
                switch ( LA(1) ) 
                {
                    case AT:
                    	{
                    		alt43=1;
                    	}
                        break;
                }

                switch (alt43) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:616:14: AT word
            	    {
            	         MATCHT(AT, &FOLLOW_AT_in_call_id2735); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecall_idEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_word_in_call_id2737);
            	        word(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecall_idEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecall_idEx; /* Prevent compiler warnings */
    rulecall_idEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end call_id */

/** 
 * $ANTLR start contact_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:627:1: contact_token : {...}? token ;
 */
static void
contact_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:627:14: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:627:16: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Contact,m))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Contact,m)";
                    EXCEPTION->ruleName	 = (void *)"contact_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_contact_token2753);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontact_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_tokenEx; /* Prevent compiler warnings */
    rulecontact_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end contact_token */

/** 
 * $ANTLR start header_contact
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:629:1: header_contact returns [belle_sip_header_contact_t* ret] : ( contact_token ) sp_tab_colon ( ( ( lws )? STAR ) | ( contact_param ( COMMA contact_param )* ) ) ;
 */
static belle_sip_header_contact_t*
header_contact(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_contact_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_contactTop = pbelle_sip_messageParser_header_contactPush(ctx);
     	(SCOPE_TOP(header_contact))->current=NULL; ret=NULL; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:632:3: ( ( contact_token ) sp_tab_colon ( ( ( lws )? STAR ) | ( contact_param ( COMMA contact_param )* ) ) )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:632:7: ( contact_token ) sp_tab_colon ( ( ( lws )? STAR ) | ( contact_param ( COMMA contact_param )* ) )
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:632:7: ( contact_token )
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:632:8: contact_token
            {
                FOLLOWPUSH(FOLLOW_contact_token_in_header_contact2787);
                contact_token(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleheader_contactEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_header_contactPop(ctx);

                    return ret;
                }

            }

            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_contact2795);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_contactEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_contactPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:633:19: ( ( ( lws )? STAR ) | ( contact_param ( COMMA contact_param )* ) )
            {
                int alt46=2;
                alt46 = cdfa46.predict(ctx, RECOGNIZER, ISTREAM, &cdfa46);
                if  (HASEXCEPTION())
                {
                    goto ruleheader_contactEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_header_contactPop(ctx);

                    return ret;
                }
                switch (alt46) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:633:22: ( ( lws )? STAR )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:633:22: ( ( lws )? STAR )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:633:23: ( lws )? STAR
            	        {

            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:633:23: ( lws )?
            	            {
            	                int alt44=2;
            	                switch ( LA(1) ) 
            	                {
            	                    case CRLF:
            	                    case SP:
            	                    	{
            	                    		alt44=1;
            	                    	}
            	                        break;
            	                }

            	                switch (alt44) 
            	                {
            	            	case 1:
            	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:633:23: lws
            	            	    {
            	            	        FOLLOWPUSH(FOLLOW_lws_in_header_contact2819);
            	            	        lws(ctx);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleheader_contactEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            pbelle_sip_messageParser_header_contactPop(ctx);

            	            	            return ret;
            	            	        }

            	            	    }
            	            	    break;

            	                }
            	            }
            	             MATCHT(STAR, &FOLLOW_STAR_in_header_contact2822); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleheader_contactEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_header_contactPop(ctx);

            	                return ret;
            	            }

            	        }

            	        if ( BACKTRACKING==0 ) 
            	        {
            	             	(SCOPE_TOP(header_contact))->current= belle_sip_header_contact_new();
            	                                        belle_sip_header_contact_set_wildcard(	(SCOPE_TOP(header_contact))->current,1);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:635:21: ( contact_param ( COMMA contact_param )* )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:635:21: ( contact_param ( COMMA contact_param )* )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:635:22: contact_param ( COMMA contact_param )*
            	        {
            	            FOLLOWPUSH(FOLLOW_contact_param_in_header_contact2848);
            	            contact_param(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleheader_contactEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_header_contactPop(ctx);

            	                return ret;
            	            }

            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:635:36: ( COMMA contact_param )*

            	            for (;;)
            	            {
            	                int alt45=2;
            	                switch ( LA(1) ) 
            	                {
            	                case COMMA:
            	                	{
            	                		alt45=1;
            	                	}
            	                    break;

            	                }

            	                switch (alt45) 
            	                {
            	            	case 1:
            	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:635:38: COMMA contact_param
            	            	    {
            	            	         MATCHT(COMMA, &FOLLOW_COMMA_in_header_contact2852); 
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleheader_contactEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            pbelle_sip_messageParser_header_contactPop(ctx);

            	            	            return ret;
            	            	        }
            	            	        FOLLOWPUSH(FOLLOW_contact_param_in_header_contact2854);
            	            	        contact_param(ctx);

            	            	        FOLLOWPOP();
            	            	        if  (HASEXCEPTION())
            	            	        {
            	            	            goto ruleheader_contactEx;
            	            	        }
            	            	        if (HASFAILED())
            	            	        {
            	            	            pbelle_sip_messageParser_header_contactPop(ctx);

            	            	            return ret;
            	            	        }

            	            	    }
            	            	    break;

            	            	default:
            	            	    goto loop45;	/* break out of the loop */
            	            	    break;
            	                }
            	            }
            	            loop45: ; /* Jump out to here if this rule does not match */


            	        }


            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_contact))->first; 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_contactEx; /* Prevent compiler warnings */
    ruleheader_contactEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (ret) belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_contactPop(ctx);

    return ret;
}
/* $ANTLR end header_contact */

/** 
 * $ANTLR start contact_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:643:1: contact_param : ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] ) ( SEMI ( lws )? contact_params ( lws )? )* ;
 */
static void
contact_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_contact_paramTop = pbelle_sip_messageParser_contact_paramPush(ctx);
     if (	(SCOPE_TOP(header_contact))->current == NULL) {
                	(SCOPE_TOP(header_contact))->current= belle_sip_header_contact_new();
                 	(SCOPE_TOP(header_contact))->first= 	(SCOPE_TOP(header_contact))->current;
                 	(SCOPE_TOP(contact_param))->prev=NULL; 
             } else {
                	(SCOPE_TOP(contact_param))->prev=	(SCOPE_TOP(header_contact))->current;
                belle_sip_header_set_next(BELLE_SIP_HEADER(	(SCOPE_TOP(header_contact))->current),(belle_sip_header_t*)belle_sip_header_contact_new());
                	(SCOPE_TOP(header_contact))->current= (belle_sip_header_contact_t*)belle_sip_header_get_next(BELLE_SIP_HEADER(	(SCOPE_TOP(header_contact))->current));
             } 
          
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:655:3: ( ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] ) ( SEMI ( lws )? contact_params ( lws )? )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:655:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] ) ( SEMI ( lws )? contact_params ( lws )? )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:655:7: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] | paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)] )
            {
                int alt47=2;
                alt47 = cdfa47.predict(ctx, RECOGNIZER, ISTREAM, &cdfa47);
                if  (HASEXCEPTION())
                {
                    goto rulecontact_paramEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_contact_paramPop(ctx);

                    return ;
                }
                switch (alt47) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:655:9: name_addr[BELLE_SIP_HEADER_ADDRESS($header_contact::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_name_addr_in_contact_param2906);
            	        name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_contact))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:656:8: paramless_addr_spec[BELLE_SIP_HEADER_ADDRESS($header_contact::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_in_contact_param2917);
            	        paramless_addr_spec(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_contact))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:656:81: ( SEMI ( lws )? contact_params ( lws )? )*

            for (;;)
            {
                int alt50=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt50=1;
                	}
                    break;

                }

                switch (alt50) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:656:82: SEMI ( lws )? contact_params ( lws )?
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_contact_param2922); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:656:87: ( lws )?
            	        {
            	            int alt48=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt48=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt48) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:656:87: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_contact_param2924);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecontact_paramEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_contact_params_in_contact_param2927);
            	        contact_params(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecontact_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:656:107: ( lws )?
            	        {
            	            int alt49=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt49=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt49) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:656:107: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_contact_param2929);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecontact_paramEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_contact_paramPop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop50;	/* break out of the loop */
            	    break;
                }
            }
            loop50: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_paramEx; /* Prevent compiler warnings */
    rulecontact_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_contact_paramPop(ctx);

    return ;
}
/* $ANTLR end contact_param */

/** 
 * $ANTLR start header_address
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:659:1: header_address returns [belle_sip_header_address_t* ret] : header_address_base[belle_sip_header_address_new()] ;
 */
static belle_sip_header_address_t*
header_address(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_address_t* ret = NULL;

    belle_sip_header_address_t* header_address_base51;
    #undef	RETURN_TYPE_header_address_base51
    #define	RETURN_TYPE_header_address_base51 belle_sip_header_address_t*

    /* Initialize rule variables
     */


     ret=NULL; 
    header_address_base51 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:661:3: ( header_address_base[belle_sip_header_address_new()] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:661:5: header_address_base[belle_sip_header_address_new()]
        {
            FOLLOWPUSH(FOLLOW_header_address_base_in_header_address2955);
            header_address_base51=header_address_base(ctx, belle_sip_header_address_new());

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_addressEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=header_address_base51;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_addressEx; /* Prevent compiler warnings */
    ruleheader_addressEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end header_address */

/** 
 * $ANTLR start header_address_base
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:663:1: header_address_base[belle_sip_header_address_t* obj] returns [belle_sip_header_address_t* ret] : ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] );
 */
static belle_sip_header_address_t*
header_address_base(pbelle_sip_messageParser ctx, belle_sip_header_address_t* obj)
{   
    belle_sip_header_address_t* ret = NULL;

    /* Initialize rule variables
     */


     ret=obj; 
    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:665:6: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] | addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)] )
            
            ANTLR3_UINT32 alt51;

            alt51=2;

            alt51 = cdfa51.predict(ctx, RECOGNIZER, ISTREAM, &cdfa51);
            if  (HASEXCEPTION())
            {
                goto ruleheader_address_baseEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            switch (alt51) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:665:10: name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)]
        	    {
        	        FOLLOWPUSH(FOLLOW_name_addr_with_generic_uri_in_header_address_base2992);
        	        name_addr_with_generic_uri(ctx, BELLE_SIP_HEADER_ADDRESS(ret));

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleheader_address_baseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ret;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:666:10: addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($ret)]
        	    {
        	        FOLLOWPUSH(FOLLOW_addr_spec_with_generic_uri_in_header_address_base3005);
        	        addr_spec_with_generic_uri(ctx, BELLE_SIP_HEADER_ADDRESS(ret));

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleheader_address_baseEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ret;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_address_baseEx; /* Prevent compiler warnings */
    ruleheader_address_baseEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	      belle_sip_object_unref(ret);
	      ret=NULL;

	}


    }
    else
    {
    }

    return ret;
}
/* $ANTLR end header_address_base */

/** 
 * $ANTLR start name_addr
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:672:1: name_addr[belle_sip_header_address_t* object] : ( ( lws )? display_name[object] )? sp_laquot addr_spec[object] raquot_sp ;
 */
static void
name_addr(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:673:3: ( ( ( lws )? display_name[object] )? sp_laquot addr_spec[object] raquot_sp )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:673:10: ( ( lws )? display_name[object] )? sp_laquot addr_spec[object] raquot_sp
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:673:10: ( ( lws )? display_name[object] )?
            {
                int alt53=2;
                alt53 = cdfa53.predict(ctx, RECOGNIZER, ISTREAM, &cdfa53);
                if  (HASEXCEPTION())
                {
                    goto rulename_addrEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt53) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:673:11: ( lws )? display_name[object]
            	    {

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:673:11: ( lws )?
            	        {
            	            int alt52=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt52=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt52) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:673:11: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_name_addr3040);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulename_addrEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_display_name_in_name_addr3043);
            	        display_name(ctx, object);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulename_addrEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_sp_laquot_in_name_addr3048);
            sp_laquot(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addrEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_addr_spec_in_name_addr3051);
            addr_spec(ctx, object);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addrEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_raquot_sp_in_name_addr3054);
            raquot_sp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addrEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulename_addrEx; /* Prevent compiler warnings */
    rulename_addrEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end name_addr */

/** 
 * $ANTLR start name_addr_with_generic_uri
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:675:1: name_addr_with_generic_uri[belle_sip_header_address_t* object] : ( ( lws )? display_name[object] )? sp_laquot addr_spec_with_generic_uri[object] raquot_sp ;
 */
static void
name_addr_with_generic_uri(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:676:3: ( ( ( lws )? display_name[object] )? sp_laquot addr_spec_with_generic_uri[object] raquot_sp )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:676:10: ( ( lws )? display_name[object] )? sp_laquot addr_spec_with_generic_uri[object] raquot_sp
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:676:10: ( ( lws )? display_name[object] )?
            {
                int alt55=2;
                alt55 = cdfa55.predict(ctx, RECOGNIZER, ISTREAM, &cdfa55);
                if  (HASEXCEPTION())
                {
                    goto rulename_addr_with_generic_uriEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt55) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:676:11: ( lws )? display_name[object]
            	    {

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:676:11: ( lws )?
            	        {
            	            int alt54=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt54=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt54) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:676:11: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_name_addr_with_generic_uri3077);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulename_addr_with_generic_uriEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_display_name_in_name_addr_with_generic_uri3080);
            	        display_name(ctx, object);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulename_addr_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_sp_laquot_in_name_addr_with_generic_uri3085);
            sp_laquot(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addr_with_generic_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_addr_spec_with_generic_uri_in_name_addr_with_generic_uri3088);
            addr_spec_with_generic_uri(ctx, object);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addr_with_generic_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_raquot_sp_in_name_addr_with_generic_uri3091);
            raquot_sp(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulename_addr_with_generic_uriEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulename_addr_with_generic_uriEx; /* Prevent compiler warnings */
    rulename_addr_with_generic_uriEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end name_addr_with_generic_uri */

/** 
 * $ANTLR start addr_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:679:1: addr_spec[belle_sip_header_address_t* object] : ( lws )? uri ( lws )? ;
 */
static void
addr_spec(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_uri_t* uri52;
    #undef	RETURN_TYPE_uri52
    #define	RETURN_TYPE_uri52 belle_sip_uri_t*

    /* Initialize rule variables
     */


    uri52 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:680:3: ( ( lws )? uri ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:680:6: ( lws )? uri ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:680:6: ( lws )?
            {
                int alt56=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt56=1;
                    	}
                        break;
                }

                switch (alt56) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:680:6: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_addr_spec3110);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddr_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_uri_in_addr_spec3113);
            uri52=uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaddr_specEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_address_set_uri(object,uri52);
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:680:68: ( lws )?
            {
                int alt57=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt57=1;
                    	}
                        break;
                }

                switch (alt57) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:680:68: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_addr_spec3117);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddr_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaddr_specEx; /* Prevent compiler warnings */
    ruleaddr_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end addr_spec */

/** 
 * $ANTLR start addr_spec_with_generic_uri
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:682:1: addr_spec_with_generic_uri[belle_sip_header_address_t* object] : ( lws )? ( uri | generic_uri ) ( lws )? ;
 */
static void
addr_spec_with_generic_uri(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_uri_t* uri53;
    #undef	RETURN_TYPE_uri53
    #define	RETURN_TYPE_uri53 belle_sip_uri_t*

    belle_generic_uri_t* generic_uri54;
    #undef	RETURN_TYPE_generic_uri54
    #define	RETURN_TYPE_generic_uri54 belle_generic_uri_t*

    /* Initialize rule variables
     */


    uri53 = NULL;
    generic_uri54 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:683:3: ( ( lws )? ( uri | generic_uri ) ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:683:6: ( lws )? ( uri | generic_uri ) ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:683:6: ( lws )?
            {
                int alt58=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt58=1;
                    	}
                        break;
                }

                switch (alt58) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:683:6: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_addr_spec_with_generic_uri3136);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:683:11: ( uri | generic_uri )
            {
                int alt59=2;
                switch ( LA(1) ) 
                {
                case HEX_CHAR:
                case COMMON_CHAR:
                	{

                		{
                		    int LA59_1 = LA(2);
                		    if ( ((((IS_TOKEN(sip)))||((IS_TOKEN(sips))))) ) 
                		    {
                		        alt59=1;
                		    }
                		    else if ( (ANTLR3_TRUE) ) 
                		    {
                		        alt59=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 59;
                		        EXCEPTION->state        = 1;


                		        goto ruleaddr_spec_with_generic_uriEx;
                		    }
                		}
                	}
                    break;
                case DIGIT:
                case DOT:
                case PLUS:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case PERCENT:
                case BQUOTE:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt59=1;
                	}
                    break;
                case SLASH:
                	{
                		alt59=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 59;
                    EXCEPTION->state        = 0;


                    goto ruleaddr_spec_with_generic_uriEx;
                }

                switch (alt59) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:683:13: uri
            	    {
            	        FOLLOWPUSH(FOLLOW_uri_in_addr_spec_with_generic_uri3141);
            	        uri53=uri(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_header_address_set_uri(object,uri53);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:685:4: generic_uri
            	    {
            	        FOLLOWPUSH(FOLLOW_generic_uri_in_addr_spec_with_generic_uri3156);
            	        generic_uri54=generic_uri(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_header_address_set_absolute_uri(object,generic_uri54);
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:686:6: ( lws )?
            {
                int alt60=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt60=1;
                    	}
                        break;
                }

                switch (alt60) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:686:6: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_addr_spec_with_generic_uri3164);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaddr_spec_with_generic_uriEx; /* Prevent compiler warnings */
    ruleaddr_spec_with_generic_uriEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end addr_spec_with_generic_uri */

/** 
 * $ANTLR start paramless_addr_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:688:1: paramless_addr_spec[belle_sip_header_address_t* object] : ( lws )? paramless_uri ( lws )? ;
 */
static void
paramless_addr_spec(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_uri_t* paramless_uri55;
    #undef	RETURN_TYPE_paramless_uri55
    #define	RETURN_TYPE_paramless_uri55 belle_sip_uri_t*

    /* Initialize rule variables
     */


    paramless_uri55 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:689:3: ( ( lws )? paramless_uri ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:689:6: ( lws )? paramless_uri ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:689:6: ( lws )?
            {
                int alt61=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt61=1;
                    	}
                        break;
                }

                switch (alt61) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:689:6: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_paramless_addr_spec3185);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_addr_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_paramless_uri_in_paramless_addr_spec3188);
            paramless_uri55=paramless_uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparamless_addr_specEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_address_set_uri(object,paramless_uri55);
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:689:88: ( lws )?
            {
                int alt62=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt62=1;
                    	}
                        break;
                }

                switch (alt62) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:689:88: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_paramless_addr_spec3192);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_addr_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamless_addr_specEx; /* Prevent compiler warnings */
    ruleparamless_addr_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end paramless_addr_spec */

/** 
 * $ANTLR start paramless_addr_spec_with_generic_uri
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:691:1: paramless_addr_spec_with_generic_uri[belle_sip_header_address_t* object] : ( lws )? ( paramless_uri | generic_uri_for_from_to_contact_addr_spec ) ( lws )? ;
 */
static void
paramless_addr_spec_with_generic_uri(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_uri_t* paramless_uri56;
    #undef	RETURN_TYPE_paramless_uri56
    #define	RETURN_TYPE_paramless_uri56 belle_sip_uri_t*

    belle_generic_uri_t* generic_uri_for_from_to_contact_addr_spec57;
    #undef	RETURN_TYPE_generic_uri_for_from_to_contact_addr_spec57
    #define	RETURN_TYPE_generic_uri_for_from_to_contact_addr_spec57 belle_generic_uri_t*

    /* Initialize rule variables
     */


    paramless_uri56 = NULL;
    generic_uri_for_from_to_contact_addr_spec57 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:692:3: ( ( lws )? ( paramless_uri | generic_uri_for_from_to_contact_addr_spec ) ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:692:6: ( lws )? ( paramless_uri | generic_uri_for_from_to_contact_addr_spec ) ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:692:6: ( lws )?
            {
                int alt63=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt63=1;
                    	}
                        break;
                }

                switch (alt63) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:692:6: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3214);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_addr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:692:11: ( paramless_uri | generic_uri_for_from_to_contact_addr_spec )
            {
                int alt64=2;
                alt64 = cdfa64.predict(ctx, RECOGNIZER, ISTREAM, &cdfa64);
                if  (HASEXCEPTION())
                {
                    goto ruleparamless_addr_spec_with_generic_uriEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt64) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:692:13: paramless_uri
            	    {
            	        FOLLOWPUSH(FOLLOW_paramless_uri_in_paramless_addr_spec_with_generic_uri3219);
            	        paramless_uri56=paramless_uri(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_addr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_header_address_set_uri(object,paramless_uri56);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:694:4: generic_uri_for_from_to_contact_addr_spec
            	    {
            	        FOLLOWPUSH(FOLLOW_generic_uri_for_from_to_contact_addr_spec_in_paramless_addr_spec_with_generic_uri3233);
            	        generic_uri_for_from_to_contact_addr_spec57=generic_uri_for_from_to_contact_addr_spec(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_addr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_header_address_set_absolute_uri(object,generic_uri_for_from_to_contact_addr_spec57);
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:695:6: ( lws )?
            {
                int alt65=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt65=1;
                    	}
                        break;
                }

                switch (alt65) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:695:6: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_paramless_addr_spec_with_generic_uri3241);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_addr_spec_with_generic_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamless_addr_spec_with_generic_uriEx; /* Prevent compiler warnings */
    ruleparamless_addr_spec_with_generic_uriEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end paramless_addr_spec_with_generic_uri */

/** 
 * $ANTLR start display_name_tokens
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:697:1: display_name_tokens : token ( lws token )* ;
 */
static belle_sip_messageParser_display_name_tokens_return
display_name_tokens(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_display_name_tokens_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:698:2: ( token ( lws token )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:698:3: token ( lws token )*
        {
            FOLLOWPUSH(FOLLOW_token_in_display_name_tokens3256);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledisplay_name_tokensEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:698:9: ( lws token )*

            for (;;)
            {
                int alt66=2;
                alt66 = cdfa66.predict(ctx, RECOGNIZER, ISTREAM, &cdfa66);
                if  (HASEXCEPTION())
                {
                    goto ruledisplay_name_tokensEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                switch (alt66) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:698:10: lws token
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_display_name_tokens3259);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledisplay_name_tokensEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_token_in_display_name_tokens3261);
            	        token(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledisplay_name_tokensEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop66;	/* break out of the loop */
            	    break;
                }
            }
            loop66: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledisplay_name_tokensEx; /* Prevent compiler warnings */
    ruledisplay_name_tokensEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end display_name_tokens */

/** 
 * $ANTLR start display_name
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:699:1: display_name[belle_sip_header_address_t* object] : ( display_name_tokens | quoted_string );
 */
static void
display_name(pbelle_sip_messageParser ctx, belle_sip_header_address_t* object)
{   
    belle_sip_messageParser_display_name_tokens_return display_name_tokens58;
    #undef	RETURN_TYPE_display_name_tokens58
    #define	RETURN_TYPE_display_name_tokens58 belle_sip_messageParser_display_name_tokens_return

    belle_sip_messageParser_quoted_string_return quoted_string59;
    #undef	RETURN_TYPE_quoted_string59
    #define	RETURN_TYPE_quoted_string59 belle_sip_messageParser_quoted_string_return

    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:700:3: ( display_name_tokens | quoted_string )
            
            ANTLR3_UINT32 alt67;

            alt67=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case DOT:
            case PLUS:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case PERCENT:
            case BQUOTE:
            case HEX_CHAR:
            case COMMON_CHAR:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt67=1;
            	}
                break;
            case DQUOTE:
            	{
            		alt67=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 67;
                EXCEPTION->state        = 0;


                goto ruledisplay_nameEx;
            }

            switch (alt67) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:700:6: display_name_tokens
        	    {
        	        FOLLOWPUSH(FOLLOW_display_name_tokens_in_display_name3277);
        	        display_name_tokens58=display_name_tokens(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledisplay_nameEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_address_set_displayname(object,(const char*)((STRSTREAM->toStringTT(STRSTREAM, display_name_tokens58.start, display_name_tokens58.stop))->chars));
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:701:8: quoted_string
        	    {
        	        FOLLOWPUSH(FOLLOW_quoted_string_in_display_name3288);
        	        quoted_string59=quoted_string(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledisplay_nameEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	                 	char* unescaped_char = belle_sip_string_to_backslash_less_unescaped_string((const char*)((STRSTREAM->toStringTT(STRSTREAM, quoted_string59.start, quoted_string59.stop))->chars));
        	                 	belle_sip_header_address_set_quoted_displayname(object,(const char*)unescaped_char);
        	                 	belle_sip_free(unescaped_char);
        	                 	
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledisplay_nameEx; /* Prevent compiler warnings */
    ruledisplay_nameEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end display_name */

/** 
 * $ANTLR start contact_params
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:709:1: contact_params : contact_extension ;
 */
static void
contact_params(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:710:3: ( contact_extension )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:711:27: contact_extension
        {
            FOLLOWPUSH(FOLLOW_contact_extension_in_contact_params3322);
            contact_extension(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontact_paramsEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_paramsEx; /* Prevent compiler warnings */
    rulecontact_paramsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end contact_params */

/** 
 * $ANTLR start contact_extension
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:716:1: contact_extension : generic_param[BELLE_SIP_PARAMETERS($header_contact::current)] ;
 */
static void
contact_extension(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:717:3: ( generic_param[BELLE_SIP_PARAMETERS($header_contact::current)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:717:7: generic_param[BELLE_SIP_PARAMETERS($header_contact::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_contact_extension3337);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_contact))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontact_extensionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontact_extensionEx; /* Prevent compiler warnings */
    rulecontact_extensionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end contact_extension */

/** 
 * $ANTLR start delta_seconds
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:719:1: delta_seconds : ( DIGIT )+ ;
 */
static belle_sip_messageParser_delta_seconds_return
delta_seconds(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_delta_seconds_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:720:3: ( ( DIGIT )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:720:7: ( DIGIT )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:720:7: ( DIGIT )+
            {
                int cnt68=0;

                for (;;)
                {
                    int alt68=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt68=1;
            		}
            	    break;

            	}

            	switch (alt68) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:720:7: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_delta_seconds3357); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledelta_secondsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt68 >= 1 )
            		{
            		    goto loop68;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledelta_secondsEx;
            	}
            	cnt68++;
                }
                loop68: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledelta_secondsEx; /* Prevent compiler warnings */
    ruledelta_secondsEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end delta_seconds */

/** 
 * $ANTLR start content_length_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:759:1: content_length_token : {...}? token ;
 */
static void
content_length_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:759:22: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:759:25: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Content-Length,l))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Content-Length,l)";
                    EXCEPTION->ruleName	 = (void *)"content_length_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_content_length_token3372);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontent_length_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontent_length_tokenEx; /* Prevent compiler warnings */
    rulecontent_length_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end content_length_token */

/** 
 * $ANTLR start header_content_length
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:760:1: header_content_length returns [belle_sip_header_content_length_t* ret] : content_length_token hcolon content_length ;
 */
static belle_sip_header_content_length_t*
header_content_length(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_content_length_t* ret = NULL;

    belle_sip_messageParser_content_length_return content_length60;
    #undef	RETURN_TYPE_content_length60
    #define	RETURN_TYPE_content_length60 belle_sip_messageParser_content_length_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_content_lengthTop = pbelle_sip_messageParser_header_content_lengthPush(ctx);
    	(SCOPE_TOP(header_content_length))->current= belle_sip_header_content_length_new(); ret=	(SCOPE_TOP(header_content_length))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:763:3: ( content_length_token hcolon content_length )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:763:6: content_length_token hcolon content_length
        {
            FOLLOWPUSH(FOLLOW_content_length_token_in_header_content_length3401);
            content_length_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_lengthEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_lengthPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_content_length3411);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_lengthEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_lengthPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_content_length_in_header_content_length3419);
            content_length60=content_length(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_lengthEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_lengthPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_content_length_set_content_length(	(SCOPE_TOP(header_content_length))->current,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, content_length60.start, content_length60.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_content_lengthEx; /* Prevent compiler warnings */
    ruleheader_content_lengthEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_content_length))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_content_lengthPop(ctx);

    return ret;
}
/* $ANTLR end header_content_length */

/** 
 * $ANTLR start content_length
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:772:1: content_length : ( DIGIT )+ ;
 */
static belle_sip_messageParser_content_length_return
content_length(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_content_length_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:772:15: ( ( DIGIT )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:772:16: ( DIGIT )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:772:16: ( DIGIT )+
            {
                int cnt69=0;

                for (;;)
                {
                    int alt69=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt69=1;
            		}
            	    break;

            	}

            	switch (alt69) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:772:16: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_content_length3432); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecontent_lengthEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt69 >= 1 )
            		{
            		    goto loop69;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulecontent_lengthEx;
            	}
            	cnt69++;
                }
                loop69: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontent_lengthEx; /* Prevent compiler warnings */
    rulecontent_lengthEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end content_length */

/** 
 * $ANTLR start content_type_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:774:1: content_type_token : {...}? token ;
 */
static void
content_type_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:774:20: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:774:23: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Content-Type,c))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Content-Type,c)";
                    EXCEPTION->ruleName	 = (void *)"content_type_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_content_type_token3445);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecontent_type_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecontent_type_tokenEx; /* Prevent compiler warnings */
    rulecontent_type_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end content_type_token */

/** 
 * $ANTLR start header_content_type
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:775:1: header_content_type returns [belle_sip_header_content_type_t* ret=NULL] : content_type_token hcolon media_type ;
 */
static belle_sip_header_content_type_t*
header_content_type(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_content_type_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_content_typeTop = pbelle_sip_messageParser_header_content_typePush(ctx);
     	(SCOPE_TOP(header_content_type))->current= belle_sip_header_content_type_new();ret=	(SCOPE_TOP(header_content_type))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:778:3: ( content_type_token hcolon media_type )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:778:6: content_type_token hcolon media_type
        {
            FOLLOWPUSH(FOLLOW_content_type_token_in_header_content_type3472);
            content_type_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_typeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_typePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_content_type3475);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_typeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_typePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_media_type_in_header_content_type3477);
            media_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_content_typeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_content_typePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_content_typeEx; /* Prevent compiler warnings */
    ruleheader_content_typeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	      belle_sip_object_unref(	(SCOPE_TOP(header_content_type))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_content_typePop(ctx);

    return ret;
}
/* $ANTLR end header_content_type */

/** 
 * $ANTLR start media_type
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:785:1: media_type : m_type slash m_subtype ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )* ;
 */
static void
media_type(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_m_type_return m_type61;
    #undef	RETURN_TYPE_m_type61
    #define	RETURN_TYPE_m_type61 belle_sip_messageParser_m_type_return

    belle_sip_messageParser_m_subtype_return m_subtype62;
    #undef	RETURN_TYPE_m_subtype62
    #define	RETURN_TYPE_m_subtype62 belle_sip_messageParser_m_subtype_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:786:3: ( m_type slash m_subtype ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:786:6: m_type slash m_subtype ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )*
        {
            FOLLOWPUSH(FOLLOW_m_type_in_media_type3503);
            m_type61=m_type(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemedia_typeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_content_type_set_type(	(SCOPE_TOP(header_content_type))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, m_type61.start, m_type61.stop))->chars);
            }
            FOLLOWPUSH(FOLLOW_slash_in_media_type3513);
            slash(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemedia_typeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_m_subtype_in_media_type3521);
            m_subtype62=m_subtype(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemedia_typeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_content_type_set_subtype(	(SCOPE_TOP(header_content_type))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, m_subtype62.start, m_subtype62.stop))->chars);
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:789:6: ( semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)] )*

            for (;;)
            {
                int alt70=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case SEMI:
                	{
                		alt70=1;
                	}
                    break;

                }

                switch (alt70) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:789:7: semi generic_param[BELLE_SIP_PARAMETERS($header_content_type::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_media_type3532);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_typeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_generic_param_in_media_type3535);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_content_type))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_typeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop70;	/* break out of the loop */
            	    break;
                }
            }
            loop70: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemedia_typeEx; /* Prevent compiler warnings */
    rulemedia_typeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end media_type */

/** 
 * $ANTLR start m_type
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:790:1: m_type : token ;
 */
static belle_sip_messageParser_m_type_return
m_type(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_m_type_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:791:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:791:5: token
        {
            FOLLOWPUSH(FOLLOW_token_in_m_type3559);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulem_typeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulem_typeEx; /* Prevent compiler warnings */
    rulem_typeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end m_type */

/** 
 * $ANTLR start m_subtype
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:803:1: m_subtype : token ;
 */
static belle_sip_messageParser_m_subtype_return
m_subtype(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_m_subtype_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:803:18: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:803:20: token
        {
            FOLLOWPUSH(FOLLOW_token_in_m_subtype3575);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulem_subtypeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulem_subtypeEx; /* Prevent compiler warnings */
    rulem_subtypeEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end m_subtype */

/** 
 * $ANTLR start cseq_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:814:1: cseq_token : {...}? token ;
 */
static void
cseq_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:814:12: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:814:15: {...}? token
        {
            if ( !((IS_TOKEN(CSeq))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(CSeq)";
                    EXCEPTION->ruleName	 = (void *)"cseq_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_cseq_token3588);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecseq_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecseq_tokenEx; /* Prevent compiler warnings */
    rulecseq_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end cseq_token */

/** 
 * $ANTLR start header_cseq
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:815:1: header_cseq returns [belle_sip_header_cseq_t* ret] : cseq_token hcolon seq_number lws method ;
 */
static belle_sip_header_cseq_t*
header_cseq(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_cseq_t* ret = NULL;

    belle_sip_messageParser_seq_number_return seq_number63;
    #undef	RETURN_TYPE_seq_number63
    #define	RETURN_TYPE_seq_number63 belle_sip_messageParser_seq_number_return

    belle_sip_messageParser_method_return method64;
    #undef	RETURN_TYPE_method64
    #define	RETURN_TYPE_method64 belle_sip_messageParser_method_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_cseqTop = pbelle_sip_messageParser_header_cseqPush(ctx);
     	(SCOPE_TOP(header_cseq))->current= belle_sip_header_cseq_new();ret= 	(SCOPE_TOP(header_cseq))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:818:3: ( cseq_token hcolon seq_number lws method )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:818:5: cseq_token hcolon seq_number lws method
        {
            FOLLOWPUSH(FOLLOW_cseq_token_in_header_cseq3614);
            cseq_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_cseq3620);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_seq_number_in_header_cseq3627);
            seq_number63=seq_number(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_cseq_set_seq_number(	(SCOPE_TOP(header_cseq))->current,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, seq_number63.start, seq_number63.stop))->chars));
            }
            FOLLOWPUSH(FOLLOW_lws_in_header_cseq3636);
            lws(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_method_in_header_cseq3643);
            method64=method(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_cseqEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_cseqPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_cseq_set_method(	(SCOPE_TOP(header_cseq))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, method64.start, method64.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_cseqEx; /* Prevent compiler warnings */
    ruleheader_cseqEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_cseq))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_cseqPop(ctx);

    return ret;
}
/* $ANTLR end header_cseq */

/** 
 * $ANTLR start seq_number
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:829:1: seq_number : ( DIGIT )+ ;
 */
static belle_sip_messageParser_seq_number_return
seq_number(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_seq_number_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:829:11: ( ( DIGIT )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:829:12: ( DIGIT )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:829:12: ( DIGIT )+
            {
                int cnt71=0;

                for (;;)
                {
                    int alt71=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt71=1;
            		}
            	    break;

            	}

            	switch (alt71) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:829:12: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_seq_number3662); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleseq_numberEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt71 >= 1 )
            		{
            		    goto loop71;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleseq_numberEx;
            	}
            	cnt71++;
                }
                loop71: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleseq_numberEx; /* Prevent compiler warnings */
    ruleseq_numberEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end seq_number */

/** 
 * $ANTLR start date_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:832:1: date_token : {...}? token ;
 */
static void
date_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:832:11: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:832:13: {...}? token
        {
            if ( !((IS_TOKEN(Date))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Date)";
                    EXCEPTION->ruleName	 = (void *)"date_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_date_token3674);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledate_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledate_tokenEx; /* Prevent compiler warnings */
    ruledate_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end date_token */

/** 
 * $ANTLR start header_date
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:834:1: header_date returns [belle_sip_header_date_t* ret] : date_token hcolon sip_date ;
 */
static belle_sip_header_date_t*
header_date(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_date_t* ret = NULL;

    belle_sip_messageParser_sip_date_return sip_date65;
    #undef	RETURN_TYPE_sip_date65
    #define	RETURN_TYPE_sip_date65 belle_sip_messageParser_sip_date_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_dateTop = pbelle_sip_messageParser_header_datePush(ctx);
    	(SCOPE_TOP(header_date))->current= belle_sip_header_date_new(); ret=	(SCOPE_TOP(header_date))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:837:3: ( date_token hcolon sip_date )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:837:6: date_token hcolon sip_date
        {
            FOLLOWPUSH(FOLLOW_date_token_in_header_date3704);
            date_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_dateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_datePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_date3708);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_dateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_datePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sip_date_in_header_date3710);
            sip_date65=sip_date(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_dateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_datePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_date_set_date(	(SCOPE_TOP(header_date))->current,(const char*) (STRSTREAM->toStringTT(STRSTREAM, sip_date65.start, sip_date65.stop))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_dateEx; /* Prevent compiler warnings */
    ruleheader_dateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_date))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_datePop(ctx);

    return ret;
}
/* $ANTLR end header_date */

/** 
 * $ANTLR start date
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:845:1: date : sip_date ;
 */
static void
date(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:846:3: ( sip_date )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:846:5: sip_date
        {
            FOLLOWPUSH(FOLLOW_sip_date_in_date3727);
            sip_date(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledateEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledateEx; /* Prevent compiler warnings */
    ruledateEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end date */

/** 
 * $ANTLR start sip_date
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:848:1: sip_date : alpha alpha alpha COMMA SP DIGIT DIGIT SP alpha alpha alpha SP DIGIT DIGIT DIGIT DIGIT SP DIGIT DIGIT COLON DIGIT DIGIT COLON DIGIT DIGIT SP alpha alpha alpha ;
 */
static belle_sip_messageParser_sip_date_return
sip_date(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_sip_date_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:849:3: ( alpha alpha alpha COMMA SP DIGIT DIGIT SP alpha alpha alpha SP DIGIT DIGIT DIGIT DIGIT SP DIGIT DIGIT COLON DIGIT DIGIT COLON DIGIT DIGIT SP alpha alpha alpha )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:849:15: alpha alpha alpha COMMA SP DIGIT DIGIT SP alpha alpha alpha SP DIGIT DIGIT DIGIT DIGIT SP DIGIT DIGIT COLON DIGIT DIGIT COLON DIGIT DIGIT SP alpha alpha alpha
        {
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3739);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3741);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3743);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(COMMA, &FOLLOW_COMMA_in_sip_date3745); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(SP, &FOLLOW_SP_in_sip_date3747); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3750); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3752); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(SP, &FOLLOW_SP_in_sip_date3754); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3756);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3758);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3760);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(SP, &FOLLOW_SP_in_sip_date3762); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3764); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3766); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3768); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3770); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(SP, &FOLLOW_SP_in_sip_date3772); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3775); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3777); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(COLON, &FOLLOW_COLON_in_sip_date3780); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3782); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3784); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(COLON, &FOLLOW_COLON_in_sip_date3787); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3789); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DIGIT, &FOLLOW_DIGIT_in_sip_date3791); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(SP, &FOLLOW_SP_in_sip_date3793); 
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3796);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3798);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_alpha_in_sip_date3800);
            alpha(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_dateEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_dateEx; /* Prevent compiler warnings */
    rulesip_dateEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end sip_date */

/** 
 * $ANTLR start header_expires
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:873:1: header_expires returns [belle_sip_header_expires_t* ret] : {...}? token hcolon delta_seconds ;
 */
static belle_sip_header_expires_t*
header_expires(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_expires_t* ret = NULL;

    belle_sip_messageParser_delta_seconds_return delta_seconds66;
    #undef	RETURN_TYPE_delta_seconds66
    #define	RETURN_TYPE_delta_seconds66 belle_sip_messageParser_delta_seconds_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_expiresTop = pbelle_sip_messageParser_header_expiresPush(ctx);
     	(SCOPE_TOP(header_expires))->current= belle_sip_header_expires_new();ret= 	(SCOPE_TOP(header_expires))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:876:3: ({...}? token hcolon delta_seconds )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:876:7: {...}? token hcolon delta_seconds
        {
            if ( !((IS_TOKEN(Expires))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_expiresPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Expires)";
                    EXCEPTION->ruleName	 = (void *)"header_expires";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_expires3840);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_expiresEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_expiresPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_expires3844);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_expiresEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_expiresPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_delta_seconds_in_header_expires3846);
            delta_seconds66=delta_seconds(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_expiresEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_expiresPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_expires_set_expires(	(SCOPE_TOP(header_expires))->current,atoi((const char *)(STRSTREAM->toStringTT(STRSTREAM, delta_seconds66.start, delta_seconds66.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_expiresEx; /* Prevent compiler warnings */
    ruleheader_expiresEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_expires))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_expiresPop(ctx);

    return ret;
}
/* $ANTLR end header_expires */

/** 
 * $ANTLR start from_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:884:1: from_token : {...}? token ;
 */
static void
from_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:884:11: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:884:14: {...}? token
        {
            if ( !((IS_HEADER_NAMED(From,f))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(From,f)";
                    EXCEPTION->ruleName	 = (void *)"from_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_from_token3867);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefrom_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefrom_tokenEx; /* Prevent compiler warnings */
    rulefrom_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end from_token */

/** 
 * $ANTLR start header_from
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:885:1: header_from returns [belle_sip_header_from_t* ret] : from_token sp_tab_colon from_spec ;
 */
static belle_sip_header_from_t*
header_from(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_from_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_fromTop = pbelle_sip_messageParser_header_fromPush(ctx);
     	(SCOPE_TOP(header_from))->current= belle_sip_header_from_new();ret= 	(SCOPE_TOP(header_from))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:889:3: ( from_token sp_tab_colon from_spec )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:889:7: from_token sp_tab_colon from_spec
        {
            FOLLOWPUSH(FOLLOW_from_token_in_header_from3904);
            from_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_fromEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_fromPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_from3907);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_fromEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_fromPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_from_spec_in_header_from3909);
            from_spec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_fromEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_fromPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_fromEx; /* Prevent compiler warnings */
    ruleheader_fromEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_from))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_fromPop(ctx);

    return ret;
}
/* $ANTLR end header_from */

/** 
 * $ANTLR start from_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:897:1: from_spec : ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] ) ( SEMI ( lws )? from_param ( lws )? )* ;
 */
static void
from_spec(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:898:3: ( ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] ) ( SEMI ( lws )? from_param ( lws )? )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:898:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] ) ( SEMI ( lws )? from_param ( lws )? )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:898:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)] )
            {
                int alt72=2;
                alt72 = cdfa72.predict(ctx, RECOGNIZER, ISTREAM, &cdfa72);
                if  (HASEXCEPTION())
                {
                    goto rulefrom_specEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt72) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:898:9: name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_name_addr_with_generic_uri_in_from_spec3936);
            	        name_addr_with_generic_uri(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_from))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:898:87: paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_from::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_with_generic_uri_in_from_spec3941);
            	        paramless_addr_spec_with_generic_uri(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_from))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:899:16: ( SEMI ( lws )? from_param ( lws )? )*

            for (;;)
            {
                int alt75=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt75=1;
                	}
                    break;

                }

                switch (alt75) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:899:18: SEMI ( lws )? from_param ( lws )?
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_from_spec3963); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:899:23: ( lws )?
            	        {
            	            int alt73=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt73=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt73) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:899:23: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_from_spec3965);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefrom_specEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_from_param_in_from_spec3968);
            	        from_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefrom_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:899:39: ( lws )?
            	        {
            	            int alt74=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt74=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt74) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:899:39: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_from_spec3970);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulefrom_specEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop75;	/* break out of the loop */
            	    break;
                }
            }
            loop75: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefrom_specEx; /* Prevent compiler warnings */
    rulefrom_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end from_spec */

/** 
 * $ANTLR start from_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:900:1: from_param : generic_param[BELLE_SIP_PARAMETERS($header_from::current)] ;
 */
static void
from_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:901:3: ( generic_param[BELLE_SIP_PARAMETERS($header_from::current)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:901:23: generic_param[BELLE_SIP_PARAMETERS($header_from::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_from_param3988);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_from))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefrom_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefrom_paramEx; /* Prevent compiler warnings */
    rulefrom_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end from_param */

/** 
 * $ANTLR start header_max_forwards
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:911:1: header_max_forwards returns [belle_sip_header_max_forwards_t* ret] : {...}? token hcolon max_forwards ;
 */
static belle_sip_header_max_forwards_t*
header_max_forwards(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_max_forwards_t* ret = NULL;

    belle_sip_messageParser_max_forwards_return max_forwards67;
    #undef	RETURN_TYPE_max_forwards67
    #define	RETURN_TYPE_max_forwards67 belle_sip_messageParser_max_forwards_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_max_forwardsTop = pbelle_sip_messageParser_header_max_forwardsPush(ctx);
     	(SCOPE_TOP(header_max_forwards))->current= belle_sip_header_max_forwards_new();ret= 	(SCOPE_TOP(header_max_forwards))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:914:3: ({...}? token hcolon max_forwards )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:914:7: {...}? token hcolon max_forwards
        {
            if ( !((IS_TOKEN(Max-Forwards))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Max-Forwards)";
                    EXCEPTION->ruleName	 = (void *)"header_max_forwards";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_max_forwards4049);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_max_forwardsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_max_forwards4053);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_max_forwardsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_max_forwards_in_header_max_forwards4060);
            max_forwards67=max_forwards(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_max_forwardsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_max_forwardsPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_max_forwards_set_max_forwards(	(SCOPE_TOP(header_max_forwards))->current,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, max_forwards67.start, max_forwards67.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_max_forwardsEx; /* Prevent compiler warnings */
    ruleheader_max_forwardsEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_max_forwards))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_max_forwardsPop(ctx);

    return ret;
}
/* $ANTLR end header_max_forwards */

/** 
 * $ANTLR start max_forwards
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:922:1: max_forwards : ( DIGIT )+ ;
 */
static belle_sip_messageParser_max_forwards_return
max_forwards(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_max_forwards_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:922:13: ( ( DIGIT )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:922:14: ( DIGIT )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:922:14: ( DIGIT )+
            {
                int cnt76=0;

                for (;;)
                {
                    int alt76=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt76=1;
            		}
            	    break;

            	}

            	switch (alt76) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:922:14: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_max_forwards4074); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemax_forwardsEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt76 >= 1 )
            		{
            		    goto loop76;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulemax_forwardsEx;
            	}
            	cnt76++;
                }
                loop76: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemax_forwardsEx; /* Prevent compiler warnings */
    rulemax_forwardsEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end max_forwards */

/** 
 * $ANTLR start header_proxy_authenticate
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:945:1: header_proxy_authenticate returns [belle_sip_header_proxy_authenticate_t* ret] : {...}? token hcolon challenge[BELLE_SIP_HEADER_WWW_AUTHENTICATE($header_proxy_authenticate::current)] ;
 */
static belle_sip_header_proxy_authenticate_t*
header_proxy_authenticate(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_proxy_authenticate_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_proxy_authenticateTop = pbelle_sip_messageParser_header_proxy_authenticatePush(ctx);
     	(SCOPE_TOP(header_proxy_authenticate))->current= belle_sip_header_proxy_authenticate_new();ret= 	(SCOPE_TOP(header_proxy_authenticate))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:948:3: ({...}? token hcolon challenge[BELLE_SIP_HEADER_WWW_AUTHENTICATE($header_proxy_authenticate::current)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:948:7: {...}? token hcolon challenge[BELLE_SIP_HEADER_WWW_AUTHENTICATE($header_proxy_authenticate::current)]
        {
            if ( !((IS_TOKEN(Proxy-Authenticate))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Proxy-Authenticate)";
                    EXCEPTION->ruleName	 = (void *)"header_proxy_authenticate";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_proxy_authenticate4109);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_proxy_authenticate4116);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_challenge_in_header_proxy_authenticate4118);
            challenge(ctx, BELLE_SIP_HEADER_WWW_AUTHENTICATE(	(SCOPE_TOP(header_proxy_authenticate))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_proxy_authenticateEx; /* Prevent compiler warnings */
    ruleheader_proxy_authenticateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_proxy_authenticate))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_proxy_authenticatePop(ctx);

    return ret;
}
/* $ANTLR end header_proxy_authenticate */

/** 
 * $ANTLR start challenge
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:957:1: challenge[belle_sip_header_www_authenticate_t* www_authenticate] : ( ({...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] );
 */
static void
challenge(pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:958:3: ( ({...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* ) | other_challenge[www_authenticate] )
            
            ANTLR3_UINT32 alt78;

            alt78=2;

            alt78 = cdfa78.predict(ctx, RECOGNIZER, ISTREAM, &cdfa78);
            if  (HASEXCEPTION())
            {
                goto rulechallengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt78) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:958:7: ({...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:958:7: ({...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )* )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:958:8: {...}? token lws digest_cln[www_authenticate] ( comma digest_cln[www_authenticate] )*
        	        {
        	            if ( !((IS_TOKEN(Digest))) ) 
        	            {
        	                if (BACKTRACKING>0)
        	                {
        	                    FAILEDFLAG = ANTLR3_TRUE;
        	                    return ;
        	                }
        	                    CONSTRUCTEX();
        	                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
        	                    EXCEPTION->message      = (void *)"IS_TOKEN(Digest)";
        	                    EXCEPTION->ruleName	 = (void *)"challenge";


        	            }
        	            FOLLOWPUSH(FOLLOW_token_in_challenge4154);
        	            token(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulechallengeEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            if ( BACKTRACKING==0 ) 
        	            {
        	                belle_sip_header_www_authenticate_set_scheme(www_authenticate,"Digest");
        	            }
        	            FOLLOWPUSH(FOLLOW_lws_in_challenge4166);
        	            lws(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulechallengeEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_digest_cln_in_challenge4168);
        	            digest_cln(ctx, www_authenticate);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulechallengeEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:959:39: ( comma digest_cln[www_authenticate] )*

        	            for (;;)
        	            {
        	                int alt77=2;
        	                switch ( LA(1) ) 
        	                {
        	                case CRLF:
        	                case SP:
        	                case COMMA:
        	                	{
        	                		alt77=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt77) 
        	                {
        	            	case 1:
        	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:959:40: comma digest_cln[www_authenticate]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_comma_in_challenge4172);
        	            	        comma(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulechallengeEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }
        	            	        FOLLOWPUSH(FOLLOW_digest_cln_in_challenge4174);
        	            	        digest_cln(ctx, www_authenticate);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulechallengeEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop77;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop77: ; /* Jump out to here if this rule does not match */


        	        }


        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:960:26: other_challenge[www_authenticate]
        	    {
        	        FOLLOWPUSH(FOLLOW_other_challenge_in_challenge4205);
        	        other_challenge(ctx, www_authenticate);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulechallengeEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulechallengeEx; /* Prevent compiler warnings */
    rulechallengeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end challenge */

/** 
 * $ANTLR start other_challenge
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:961:1: other_challenge[belle_sip_header_www_authenticate_t* www_authenticate] : auth_scheme lws auth_param[NULL] ( comma auth_param[NULL] )* ;
 */
static void
other_challenge(pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate)
{   
    belle_sip_messageParser_auth_scheme_return auth_scheme68;
    #undef	RETURN_TYPE_auth_scheme68
    #define	RETURN_TYPE_auth_scheme68 belle_sip_messageParser_auth_scheme_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:962:3: ( auth_scheme lws auth_param[NULL] ( comma auth_param[NULL] )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:962:7: auth_scheme lws auth_param[NULL] ( comma auth_param[NULL] )*
        {
            FOLLOWPUSH(FOLLOW_auth_scheme_in_other_challenge4224);
            auth_scheme68=auth_scheme(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_challengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_www_authenticate_set_scheme(www_authenticate,(char*)(STRSTREAM->toStringTT(STRSTREAM, auth_scheme68.start, auth_scheme68.stop))->chars);
            }
            FOLLOWPUSH(FOLLOW_lws_in_other_challenge4234);
            lws(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_challengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_auth_param_in_other_challenge4236);
            auth_param(ctx, NULL);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_challengeEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:964:24: ( comma auth_param[NULL] )*

            for (;;)
            {
                int alt79=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case COMMA:
                	{
                		alt79=1;
                	}
                    break;

                }

                switch (alt79) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:964:25: comma auth_param[NULL]
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_other_challenge4263);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_challengeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_auth_param_in_other_challenge4265);
            	        auth_param(ctx, NULL);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleother_challengeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop79;	/* break out of the loop */
            	    break;
                }
            }
            loop79: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_challengeEx; /* Prevent compiler warnings */
    ruleother_challengeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end other_challenge */

/** 
 * $ANTLR start digest_cln
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:965:1: digest_cln[belle_sip_header_www_authenticate_t* www_authenticate] : ( realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] );
 */
static void
digest_cln(pbelle_sip_messageParser ctx, belle_sip_header_www_authenticate_t* www_authenticate)
{   
    char* realm69;
    #undef	RETURN_TYPE_realm69
    #define	RETURN_TYPE_realm69 char*

    char* nonce70;
    #undef	RETURN_TYPE_nonce70
    #define	RETURN_TYPE_nonce70 char*

    const char* algorithm71;
    #undef	RETURN_TYPE_algorithm71
    #define	RETURN_TYPE_algorithm71 const char*

    char* opaque72;
    #undef	RETURN_TYPE_opaque72
    #define	RETURN_TYPE_opaque72 char*

    belle_sip_list_t* qop_opts73;
    #undef	RETURN_TYPE_qop_opts73
    #define	RETURN_TYPE_qop_opts73 belle_sip_list_t*

    char* domain74;
    #undef	RETURN_TYPE_domain74
    #define	RETURN_TYPE_domain74 char*

    const char* stale75;
    #undef	RETURN_TYPE_stale75
    #define	RETURN_TYPE_stale75 const char*

    /* Initialize rule variables
     */


    realm69 = NULL;
    nonce70 = NULL;
    algorithm71 = NULL;
    opaque72 = NULL;
    qop_opts73 = NULL;
    domain74 = NULL;
    stale75 = NULL;

    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:966:3: ( realm | nonce | algorithm | opaque | qop_opts | domain | stale | auth_param[(belle_sip_header_authorization_t*)www_authenticate] )
            
            ANTLR3_UINT32 alt80;

            alt80=8;

            alt80 = cdfa80.predict(ctx, RECOGNIZER, ISTREAM, &cdfa80);
            if  (HASEXCEPTION())
            {
                goto ruledigest_clnEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt80) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:967:4: realm
        	    {
        	        FOLLOWPUSH(FOLLOW_realm_in_digest_cln4292);
        	        realm69=realm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_realm(www_authenticate,(char*)realm69);
        	                       belle_sip_free(realm69);
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:969:5: nonce
        	    {
        	        FOLLOWPUSH(FOLLOW_nonce_in_digest_cln4301);
        	        nonce70=nonce(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_nonce(www_authenticate,(char*)nonce70);
        	                       belle_sip_free(nonce70);
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:971:5: algorithm
        	    {
        	        FOLLOWPUSH(FOLLOW_algorithm_in_digest_cln4309);
        	        algorithm71=algorithm(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_algorithm(www_authenticate,algorithm71);
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:972:5: opaque
        	    {
        	        FOLLOWPUSH(FOLLOW_opaque_in_digest_cln4318);
        	        opaque72=opaque(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_opaque(www_authenticate,opaque72);
        	                         belle_sip_free(opaque72);
        	        }

        	    }
        	    break;
        	case 5:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:974:5: qop_opts
        	    {
        	        FOLLOWPUSH(FOLLOW_qop_opts_in_digest_cln4327);
        	        qop_opts73=qop_opts(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_qop(www_authenticate,qop_opts73);
        	                          /*belle_sip_free(qop_opts73);*/
        	        }

        	    }
        	    break;
        	case 6:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:976:5: domain
        	    {
        	        FOLLOWPUSH(FOLLOW_domain_in_digest_cln4335);
        	        domain74=domain(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	            belle_sip_header_www_authenticate_set_domain(www_authenticate,domain74);
        	                         belle_sip_free(domain74);
        	        }

        	    }
        	    break;
        	case 7:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:978:5: stale
        	    {
        	        FOLLOWPUSH(FOLLOW_stale_in_digest_cln4344);
        	        stale75=stale(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {
        	             if (strcmp("true",stale75)==0) {
        	                           belle_sip_header_www_authenticate_set_stale(www_authenticate,1);
        	                         }
        	                      
        	        }

        	    }
        	    break;
        	case 8:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:982:8: auth_param[(belle_sip_header_authorization_t*)www_authenticate]
        	    {
        	        FOLLOWPUSH(FOLLOW_auth_param_in_digest_cln4355);
        	        auth_param(ctx, (belle_sip_header_authorization_t*)www_authenticate);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledigest_clnEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledigest_clnEx; /* Prevent compiler warnings */
    ruledigest_clnEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end digest_cln */

/** 
 * $ANTLR start realm
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:985:1: realm returns [char* ret=NULL] : {...}? token equal realm_value ;
 */
static char*
realm(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_realm_value_return realm_value76;
    #undef	RETURN_TYPE_realm_value76
    #define	RETURN_TYPE_realm_value76 belle_sip_messageParser_realm_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:986:3: ({...}? token equal realm_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:986:7: {...}? token equal realm_value
        {
            if ( !((IS_TOKEN(realm))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(realm)";
                    EXCEPTION->ruleName	 = (void *)"realm";


            }
            FOLLOWPUSH(FOLLOW_token_in_realm4390);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_realm4394);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_realm_value_in_realm4396);
            realm_value76=realm_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, realm_value76.start, realm_value76.stop))->chars);
                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerealmEx; /* Prevent compiler warnings */
    rulerealmEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end realm */

/** 
 * $ANTLR start realm_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:989:1: realm_value : quoted_string ;
 */
static belle_sip_messageParser_realm_value_return
realm_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_realm_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:990:3: ( quoted_string )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:990:7: quoted_string
        {
            FOLLOWPUSH(FOLLOW_quoted_string_in_realm_value4418);
            quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerealm_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerealm_valueEx; /* Prevent compiler warnings */
    rulerealm_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end realm_value */

/** 
 * $ANTLR start domain
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:992:1: domain returns [char* ret=NULL] : {...}? token equal quoted_string ;
 */
static char*
domain(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_quoted_string_return quoted_string77;
    #undef	RETURN_TYPE_quoted_string77
    #define	RETURN_TYPE_quoted_string77 belle_sip_messageParser_quoted_string_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:993:3: ({...}? token equal quoted_string )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:993:7: {...}? token equal quoted_string
        {
            if ( !((IS_TOKEN(domain))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(domain)";
                    EXCEPTION->ruleName	 = (void *)"domain";


            }
            FOLLOWPUSH(FOLLOW_token_in_domain4451);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledomainEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_domain4455);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledomainEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_quoted_string_in_domain4457);
            quoted_string77=quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledomainEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, quoted_string77.start, quoted_string77.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruledomainEx; /* Prevent compiler warnings */
    ruledomainEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end domain */

/** 
 * $ANTLR start nonce
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1000:1: nonce returns [char* ret=NULL] : {...}? token equal nonce_value ;
 */
static char*
nonce(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_nonce_value_return nonce_value78;
    #undef	RETURN_TYPE_nonce_value78
    #define	RETURN_TYPE_nonce_value78 belle_sip_messageParser_nonce_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1001:3: ({...}? token equal nonce_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1001:7: {...}? token equal nonce_value
        {
            if ( !((IS_TOKEN(nonce))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(nonce)";
                    EXCEPTION->ruleName	 = (void *)"nonce";


            }
            FOLLOWPUSH(FOLLOW_token_in_nonce4494);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_nonce4498);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_nonce_value_in_nonce4500);
            nonce_value78=nonce_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenonceEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, nonce_value78.start, nonce_value78.stop))->chars);
                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenonceEx; /* Prevent compiler warnings */
    rulenonceEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end nonce */

/** 
 * $ANTLR start opaque
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1004:1: opaque returns [char* ret=NULL] : {...}? token equal quoted_string ;
 */
static char*
opaque(pbelle_sip_messageParser ctx)
{   
    char* ret = NULL;

    belle_sip_messageParser_quoted_string_return quoted_string79;
    #undef	RETURN_TYPE_quoted_string79
    #define	RETURN_TYPE_quoted_string79 belle_sip_messageParser_quoted_string_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1005:3: ({...}? token equal quoted_string )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1005:7: {...}? token equal quoted_string
        {
            if ( !((IS_TOKEN(opaque))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(opaque)";
                    EXCEPTION->ruleName	 = (void *)"opaque";


            }
            FOLLOWPUSH(FOLLOW_token_in_opaque4531);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaqueEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_opaque4535);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaqueEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_quoted_string_in_opaque4537);
            quoted_string79=quoted_string(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopaqueEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {

                                      ret= _belle_sip_str_dup_and_unquote_string((char*)(STRSTREAM->toStringTT(STRSTREAM, quoted_string79.start, quoted_string79.stop))->chars);
                                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleopaqueEx; /* Prevent compiler warnings */
    ruleopaqueEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end opaque */

/** 
 * $ANTLR start stale
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1009:1: stale returns [const char* ret=NULL] : {...}? token equal stale_value ;
 */
static const char*
stale(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_stale_value_return stale_value80;
    #undef	RETURN_TYPE_stale_value80
    #define	RETURN_TYPE_stale_value80 belle_sip_messageParser_stale_value_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1010:3: ({...}? token equal stale_value )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1010:7: {...}? token equal stale_value
        {
            if ( !((IS_TOKEN(stale))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(stale)";
                    EXCEPTION->ruleName	 = (void *)"stale";


            }
            FOLLOWPUSH(FOLLOW_token_in_stale4570);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestaleEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_stale4574);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestaleEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_stale_value_in_stale4576);
            stale_value80=stale_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestaleEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(char*)(STRSTREAM->toStringTT(STRSTREAM, stale_value80.start, stale_value80.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestaleEx; /* Prevent compiler warnings */
    rulestaleEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end stale */

/** 
 * $ANTLR start stale_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1012:1: stale_value : token ;
 */
static belle_sip_messageParser_stale_value_return
stale_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_stale_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1012:12: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1012:13: token
        {
            FOLLOWPUSH(FOLLOW_token_in_stale_value4586);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestale_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestale_valueEx; /* Prevent compiler warnings */
    rulestale_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end stale_value */

/** 
 * $ANTLR start algorithm
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1014:1: algorithm returns [const char* ret=NULL] : {...}? token equal alg_value= token ;
 */
static const char*
algorithm(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_token_return alg_value;
    #undef	RETURN_TYPE_alg_value
    #define	RETURN_TYPE_alg_value belle_sip_messageParser_token_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1015:3: ({...}? token equal alg_value= token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1015:7: {...}? token equal alg_value= token
        {
            if ( !((IS_TOKEN(algorithm))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(algorithm)";
                    EXCEPTION->ruleName	 = (void *)"algorithm";


            }
            FOLLOWPUSH(FOLLOW_token_in_algorithm4615);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_algorithm4619);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_token_in_algorithm4625);
            alg_value=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithmEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(char*)(STRSTREAM->toStringTT(STRSTREAM, alg_value.start, alg_value.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealgorithmEx; /* Prevent compiler warnings */
    rulealgorithmEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end algorithm */

/** 
 * $ANTLR start qop_opts
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1019:1: qop_opts returns [belle_sip_list_t* ret=NULL] : {...}? token equal DQUOTE qop_opts_value ( COMMA qop_opts_value )* DQUOTE ;
 */
static belle_sip_list_t*
qop_opts(pbelle_sip_messageParser ctx)
{   
    belle_sip_list_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_qop_optsTop = pbelle_sip_messageParser_qop_optsPush(ctx);
    	(SCOPE_TOP(qop_opts))->list=NULL;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1022:3: ({...}? token equal DQUOTE qop_opts_value ( COMMA qop_opts_value )* DQUOTE )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1022:7: {...}? token equal DQUOTE qop_opts_value ( COMMA qop_opts_value )* DQUOTE
        {
            if ( !((IS_TOKEN(qop))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_qop_optsPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(qop)";
                    EXCEPTION->ruleName	 = (void *)"qop_opts";


            }
            FOLLOWPUSH(FOLLOW_token_in_qop_opts4665);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_equal_in_qop_opts4669);
            equal(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_qop_opts4675); 
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_qop_opts_value_in_qop_opts4680);
            qop_opts_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1025:3: ( COMMA qop_opts_value )*

            for (;;)
            {
                int alt81=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt81=1;
                	}
                    break;

                }

                switch (alt81) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1025:4: COMMA qop_opts_value
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_qop_opts4686); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleqop_optsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_qop_optsPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_qop_opts_value_in_qop_opts4688);
            	        qop_opts_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleqop_optsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_qop_optsPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop81;	/* break out of the loop */
            	    break;
                }
            }
            loop81: ; /* Jump out to here if this rule does not match */

             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_qop_opts4696); 
            if  (HASEXCEPTION())
            {
                goto ruleqop_optsEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_qop_optsPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=	(SCOPE_TOP(qop_opts))->list;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleqop_optsEx; /* Prevent compiler warnings */
    ruleqop_optsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_qop_optsPop(ctx);

    return ret;
}
/* $ANTLR end qop_opts */

/** 
 * $ANTLR start qop_opts_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1028:1: qop_opts_value : ( lws )? token ( lws )? ;
 */
static void
qop_opts_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_token_return token81;
    #undef	RETURN_TYPE_token81
    #define	RETURN_TYPE_token81 belle_sip_messageParser_token_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1029:1: ( ( lws )? token ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1029:3: ( lws )? token ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1029:3: ( lws )?
            {
                int alt82=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt82=1;
                    	}
                        break;
                }

                switch (alt82) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1029:3: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_qop_opts_value4711);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleqop_opts_valueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            FOLLOWPUSH(FOLLOW_token_in_qop_opts_value4714);
            token81=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleqop_opts_valueEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1029:14: ( lws )?
            {
                int alt83=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt83=1;
                    	}
                        break;
                }

                switch (alt83) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1029:14: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_qop_opts_value4716);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleqop_opts_valueEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                	(SCOPE_TOP(qop_opts))->list=belle_sip_list_append(	(SCOPE_TOP(qop_opts))->list,belle_sip_strdup((const char*)(STRSTREAM->toStringTT(STRSTREAM, token81.start, token81.stop))->chars));
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleqop_opts_valueEx; /* Prevent compiler warnings */
    ruleqop_opts_valueEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end qop_opts_value */

/** 
 * $ANTLR start header_proxy_authorization
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1031:1: header_proxy_authorization returns [belle_sip_header_proxy_authorization_t* ret=NULL] : {...}? token hcolon credentials[(belle_sip_header_authorization_t*)$header_proxy_authorization::current] ;
 */
static belle_sip_header_proxy_authorization_t*
header_proxy_authorization(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_proxy_authorization_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_proxy_authorizationTop = pbelle_sip_messageParser_header_proxy_authorizationPush(ctx);
     	(SCOPE_TOP(header_proxy_authorization))->current= belle_sip_header_proxy_authorization_new();ret= 	(SCOPE_TOP(header_proxy_authorization))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1034:3: ({...}? token hcolon credentials[(belle_sip_header_authorization_t*)$header_proxy_authorization::current] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1034:7: {...}? token hcolon credentials[(belle_sip_header_authorization_t*)$header_proxy_authorization::current]
        {
            if ( !((IS_TOKEN(Proxy-Authorization))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Proxy-Authorization)";
                    EXCEPTION->ruleName	 = (void *)"header_proxy_authorization";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_proxy_authorization4747);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_proxy_authorization4751);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_credentials_in_header_proxy_authorization4753);
            credentials(ctx, (belle_sip_header_authorization_t*)	(SCOPE_TOP(header_proxy_authorization))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_proxy_authorizationEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_proxy_authorizationEx; /* Prevent compiler warnings */
    ruleheader_proxy_authorizationEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_proxy_authorization))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_proxy_authorizationPop(ctx);

    return ret;
}
/* $ANTLR end header_proxy_authorization */

/** 
 * $ANTLR start service_route_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1050:1: service_route_token : {...}? token ;
 */
static void
service_route_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1050:20: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1050:23: {...}? token
        {
            if ( !((IS_TOKEN(Service-Route))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Service-Route)";
                    EXCEPTION->ruleName	 = (void *)"service_route_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_service_route_token4774);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleservice_route_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleservice_route_tokenEx; /* Prevent compiler warnings */
    ruleservice_route_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end service_route_token */

/** 
 * $ANTLR start header_service_route
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1051:1: header_service_route returns [belle_sip_header_service_route_t* ret=NULL] : service_route_token sp_tab_colon srv_route ( COMMA srv_route )* ;
 */
static belle_sip_header_service_route_t*
header_service_route(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_service_route_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_service_routeTop = pbelle_sip_messageParser_header_service_routePush(ctx);
     	(SCOPE_TOP(header_service_route))->current= NULL;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1054:3: ( service_route_token sp_tab_colon srv_route ( COMMA srv_route )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1054:7: service_route_token sp_tab_colon srv_route ( COMMA srv_route )*
        {
            FOLLOWPUSH(FOLLOW_service_route_token_in_header_service_route4802);
            service_route_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_service_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_service_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_service_route4806);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_service_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_service_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_srv_route_in_header_service_route4808);
            srv_route(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_service_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_service_routePop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1054:70: ( COMMA srv_route )*

            for (;;)
            {
                int alt84=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt84=1;
                	}
                    break;

                }

                switch (alt84) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1054:71: COMMA srv_route
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_header_service_route4811); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_service_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_service_routePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_srv_route_in_header_service_route4813);
            	        srv_route(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_service_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_service_routePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop84;	/* break out of the loop */
            	    break;
                }
            }
            loop84: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_service_route))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_service_routeEx; /* Prevent compiler warnings */
    ruleheader_service_routeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (ret) belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_service_routePop(ctx);

    return ret;
}
/* $ANTLR end header_service_route */

/** 
 * $ANTLR start srv_route
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1061:1: srv_route : name_addr[BELLE_SIP_HEADER_ADDRESS($header_service_route::current)] ( SEMI ( lws )? sr_param ( lws )? )* ;
 */
static void
srv_route(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_srv_routeTop = pbelle_sip_messageParser_srv_routePush(ctx);
     if (	(SCOPE_TOP(header_service_route))->current == NULL) {
                	(SCOPE_TOP(header_service_route))->first= 	(SCOPE_TOP(header_service_route))->current = belle_sip_header_service_route_new();
                	(SCOPE_TOP(srv_route))->prev=NULL;
             } else {
                belle_sip_header_t* header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_service_route))->current); 
                	(SCOPE_TOP(srv_route))->prev=	(SCOPE_TOP(header_service_route))->current;
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_service_route))->current= belle_sip_header_service_route_new()));
             } 
          
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:4: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_service_route::current)] ( SEMI ( lws )? sr_param ( lws )? )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:8: name_addr[BELLE_SIP_HEADER_ADDRESS($header_service_route::current)] ( SEMI ( lws )? sr_param ( lws )? )*
        {
            FOLLOWPUSH(FOLLOW_name_addr_in_srv_route4849);
            name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_service_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesrv_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_srv_routePop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:76: ( SEMI ( lws )? sr_param ( lws )? )*

            for (;;)
            {
                int alt87=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt87=1;
                	}
                    break;

                }

                switch (alt87) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:78: SEMI ( lws )? sr_param ( lws )?
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_srv_route4854); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesrv_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_srv_routePop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:83: ( lws )?
            	        {
            	            int alt85=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt85=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt85) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:83: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_srv_route4856);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesrv_routeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_srv_routePop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_sr_param_in_srv_route4859);
            	        sr_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesrv_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_srv_routePop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:97: ( lws )?
            	        {
            	            int alt86=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt86=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt86) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1072:97: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_srv_route4861);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulesrv_routeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_srv_routePop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop87;	/* break out of the loop */
            	    break;
                }
            }
            loop87: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesrv_routeEx; /* Prevent compiler warnings */
    rulesrv_routeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_srv_routePop(ctx);

    return ;
}
/* $ANTLR end srv_route */

/** 
 * $ANTLR start sr_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1075:1: sr_param : generic_param[BELLE_SIP_PARAMETERS($header_service_route::current)] ;
 */
static void
sr_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1076:3: ( generic_param[BELLE_SIP_PARAMETERS($header_service_route::current)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1076:7: generic_param[BELLE_SIP_PARAMETERS($header_service_route::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_sr_param4885);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_service_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesr_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesr_paramEx; /* Prevent compiler warnings */
    rulesr_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sr_param */

/** 
 * $ANTLR start record_route_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1078:1: record_route_token : {...}? token ;
 */
static void
record_route_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1078:19: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1078:22: {...}? token
        {
            if ( !((IS_TOKEN(Record-Route))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Record-Route)";
                    EXCEPTION->ruleName	 = (void *)"record_route_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_record_route_token4898);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerecord_route_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerecord_route_tokenEx; /* Prevent compiler warnings */
    rulerecord_route_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end record_route_token */

/** 
 * $ANTLR start header_record_route
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1079:1: header_record_route returns [belle_sip_header_record_route_t* ret=NULL] : record_route_token sp_tab_colon rec_route ( COMMA rec_route )* ;
 */
static belle_sip_header_record_route_t*
header_record_route(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_record_route_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_record_routeTop = pbelle_sip_messageParser_header_record_routePush(ctx);
     	(SCOPE_TOP(header_record_route))->current= NULL;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1082:3: ( record_route_token sp_tab_colon rec_route ( COMMA rec_route )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1082:7: record_route_token sp_tab_colon rec_route ( COMMA rec_route )*
        {
            FOLLOWPUSH(FOLLOW_record_route_token_in_header_record_route4926);
            record_route_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_record_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_record_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_record_route4930);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_record_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_record_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_rec_route_in_header_record_route4932);
            rec_route(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_record_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_record_routePop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1082:68: ( COMMA rec_route )*

            for (;;)
            {
                int alt88=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt88=1;
                	}
                    break;

                }

                switch (alt88) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1082:70: COMMA rec_route
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_header_record_route4936); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_record_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_record_routePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_rec_route_in_header_record_route4938);
            	        rec_route(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_record_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_record_routePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop88;	/* break out of the loop */
            	    break;
                }
            }
            loop88: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_record_route))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_record_routeEx; /* Prevent compiler warnings */
    ruleheader_record_routeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (ret) belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_record_routePop(ctx);

    return ret;
}
/* $ANTLR end header_record_route */

/** 
 * $ANTLR start rec_route
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1089:1: rec_route : name_addr[BELLE_SIP_HEADER_ADDRESS($header_record_route::current)] ( SEMI ( lws )? rr_param ( lws )? )* ;
 */
static void
rec_route(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_rec_routeTop = pbelle_sip_messageParser_rec_routePush(ctx);
     if (	(SCOPE_TOP(header_record_route))->current == NULL) {
                	(SCOPE_TOP(header_record_route))->first= 	(SCOPE_TOP(header_record_route))->current = belle_sip_header_record_route_new();
                	(SCOPE_TOP(rec_route))->prev=NULL;
             } else {
                belle_sip_header_t* header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_record_route))->current); 
                	(SCOPE_TOP(rec_route))->prev=	(SCOPE_TOP(header_record_route))->current;
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_record_route))->current= belle_sip_header_record_route_new()));
             } 
          
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:3: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_record_route::current)] ( SEMI ( lws )? rr_param ( lws )? )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:7: name_addr[BELLE_SIP_HEADER_ADDRESS($header_record_route::current)] ( SEMI ( lws )? rr_param ( lws )? )*
        {
            FOLLOWPUSH(FOLLOW_name_addr_in_rec_route4973);
            name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_record_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerec_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_rec_routePop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:74: ( SEMI ( lws )? rr_param ( lws )? )*

            for (;;)
            {
                int alt91=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt91=1;
                	}
                    break;

                }

                switch (alt91) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:76: SEMI ( lws )? rr_param ( lws )?
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_rec_route4978); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerec_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_rec_routePop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:81: ( lws )?
            	        {
            	            int alt89=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt89=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt89) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:81: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_rec_route4980);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulerec_routeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_rec_routePop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_rr_param_in_rec_route4983);
            	        rr_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerec_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_rec_routePop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:95: ( lws )?
            	        {
            	            int alt90=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt90=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt90) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1100:95: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_rec_route4985);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulerec_routeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_rec_routePop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop91;	/* break out of the loop */
            	    break;
                }
            }
            loop91: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerec_routeEx; /* Prevent compiler warnings */
    rulerec_routeEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_rec_routePop(ctx);

    return ;
}
/* $ANTLR end rec_route */

/** 
 * $ANTLR start rr_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1102:1: rr_param : generic_param[BELLE_SIP_PARAMETERS($header_record_route::current)] ;
 */
static void
rr_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1103:3: ( generic_param[BELLE_SIP_PARAMETERS($header_record_route::current)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1103:7: generic_param[BELLE_SIP_PARAMETERS($header_record_route::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_rr_param5009);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_record_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerr_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerr_paramEx; /* Prevent compiler warnings */
    rulerr_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end rr_param */

/** 
 * $ANTLR start comment
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1119:1: comment : LPAREN . RPAREN ;
 */
static void
comment(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1119:9: ( LPAREN . RPAREN )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1119:11: LPAREN . RPAREN
        {
             MATCHT(LPAREN, &FOLLOW_LPAREN_in_comment5019); 
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            MATCHANYT(); 
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(RPAREN, &FOLLOW_RPAREN_in_comment5023); 
            if  (HASEXCEPTION())
            {
                goto rulecommentEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommentEx; /* Prevent compiler warnings */
    rulecommentEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end comment */

/** 
 * $ANTLR start route_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1126:1: route_token : {...}? token ;
 */
static void
route_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1126:12: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1126:15: {...}? token
        {
            if ( !((IS_TOKEN(Route))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Route)";
                    EXCEPTION->ruleName	 = (void *)"route_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_route_token5037);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleroute_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleroute_tokenEx; /* Prevent compiler warnings */
    ruleroute_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end route_token */

/** 
 * $ANTLR start header_route
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1127:1: header_route returns [belle_sip_header_route_t* ret=NULL] : route_token sp_tab_colon route_param ( COMMA route_param )* ;
 */
static belle_sip_header_route_t*
header_route(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_route_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_routeTop = pbelle_sip_messageParser_header_routePush(ctx);
     	(SCOPE_TOP(header_route))->current= NULL; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1130:3: ( route_token sp_tab_colon route_param ( COMMA route_param )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1130:7: route_token sp_tab_colon route_param ( COMMA route_param )*
        {
            FOLLOWPUSH(FOLLOW_route_token_in_header_route5065);
            route_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_route5069);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_routePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_route_param_in_header_route5071);
            route_param(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_routeEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_routePop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1130:56: ( COMMA route_param )*

            for (;;)
            {
                int alt92=2;
                switch ( LA(1) ) 
                {
                case COMMA:
                	{
                		alt92=1;
                	}
                    break;

                }

                switch (alt92) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1130:58: COMMA route_param
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_header_route5075); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_routePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_route_param_in_header_route5077);
            	        route_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_routeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_routePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop92;	/* break out of the loop */
            	    break;
                }
            }
            loop92: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_route))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_routeEx; /* Prevent compiler warnings */
    ruleheader_routeEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (ret) belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_routePop(ctx);

    return ret;
}
/* $ANTLR end header_route */

/** 
 * $ANTLR start route_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1137:1: route_param : name_addr[BELLE_SIP_HEADER_ADDRESS($header_route::current)] ( SEMI ( lws )? r_param ( lws )? )* ;
 */
static void
route_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_route_paramTop = pbelle_sip_messageParser_route_paramPush(ctx);
     if (	(SCOPE_TOP(header_route))->current == NULL) {
                	(SCOPE_TOP(header_route))->first= 	(SCOPE_TOP(header_route))->current = belle_sip_header_route_new();
                 	(SCOPE_TOP(route_param))->prev=NULL;
             } else {
                belle_sip_header_t* header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_route))->current); 
                	(SCOPE_TOP(route_param))->prev=	(SCOPE_TOP(header_route))->current;
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_route))->current= belle_sip_header_route_new()));
             } 
          
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:3: ( name_addr[BELLE_SIP_HEADER_ADDRESS($header_route::current)] ( SEMI ( lws )? r_param ( lws )? )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:7: name_addr[BELLE_SIP_HEADER_ADDRESS($header_route::current)] ( SEMI ( lws )? r_param ( lws )? )*
        {
            FOLLOWPUSH(FOLLOW_name_addr_in_route_param5113);
            name_addr(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleroute_paramEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_route_paramPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:67: ( SEMI ( lws )? r_param ( lws )? )*

            for (;;)
            {
                int alt95=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt95=1;
                	}
                    break;

                }

                switch (alt95) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:69: SEMI ( lws )? r_param ( lws )?
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_route_param5118); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleroute_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_route_paramPop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:74: ( lws )?
            	        {
            	            int alt93=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt93=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt93) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:74: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_route_param5120);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleroute_paramEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_route_paramPop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_r_param_in_route_param5123);
            	        r_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleroute_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_route_paramPop(ctx);

            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:87: ( lws )?
            	        {
            	            int alt94=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt94=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt94) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1148:87: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_route_param5125);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleroute_paramEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sip_messageParser_route_paramPop(ctx);

            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop95;	/* break out of the loop */
            	    break;
                }
            }
            loop95: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleroute_paramEx; /* Prevent compiler warnings */
    ruleroute_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_route_paramPop(ctx);

    return ;
}
/* $ANTLR end route_param */

/** 
 * $ANTLR start r_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1150:1: r_param : generic_param[BELLE_SIP_PARAMETERS($header_route::current)] ;
 */
static void
r_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1151:3: ( generic_param[BELLE_SIP_PARAMETERS($header_route::current)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1151:7: generic_param[BELLE_SIP_PARAMETERS($header_route::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_r_param5146);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_route))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruler_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruler_paramEx; /* Prevent compiler warnings */
    ruler_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end r_param */

/** 
 * $ANTLR start to_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1175:1: to_token : {...}? token ;
 */
static void
to_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1175:9: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1175:12: {...}? token
        {
            if ( !((IS_HEADER_NAMED(To,t))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(To,t)";
                    EXCEPTION->ruleName	 = (void *)"to_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_to_token5161);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleto_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleto_tokenEx; /* Prevent compiler warnings */
    ruleto_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end to_token */

/** 
 * $ANTLR start header_to
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1176:1: header_to returns [belle_sip_header_to_t* ret=NULL] : to_token sp_tab_colon to_spec ;
 */
static belle_sip_header_to_t*
header_to(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_to_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_toTop = pbelle_sip_messageParser_header_toPush(ctx);
     	(SCOPE_TOP(header_to))->current= belle_sip_header_to_new(); ret= 	(SCOPE_TOP(header_to))->current;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1180:3: ( to_token sp_tab_colon to_spec )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1180:7: to_token sp_tab_colon to_spec
        {
            FOLLOWPUSH(FOLLOW_to_token_in_header_to5198);
            to_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_toEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_toPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_to5202);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_toEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_toPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_to_spec_in_header_to5204);
            to_spec(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_toEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_toPop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_toEx; /* Prevent compiler warnings */
    ruleheader_toEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_to))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_toPop(ctx);

    return ret;
}
/* $ANTLR end header_to */

/** 
 * $ANTLR start to_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1187:1: to_spec : ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] ) ( SEMI ( lws )? to_param ( lws )? )* ;
 */
static void
to_spec(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1188:3: ( ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] ) ( SEMI ( lws )? to_param ( lws )? )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1188:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] ) ( SEMI ( lws )? to_param ( lws )? )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1188:7: ( name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] | paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)] )
            {
                int alt96=2;
                alt96 = cdfa96.predict(ctx, RECOGNIZER, ISTREAM, &cdfa96);
                if  (HASEXCEPTION())
                {
                    goto ruleto_specEx;
                }
                if (HASFAILED())
                {
                    return ;
                }
                switch (alt96) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1188:9: name_addr_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_name_addr_with_generic_uri_in_to_spec5228);
            	        name_addr_with_generic_uri(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_to))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1188:85: paramless_addr_spec_with_generic_uri[BELLE_SIP_HEADER_ADDRESS($header_to::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_with_generic_uri_in_to_spec5233);
            	        paramless_addr_spec_with_generic_uri(ctx, BELLE_SIP_HEADER_ADDRESS(	(SCOPE_TOP(header_to))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1189:16: ( SEMI ( lws )? to_param ( lws )? )*

            for (;;)
            {
                int alt99=2;
                switch ( LA(1) ) 
                {
                case SEMI:
                	{
                		alt99=1;
                	}
                    break;

                }

                switch (alt99) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1189:18: SEMI ( lws )? to_param ( lws )?
            	    {
            	         MATCHT(SEMI, &FOLLOW_SEMI_in_to_spec5255); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1189:23: ( lws )?
            	        {
            	            int alt97=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt97=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt97) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1189:23: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_to_spec5257);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleto_specEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }
            	        FOLLOWPUSH(FOLLOW_to_param_in_to_spec5260);
            	        to_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleto_specEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1189:37: ( lws )?
            	        {
            	            int alt98=2;
            	            switch ( LA(1) ) 
            	            {
            	                case CRLF:
            	                case SP:
            	                	{
            	                		alt98=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt98) 
            	            {
            	        	case 1:
            	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1189:37: lws
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_lws_in_to_spec5262);
            	        	        lws(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleto_specEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return ;
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop99;	/* break out of the loop */
            	    break;
                }
            }
            loop99: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleto_specEx; /* Prevent compiler warnings */
    ruleto_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end to_spec */

/** 
 * $ANTLR start to_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1190:1: to_param : generic_param[BELLE_SIP_PARAMETERS($header_to::current)] ;
 */
static void
to_param(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1191:3: ( generic_param[BELLE_SIP_PARAMETERS($header_to::current)] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1191:23: generic_param[BELLE_SIP_PARAMETERS($header_to::current)]
        {
            FOLLOWPUSH(FOLLOW_generic_param_in_to_param5280);
            generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_to))->current));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleto_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleto_paramEx; /* Prevent compiler warnings */
    ruleto_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end to_param */

/** 
 * $ANTLR start refer_to_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1193:1: refer_to_token : {...}? token ;
 */
static void
refer_to_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1193:15: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1193:18: {...}? token
        {
            if ( !((IS_TOKEN(Refer-To))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Refer-To)";
                    EXCEPTION->ruleName	 = (void *)"refer_to_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_refer_to_token5292);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerefer_to_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerefer_to_tokenEx; /* Prevent compiler warnings */
    rulerefer_to_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end refer_to_token */

/** 
 * $ANTLR start header_refer_to
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1194:1: header_refer_to returns [belle_sip_header_refer_to_t* ret=NULL] : refer_to_token sp_tab_colon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new())] ;
 */
static belle_sip_header_refer_to_t*
header_refer_to(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_refer_to_t* ret = NULL;

    belle_sip_header_address_t* refer_to_spec82;
    #undef	RETURN_TYPE_refer_to_spec82
    #define	RETURN_TYPE_refer_to_spec82 belle_sip_header_address_t*

    /* Initialize rule variables
     */


    refer_to_spec82 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1195:3: ( refer_to_token sp_tab_colon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new())] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1195:7: refer_to_token sp_tab_colon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new())]
        {
            FOLLOWPUSH(FOLLOW_refer_to_token_in_header_refer_to5311);
            refer_to_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_refer_toEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_refer_to5322);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_refer_toEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_refer_to_spec_in_header_refer_to5331);
            refer_to_spec82=refer_to_spec(ctx, BELLE_SIP_HEADER_ADDRESS(belle_sip_header_refer_to_new()));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_refer_toEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= BELLE_SIP_HEADER_REFER_TO(refer_to_spec82);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_refer_toEx; /* Prevent compiler warnings */
    ruleheader_refer_toEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end header_refer_to */

/** 
 * $ANTLR start referred_by_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1199:1: referred_by_token : {...}? token ;
 */
static void
referred_by_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1199:18: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1199:21: {...}? token
        {
            if ( !((IS_TOKEN(Referred-By))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Referred-By)";
                    EXCEPTION->ruleName	 = (void *)"referred_by_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_referred_by_token5344);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulereferred_by_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereferred_by_tokenEx; /* Prevent compiler warnings */
    rulereferred_by_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end referred_by_token */

/** 
 * $ANTLR start header_referred_by
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1200:1: header_referred_by returns [belle_sip_header_referred_by_t* ret=NULL] : referred_by_token sp_tab_colon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new())] ;
 */
static belle_sip_header_referred_by_t*
header_referred_by(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_referred_by_t* ret = NULL;

    belle_sip_header_address_t* refer_to_spec83;
    #undef	RETURN_TYPE_refer_to_spec83
    #define	RETURN_TYPE_refer_to_spec83 belle_sip_header_address_t*

    /* Initialize rule variables
     */


    refer_to_spec83 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1201:3: ( referred_by_token sp_tab_colon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new())] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1201:7: referred_by_token sp_tab_colon refer_to_spec[BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new())]
        {
            FOLLOWPUSH(FOLLOW_referred_by_token_in_header_referred_by5363);
            referred_by_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_referred_byEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_referred_by5374);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_referred_byEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_refer_to_spec_in_header_referred_by5383);
            refer_to_spec83=refer_to_spec(ctx, BELLE_SIP_HEADER_ADDRESS(belle_sip_header_referred_by_new()));

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_referred_byEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= BELLE_SIP_HEADER_REFERRED_BY(refer_to_spec83);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_referred_byEx; /* Prevent compiler warnings */
    ruleheader_referred_byEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end header_referred_by */

/** 
 * $ANTLR start refer_to_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1205:1: refer_to_spec[belle_sip_header_address_t* address] returns [belle_sip_header_address_t* ret] : ( ( name_addr[address] | paramless_addr_spec[address] ) ( SEMI ( lws )? generic_param[BELLE_SIP_PARAMETERS(address)] ( lws )? )* ) ;
 */
static belle_sip_header_address_t*
refer_to_spec(pbelle_sip_messageParser ctx, belle_sip_header_address_t* address)
{   
    belle_sip_header_address_t* ret = NULL;

    /* Initialize rule variables
     */


    ret=address;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:3: ( ( ( name_addr[address] | paramless_addr_spec[address] ) ( SEMI ( lws )? generic_param[BELLE_SIP_PARAMETERS(address)] ( lws )? )* ) )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:7: ( ( name_addr[address] | paramless_addr_spec[address] ) ( SEMI ( lws )? generic_param[BELLE_SIP_PARAMETERS(address)] ( lws )? )* )
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:7: ( ( name_addr[address] | paramless_addr_spec[address] ) ( SEMI ( lws )? generic_param[BELLE_SIP_PARAMETERS(address)] ( lws )? )* )
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:8: ( name_addr[address] | paramless_addr_spec[address] ) ( SEMI ( lws )? generic_param[BELLE_SIP_PARAMETERS(address)] ( lws )? )*
            {

                // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:8: ( name_addr[address] | paramless_addr_spec[address] )
                {
                    int alt100=2;
                    alt100 = cdfa100.predict(ctx, RECOGNIZER, ISTREAM, &cdfa100);
                    if  (HASEXCEPTION())
                    {
                        goto rulerefer_to_specEx;
                    }
                    if (HASFAILED())
                    {
                        return ret;
                    }
                    switch (alt100) 
                    {
                	case 1:
                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:10: name_addr[address]
                	    {
                	        FOLLOWPUSH(FOLLOW_name_addr_in_refer_to_spec5417);
                	        name_addr(ctx, address);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }

                	    }
                	    break;
                	case 2:
                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:31: paramless_addr_spec[address]
                	    {
                	        FOLLOWPUSH(FOLLOW_paramless_addr_spec_in_refer_to_spec5422);
                	        paramless_addr_spec(ctx, address);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }

                	    }
                	    break;

                    }
                }

                // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:62: ( SEMI ( lws )? generic_param[BELLE_SIP_PARAMETERS(address)] ( lws )? )*

                for (;;)
                {
                    int alt103=2;
                    switch ( LA(1) ) 
                    {
                    case SEMI:
                    	{
                    		alt103=1;
                    	}
                        break;

                    }

                    switch (alt103) 
                    {
                	case 1:
                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:64: SEMI ( lws )? generic_param[BELLE_SIP_PARAMETERS(address)] ( lws )?
                	    {
                	         MATCHT(SEMI, &FOLLOW_SEMI_in_refer_to_spec5429); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }

                	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:69: ( lws )?
                	        {
                	            int alt101=2;
                	            switch ( LA(1) ) 
                	            {
                	                case CRLF:
                	                case SP:
                	                	{
                	                		alt101=1;
                	                	}
                	                    break;
                	            }

                	            switch (alt101) 
                	            {
                	        	case 1:
                	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:69: lws
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_lws_in_refer_to_spec5431);
                	        	        lws(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulerefer_to_specEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return ret;
                	        	        }

                	        	    }
                	        	    break;

                	            }
                	        }
                	        FOLLOWPUSH(FOLLOW_generic_param_in_refer_to_spec5434);
                	        generic_param(ctx, BELLE_SIP_PARAMETERS(address));

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulerefer_to_specEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            return ret;
                	        }

                	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:120: ( lws )?
                	        {
                	            int alt102=2;
                	            switch ( LA(1) ) 
                	            {
                	                case CRLF:
                	                case SP:
                	                	{
                	                		alt102=1;
                	                	}
                	                    break;
                	            }

                	            switch (alt102) 
                	            {
                	        	case 1:
                	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1207:120: lws
                	        	    {
                	        	        FOLLOWPUSH(FOLLOW_lws_in_refer_to_spec5438);
                	        	        lws(ctx);

                	        	        FOLLOWPOP();
                	        	        if  (HASEXCEPTION())
                	        	        {
                	        	            goto rulerefer_to_specEx;
                	        	        }
                	        	        if (HASFAILED())
                	        	        {
                	        	            return ret;
                	        	        }

                	        	    }
                	        	    break;

                	            }
                	        }

                	    }
                	    break;

                	default:
                	    goto loop103;	/* break out of the loop */
                	    break;
                    }
                }
                loop103: ; /* Jump out to here if this rule does not match */


            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerefer_to_specEx; /* Prevent compiler warnings */
    rulerefer_to_specEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(address);
	       ret=NULL;

	}


    }
    else
    {
    }

    return ret;
}
/* $ANTLR end refer_to_spec */

/** 
 * $ANTLR start header_user_agent
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1220:1: header_user_agent returns [belle_sip_header_user_agent_t* ret] : {...}? token hcolon server_val ( lws server_val )* ;
 */
static belle_sip_header_user_agent_t*
header_user_agent(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_user_agent_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_user_agentTop = pbelle_sip_messageParser_header_user_agentPush(ctx);
     	(SCOPE_TOP(header_user_agent))->current= belle_sip_header_user_agent_new();ret= 	(SCOPE_TOP(header_user_agent))->current;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1223:3: ({...}? token hcolon server_val ( lws server_val )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1223:7: {...}? token hcolon server_val ( lws server_val )*
        {
            if ( !((IS_TOKEN(User-Agent))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_user_agentPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(User-Agent)";
                    EXCEPTION->ruleName	 = (void *)"header_user_agent";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_user_agent5489);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_user_agentEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_user_agentPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_user_agent5493);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_user_agentEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_user_agentPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_server_val_in_header_user_agent5495);
            server_val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_user_agentEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_user_agentPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1223:72: ( lws server_val )*

            for (;;)
            {
                int alt104=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                	{
                		alt104=1;
                	}
                    break;

                }

                switch (alt104) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1223:73: lws server_val
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_header_user_agent5498);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_user_agentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_user_agentPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_server_val_in_header_user_agent5500);
            	        server_val(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_user_agentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_user_agentPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop104;	/* break out of the loop */
            	    break;
                }
            }
            loop104: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_user_agentEx; /* Prevent compiler warnings */
    ruleheader_user_agentEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_user_agent))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_user_agentPop(ctx);

    return ret;
}
/* $ANTLR end header_user_agent */

/** 
 * $ANTLR start server_val
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1231:1: server_val : word ;
 */
static void
server_val(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_word_return word84;
    #undef	RETURN_TYPE_word84
    #define	RETURN_TYPE_word84 belle_sip_messageParser_word_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1231:15: ( word )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1231:17: word
        {
            FOLLOWPUSH(FOLLOW_word_in_server_val5520);
            word84=word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleserver_valEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_user_agent_add_product(	(SCOPE_TOP(header_user_agent))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, word84.start, word84.stop))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleserver_valEx; /* Prevent compiler warnings */
    ruleserver_valEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end server_val */

/** 
 * $ANTLR start via_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1239:1: via_token : {...}? token ;
 */
static void
via_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1239:10: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1239:13: {...}? token
        {
            if ( !((IS_HEADER_NAMED(Via,v))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_HEADER_NAMED(Via,v)";
                    EXCEPTION->ruleName	 = (void *)"via_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_via_token5533);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_tokenEx; /* Prevent compiler warnings */
    rulevia_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end via_token */

/** 
 * $ANTLR start header_via
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1240:1: header_via returns [belle_sip_header_via_t* ret] : via_token hcolon via_parm ( comma via_parm )* ;
 */
static belle_sip_header_via_t*
header_via(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_via_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_viaTop = pbelle_sip_messageParser_header_viaPush(ctx);
     	(SCOPE_TOP(header_via))->current= NULL;ret= NULL;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1244:3: ( via_token hcolon via_parm ( comma via_parm )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1244:7: via_token hcolon via_parm ( comma via_parm )*
        {
            FOLLOWPUSH(FOLLOW_via_token_in_header_via5570);
            via_token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_viaEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_viaPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_via5573);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_viaEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_viaPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_via_parm_in_header_via5575);
            via_parm(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_viaEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_viaPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1244:53: ( comma via_parm )*

            for (;;)
            {
                int alt105=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case COMMA:
                	{
                		alt105=1;
                	}
                    break;

                }

                switch (alt105) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1244:54: comma via_parm
            	    {
            	        FOLLOWPUSH(FOLLOW_comma_in_header_via5578);
            	        comma(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_viaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_viaPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_via_parm_in_header_via5580);
            	        via_parm(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_viaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_viaPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop105;	/* break out of the loop */
            	    break;
                }
            }
            loop105: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(header_via))->first;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_viaEx; /* Prevent compiler warnings */
    ruleheader_viaEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (ret) belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_viaPop(ctx);

    return ret;
}
/* $ANTLR end header_via */

/** 
 * $ANTLR start via_parm
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1251:1: via_parm : sent_protocol lws sent_by ( semi via_params )* ;
 */
static void
via_parm(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_via_parmTop = pbelle_sip_messageParser_via_parmPush(ctx);
     if (	(SCOPE_TOP(header_via))->current == NULL) {
                	(SCOPE_TOP(header_via))->first= 	(SCOPE_TOP(header_via))->current = belle_sip_header_via_new();
                	(SCOPE_TOP(via_parm))->prev=NULL;
             } else {
          belle_sip_header_t* header;
                	(SCOPE_TOP(via_parm))->prev=	(SCOPE_TOP(header_via))->current;
                header = BELLE_SIP_HEADER(	(SCOPE_TOP(header_via))->current); 
                belle_sip_header_set_next(header,(belle_sip_header_t*)(	(SCOPE_TOP(header_via))->current= belle_sip_header_via_new()));
             } 
          
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1263:3: ( sent_protocol lws sent_by ( semi via_params )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1263:7: sent_protocol lws sent_by ( semi via_params )*
        {
            FOLLOWPUSH(FOLLOW_sent_protocol_in_via_parm5621);
            sent_protocol(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_parmEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_via_parmPop(ctx);

                return ;
            }
            FOLLOWPUSH(FOLLOW_lws_in_via_parm5624);
            lws(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_parmEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_via_parmPop(ctx);

                return ;
            }
            FOLLOWPUSH(FOLLOW_sent_by_in_via_parm5626);
            sent_by(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_parmEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_via_parmPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1263:34: ( semi via_params )*

            for (;;)
            {
                int alt106=2;
                alt106 = cdfa106.predict(ctx, RECOGNIZER, ISTREAM, &cdfa106);
                if  (HASEXCEPTION())
                {
                    goto rulevia_parmEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_via_parmPop(ctx);

                    return ;
                }
                switch (alt106) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1263:36: semi via_params
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_via_parm5630);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevia_parmEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_via_parmPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_via_params_in_via_parm5632);
            	        via_params(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevia_parmEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_via_parmPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop106;	/* break out of the loop */
            	    break;
                }
            }
            loop106: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_parmEx; /* Prevent compiler warnings */
    rulevia_parmEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_via_parmPop(ctx);

    return ;
}
/* $ANTLR end via_parm */

/** 
 * $ANTLR start via_params
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1265:1: via_params : ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] );
 */
static void
via_params(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1266:3: ( via_received[$header_via::current] | generic_param[BELLE_SIP_PARAMETERS($header_via::current)] )
            
            ANTLR3_UINT32 alt107;

            alt107=2;

            alt107 = cdfa107.predict(ctx, RECOGNIZER, ISTREAM, &cdfa107);
            if  (HASEXCEPTION())
            {
                goto rulevia_paramsEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt107) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1268:41: via_received[$header_via::current]
        	    {
        	        FOLLOWPUSH(FOLLOW_via_received_in_via_params5659);
        	        via_received(ctx, 	(SCOPE_TOP(header_via))->current);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_paramsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1268:78: generic_param[BELLE_SIP_PARAMETERS($header_via::current)]
        	    {
        	        FOLLOWPUSH(FOLLOW_generic_param_in_via_params5664);
        	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_via))->current));

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_paramsEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_paramsEx; /* Prevent compiler warnings */
    rulevia_paramsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end via_params */

/** 
 * $ANTLR start via_received
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1273:1: via_received[belle_sip_header_via_t* object] : {...}? token EQUAL via_address ;
 */
static void
via_received(pbelle_sip_messageParser ctx, belle_sip_header_via_t* object)
{   
    belle_sip_messageParser_via_address_return via_address85;
    #undef	RETURN_TYPE_via_address85
    #define	RETURN_TYPE_via_address85 belle_sip_messageParser_via_address_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1274:3: ({...}? token EQUAL via_address )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1274:5: {...}? token EQUAL via_address
        {
            if ( !((IS_TOKEN(received))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(received)";
                    EXCEPTION->ruleName	 = (void *)"via_received";


            }
            FOLLOWPUSH(FOLLOW_token_in_via_received5682);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_receivedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(EQUAL, &FOLLOW_EQUAL_in_via_received5684); 
            if  (HASEXCEPTION())
            {
                goto rulevia_receivedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_via_address_in_via_received5686);
            via_address85=via_address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevia_receivedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_received(object,(const char*)(STRSTREAM->toStringTT(STRSTREAM, via_address85.start, via_address85.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_receivedEx; /* Prevent compiler warnings */
    rulevia_receivedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end via_received */

/** 
 * $ANTLR start via_address
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1276:1: via_address : ( ipv4address | ipv6address );
 */
static belle_sip_messageParser_via_address_return
via_address(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_via_address_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1276:12: ( ipv4address | ipv6address )
            
            ANTLR3_UINT32 alt108;

            alt108=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            	{
            		switch ( LA(2) ) 
            		{
            		case DIGIT:
            			{
            				switch ( LA(3) ) 
            				{
            				case DIGIT:
            					{
            						switch ( LA(4) ) 
            						{
            						case EOF:
            						case CRLF:
            						case SP:
            						case DIGIT:
            						case COLON:
            						case COMMA:
            						case SEMI:
            						case HEX_CHAR:
            							{
            								alt108=2;
            							}
            						    break;
            						case DOT:
            							{
            								alt108=1;
            							}
            						    break;

            						default:
            						    if (BACKTRACKING>0)
            						    {
            						        FAILEDFLAG = ANTLR3_TRUE;
            						        return retval;
            						    }
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 108;
            						    EXCEPTION->state        = 5;


            						    goto rulevia_addressEx;
            						}

            					}
            				    break;
            				case EOF:
            				case CRLF:
            				case SP:
            				case COLON:
            				case COMMA:
            				case SEMI:
            				case HEX_CHAR:
            					{
            						alt108=2;
            					}
            				    break;
            				case DOT:
            					{
            						alt108=1;
            					}
            				    break;

            				default:
            				    if (BACKTRACKING>0)
            				    {
            				        FAILEDFLAG = ANTLR3_TRUE;
            				        return retval;
            				    }
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 108;
            				    EXCEPTION->state        = 3;


            				    goto rulevia_addressEx;
            				}

            			}
            		    break;
            		case EOF:
            		case CRLF:
            		case SP:
            		case COLON:
            		case COMMA:
            		case SEMI:
            		case HEX_CHAR:
            			{
            				alt108=2;
            			}
            		    break;
            		case DOT:
            			{
            				alt108=1;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 108;
            		    EXCEPTION->state        = 1;


            		    goto rulevia_addressEx;
            		}

            	}
                break;
            case COLON:
            case HEX_CHAR:
            	{
            		alt108=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 108;
                EXCEPTION->state        = 0;


                goto rulevia_addressEx;
            }

            switch (alt108) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1276:14: ipv4address
        	    {
        	        FOLLOWPUSH(FOLLOW_ipv4address_in_via_address5695);
        	        ipv4address(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1276:28: ipv6address
        	    {
        	        FOLLOWPUSH(FOLLOW_ipv6address_in_via_address5699);
        	        ipv6address(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulevia_addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulevia_addressEx; /* Prevent compiler warnings */
    rulevia_addressEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end via_address */

/** 
 * $ANTLR start sent_protocol
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1282:1: sent_protocol : ( protocol_name slash protocol_version ) slash transport ;
 */
static belle_sip_messageParser_sent_protocol_return
sent_protocol(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_sent_protocol_return retval;

    belle_sip_messageParser_transport_return transport86;
    #undef	RETURN_TYPE_transport86
    #define	RETURN_TYPE_transport86 belle_sip_messageParser_transport_return

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1283:3: ( ( protocol_name slash protocol_version ) slash transport )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1283:7: ( protocol_name slash protocol_version ) slash transport
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1283:7: ( protocol_name slash protocol_version )
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1283:8: protocol_name slash protocol_version
            {
                FOLLOWPUSH(FOLLOW_protocol_name_in_sent_protocol5718);
                protocol_name(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesent_protocolEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                FOLLOWPUSH(FOLLOW_slash_in_sent_protocol5720);
                slash(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesent_protocolEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                FOLLOWPUSH(FOLLOW_protocol_version_in_sent_protocol5722);
                protocol_version(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulesent_protocolEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

            }

            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_protocol(	(SCOPE_TOP(header_via))->current,(const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
            }
            FOLLOWPUSH(FOLLOW_slash_in_sent_protocol5748);
            slash(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesent_protocolEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_transport_in_sent_protocol5750);
            transport86=transport(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesent_protocolEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_transport(	(SCOPE_TOP(header_via))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, transport86.start, transport86.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesent_protocolEx; /* Prevent compiler warnings */
    rulesent_protocolEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end sent_protocol */

/** 
 * $ANTLR start protocol_name
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1285:1: protocol_name : token ;
 */
static void
protocol_name(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1286:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1286:19: token
        {
            FOLLOWPUSH(FOLLOW_token_in_protocol_name5771);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprotocol_nameEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprotocol_nameEx; /* Prevent compiler warnings */
    ruleprotocol_nameEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end protocol_name */

/** 
 * $ANTLR start protocol_version
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1287:1: protocol_version : token ;
 */
static void
protocol_version(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1288:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1288:7: token
        {
            FOLLOWPUSH(FOLLOW_token_in_protocol_version5784);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprotocol_versionEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprotocol_versionEx; /* Prevent compiler warnings */
    ruleprotocol_versionEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end protocol_version */

/** 
 * $ANTLR start transport
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1289:1: transport : other_transport ;
 */
static belle_sip_messageParser_transport_return
transport(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_transport_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1290:3: ( other_transport )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1291:27: other_transport
        {
            FOLLOWPUSH(FOLLOW_other_transport_in_transport5805);
            other_transport(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletransportEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletransportEx; /* Prevent compiler warnings */
    ruletransportEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end transport */

/** 
 * $ANTLR start other_transport
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1292:1: other_transport : token ;
 */
static void
other_transport(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1293:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1293:5: token
        {
            FOLLOWPUSH(FOLLOW_token_in_other_transport5814);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleother_transportEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_transportEx; /* Prevent compiler warnings */
    ruleother_transportEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end other_transport */

/** 
 * $ANTLR start sent_by
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1295:1: sent_by : host ( COLON port )? ;
 */
static void
sent_by(pbelle_sip_messageParser ctx)
{   
    const char* host87;
    #undef	RETURN_TYPE_host87
    #define	RETURN_TYPE_host87 const char*

    belle_sip_messageParser_port_return port88;
    #undef	RETURN_TYPE_port88
    #define	RETURN_TYPE_port88 belle_sip_messageParser_port_return

    /* Initialize rule variables
     */


    host87 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1296:3: ( host ( COLON port )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1296:7: host ( COLON port )?
        {
            FOLLOWPUSH(FOLLOW_host_in_sent_by5837);
            host87=host(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesent_byEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_via_set_host(	(SCOPE_TOP(header_via))->current,host87);
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1297:6: ( COLON port )?
            {
                int alt109=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt109=1;
                    	}
                        break;
                }

                switch (alt109) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1297:8: COLON port
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_sent_by5848); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesent_byEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_port_in_sent_by5850);
            	        port88=port(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesent_byEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_header_via_set_port(	(SCOPE_TOP(header_via))->current,port88.ret);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesent_byEx; /* Prevent compiler warnings */
    rulesent_byEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sent_by */

/** 
 * $ANTLR start header_www_authenticate
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1316:1: header_www_authenticate returns [belle_sip_header_www_authenticate_t* ret] : {...}? token hcolon challenge[$header_www_authenticate::current] ;
 */
static belle_sip_header_www_authenticate_t*
header_www_authenticate(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_www_authenticate_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_www_authenticateTop = pbelle_sip_messageParser_header_www_authenticatePush(ctx);
     	(SCOPE_TOP(header_www_authenticate))->current= belle_sip_header_www_authenticate_new();ret= 	(SCOPE_TOP(header_www_authenticate))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1319:3: ({...}? token hcolon challenge[$header_www_authenticate::current] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1319:7: {...}? token hcolon challenge[$header_www_authenticate::current]
        {
            if ( !((IS_TOKEN(WWW-Authenticate))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(WWW-Authenticate)";
                    EXCEPTION->ruleName	 = (void *)"header_www_authenticate";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_www_authenticate5890);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_www_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_www_authenticate5894);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_www_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_challenge_in_header_www_authenticate5896);
            challenge(ctx, 	(SCOPE_TOP(header_www_authenticate))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_www_authenticateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_www_authenticatePop(ctx);

                return ret;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_www_authenticateEx; /* Prevent compiler warnings */
    ruleheader_www_authenticateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_www_authenticate))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_www_authenticatePop(ctx);

    return ret;
}
/* $ANTLR end header_www_authenticate */

/** 
 * $ANTLR start state_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1326:1: state_value : token ;
 */
static belle_sip_messageParser_state_value_return
state_value(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_state_value_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1326:12: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1326:14: token
        {
            FOLLOWPUSH(FOLLOW_token_in_state_value5909);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestate_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestate_valueEx; /* Prevent compiler warnings */
    rulestate_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end state_value */

/** 
 * $ANTLR start header_subscription_state
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1328:1: header_subscription_state returns [belle_sip_header_subscription_state_t* ret] : {...}? token hcolon state_value ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )* ;
 */
static belle_sip_header_subscription_state_t*
header_subscription_state(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_subscription_state_t* ret = NULL;

    belle_sip_messageParser_state_value_return state_value89;
    #undef	RETURN_TYPE_state_value89
    #define	RETURN_TYPE_state_value89 belle_sip_messageParser_state_value_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_subscription_stateTop = pbelle_sip_messageParser_header_subscription_statePush(ctx);
     	(SCOPE_TOP(header_subscription_state))->current= belle_sip_header_subscription_state_new();ret= 	(SCOPE_TOP(header_subscription_state))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1331:2: ({...}? token hcolon state_value ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1331:4: {...}? token hcolon state_value ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )*
        {
            if ( !((IS_TOKEN(Subscription-State))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_subscription_statePop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Subscription-State)";
                    EXCEPTION->ruleName	 = (void *)"header_subscription_state";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_subscription_state5937);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_subscription_stateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_subscription_statePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_subscription_state5943);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_subscription_stateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_subscription_statePop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_state_value_in_header_subscription_state5945);
            state_value89=state_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_subscription_stateEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_subscription_statePop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_subscription_state_set_state(	(SCOPE_TOP(header_subscription_state))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, state_value89.start, state_value89.stop))->chars);
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1333:2: ( semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)] )*

            for (;;)
            {
                int alt110=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case SEMI:
                	{
                		alt110=1;
                	}
                    break;

                }

                switch (alt110) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1333:3: semi generic_param[BELLE_SIP_PARAMETERS($header_subscription_state::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_header_subscription_state5952);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_subscription_stateEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_subscription_statePop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_generic_param_in_header_subscription_state5955);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_subscription_state))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_subscription_stateEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_subscription_statePop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop110;	/* break out of the loop */
            	    break;
                }
            }
            loop110: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_subscription_stateEx; /* Prevent compiler warnings */
    ruleheader_subscription_stateEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_subscription_state))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_subscription_statePop(ctx);

    return ret;
}
/* $ANTLR end header_subscription_state */

/** 
 * $ANTLR start header_event
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1341:1: header_event returns [belle_sip_header_event_t* ret] : {...}? token hcolon event_package ( semi generic_param[BELLE_SIP_PARAMETERS($header_event::current)] )* ;
 */
static belle_sip_header_event_t*
header_event(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_event_t* ret = NULL;

    belle_sip_messageParser_event_package_return event_package90;
    #undef	RETURN_TYPE_event_package90
    #define	RETURN_TYPE_event_package90 belle_sip_messageParser_event_package_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_eventTop = pbelle_sip_messageParser_header_eventPush(ctx);
     	(SCOPE_TOP(header_event))->current= belle_sip_header_event_new();ret= 	(SCOPE_TOP(header_event))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1344:2: ({...}? token hcolon event_package ( semi generic_param[BELLE_SIP_PARAMETERS($header_event::current)] )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1344:4: {...}? token hcolon event_package ( semi generic_param[BELLE_SIP_PARAMETERS($header_event::current)] )*
        {
            if ( !((IS_TOKEN(Event))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_eventPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Event)";
                    EXCEPTION->ruleName	 = (void *)"header_event";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_event5993);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_eventEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_eventPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_event5999);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_eventEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_eventPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_event_package_in_header_event6001);
            event_package90=event_package(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_eventEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_eventPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_event_set_package_name(	(SCOPE_TOP(header_event))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, event_package90.start, event_package90.stop))->chars);
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1346:2: ( semi generic_param[BELLE_SIP_PARAMETERS($header_event::current)] )*

            for (;;)
            {
                int alt111=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case SEMI:
                	{
                		alt111=1;
                	}
                    break;

                }

                switch (alt111) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1346:3: semi generic_param[BELLE_SIP_PARAMETERS($header_event::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_header_event6008);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_eventEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_eventPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_generic_param_in_header_event6011);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_event))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_eventEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_eventPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop111;	/* break out of the loop */
            	    break;
                }
            }
            loop111: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_eventEx; /* Prevent compiler warnings */
    ruleheader_eventEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_event))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_eventPop(ctx);

    return ret;
}
/* $ANTLR end header_event */

/** 
 * $ANTLR start event_package
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1353:1: event_package : token ;
 */
static belle_sip_messageParser_event_package_return
event_package(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_event_package_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1354:2: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1354:5: token
        {
            FOLLOWPUSH(FOLLOW_token_in_event_package6031);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleevent_packageEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleevent_packageEx; /* Prevent compiler warnings */
    ruleevent_packageEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end event_package */

/** 
 * $ANTLR start header_replaces
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1367:1: header_replaces returns [belle_sip_header_replaces_t* ret] : {...}? token hcolon call_id ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )* ;
 */
static belle_sip_header_replaces_t*
header_replaces(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_replaces_t* ret = NULL;

    belle_sip_messageParser_call_id_return call_id91;
    #undef	RETURN_TYPE_call_id91
    #define	RETURN_TYPE_call_id91 belle_sip_messageParser_call_id_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_replacesTop = pbelle_sip_messageParser_header_replacesPush(ctx);
     	(SCOPE_TOP(header_replaces))->current= belle_sip_header_replaces_new();ret= 	(SCOPE_TOP(header_replaces))->current; 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1370:2: ({...}? token hcolon call_id ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1370:4: {...}? token hcolon call_id ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )*
        {
            if ( !((IS_TOKEN(Replaces))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_replacesPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Replaces)";
                    EXCEPTION->ruleName	 = (void *)"header_replaces";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_replaces6064);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_replacesEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_replacesPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_replaces6070);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_replacesEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_replacesPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_call_id_in_header_replaces6072);
            call_id91=call_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_replacesEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_replacesPop(ctx);

                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_replaces_set_call_id(	(SCOPE_TOP(header_replaces))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, call_id91.start, call_id91.stop))->chars);
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1372:3: ( semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)] )*

            for (;;)
            {
                int alt112=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case SEMI:
                	{
                		alt112=1;
                	}
                    break;

                }

                switch (alt112) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1372:4: semi generic_param[BELLE_SIP_PARAMETERS($header_replaces::current)]
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_header_replaces6080);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_replacesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_replacesPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_generic_param_in_header_replaces6083);
            	        generic_param(ctx, BELLE_SIP_PARAMETERS(	(SCOPE_TOP(header_replaces))->current));

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_replacesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_replacesPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop112;	/* break out of the loop */
            	    break;
                }
            }
            loop112: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_replacesEx; /* Prevent compiler warnings */
    ruleheader_replacesEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(header_replaces))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_replacesPop(ctx);

    return ret;
}
/* $ANTLR end header_replaces */

/** 
 * $ANTLR start header_p_preferred_identity
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1383:1: header_p_preferred_identity returns [belle_sip_header_p_preferred_identity_t* ret] : {...}? token sp_tab_colon header_address_base[(belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new()] ;
 */
static belle_sip_header_p_preferred_identity_t*
header_p_preferred_identity(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_p_preferred_identity_t* ret = NULL;

    belle_sip_header_address_t* header_address_base92;
    #undef	RETURN_TYPE_header_address_base92
    #define	RETURN_TYPE_header_address_base92 belle_sip_header_address_t*

    /* Initialize rule variables
     */


     ret=NULL; 
    header_address_base92 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1385:3: ({...}? token sp_tab_colon header_address_base[(belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new()] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1385:6: {...}? token sp_tab_colon header_address_base[(belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new()]
        {
            if ( !((IS_TOKEN(P-Preferred-Identity))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(P-Preferred-Identity)";
                    EXCEPTION->ruleName	 = (void *)"header_p_preferred_identity";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_p_preferred_identity6122);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_p_preferred_identityEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_header_p_preferred_identity6128);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_p_preferred_identityEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            FOLLOWPUSH(FOLLOW_header_address_base_in_header_p_preferred_identity6130);
            header_address_base92=header_address_base(ctx, (belle_sip_header_address_t*)belle_sip_header_p_preferred_identity_new());

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_p_preferred_identityEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=(belle_sip_header_p_preferred_identity_t*)header_address_base92;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_p_preferred_identityEx; /* Prevent compiler warnings */
    ruleheader_p_preferred_identityEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end header_p_preferred_identity */

/** 
 * $ANTLR start header_privacy
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1388:1: header_privacy returns [belle_sip_header_privacy_t* ret] : {...}? token hcolon privacy_val ( semi privacy_val )* ;
 */
static belle_sip_header_privacy_t*
header_privacy(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_privacy_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_privacyTop = pbelle_sip_messageParser_header_privacyPush(ctx);
     	(SCOPE_TOP(header_privacy))->current= belle_sip_header_privacy_new();ret= 	(SCOPE_TOP(header_privacy))->current;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1391:3: ({...}? token hcolon privacy_val ( semi privacy_val )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1391:7: {...}? token hcolon privacy_val ( semi privacy_val )*
        {
            if ( !((IS_TOKEN(Privacy))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sip_messageParser_header_privacyPop(ctx);

                    return ret;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(Privacy)";
                    EXCEPTION->ruleName	 = (void *)"header_privacy";


            }
            FOLLOWPUSH(FOLLOW_token_in_header_privacy6167);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_privacyEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_privacyPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_hcolon_in_header_privacy6171);
            hcolon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_privacyEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_privacyPop(ctx);

                return ret;
            }
            FOLLOWPUSH(FOLLOW_privacy_val_in_header_privacy6173);
            privacy_val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_privacyEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_header_privacyPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1391:67: ( semi privacy_val )*

            for (;;)
            {
                int alt113=2;
                switch ( LA(1) ) 
                {
                case CRLF:
                case SP:
                case SEMI:
                	{
                		alt113=1;
                	}
                    break;

                }

                switch (alt113) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1391:68: semi privacy_val
            	    {
            	        FOLLOWPUSH(FOLLOW_semi_in_header_privacy6176);
            	        semi(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_privacyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_privacyPop(ctx);

            	            return ret;
            	        }
            	        FOLLOWPUSH(FOLLOW_privacy_val_in_header_privacy6178);
            	        privacy_val(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheader_privacyEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_header_privacyPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop113;	/* break out of the loop */
            	    break;
                }
            }
            loop113: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_privacyEx; /* Prevent compiler warnings */
    ruleheader_privacyEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_privacyPop(ctx);

    return ret;
}
/* $ANTLR end header_privacy */

/** 
 * $ANTLR start privacy_val
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1398:1: privacy_val : token ;
 */
static void
privacy_val(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_token_return token93;
    #undef	RETURN_TYPE_token93
    #define	RETURN_TYPE_token93 belle_sip_messageParser_token_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1398:12: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1398:14: token
        {
            FOLLOWPUSH(FOLLOW_token_in_privacy_val6193);
            token93=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprivacy_valEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_header_privacy_add_privacy(	(SCOPE_TOP(header_privacy))->current,(const char*)(STRSTREAM->toStringTT(STRSTREAM, token93.start, token93.stop))->chars);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprivacy_valEx; /* Prevent compiler warnings */
    ruleprivacy_valEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end privacy_val */

/** 
 * $ANTLR start header
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1400:1: header returns [belle_sip_header_t* ret=NULL] : header_extension_base[FALSE] ;
 */
static belle_sip_header_t*
header(pbelle_sip_messageParser ctx)
{   
    belle_sip_header_t* ret = NULL;

    belle_sip_header_t* header_extension_base94;
    #undef	RETURN_TYPE_header_extension_base94
    #define	RETURN_TYPE_header_extension_base94 belle_sip_header_t*

    /* Initialize rule variables
     */


    header_extension_base94 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1401:3: ( header_extension_base[FALSE] )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1401:5: header_extension_base[FALSE]
        {
            FOLLOWPUSH(FOLLOW_header_extension_base_in_header6210);
            header_extension_base94=header_extension_base(ctx, FALSE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheaderEx;
            }
            if (HASFAILED())
            {
                return ret;
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=header_extension_base94;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheaderEx; /* Prevent compiler warnings */
    ruleheaderEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ret;
}
/* $ANTLR end header */

/** 
 * $ANTLR start header_extension_base
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1404:1: header_extension_base[ANTLR3_BOOLEAN is_http] returns [belle_sip_header_t* ret] : ( header_name hcolon ( header_value[(const char*)$header_name.text->chars,$is_http ] )? ) ;
 */
static belle_sip_header_t*
header_extension_base(pbelle_sip_messageParser ctx, ANTLR3_BOOLEAN is_http)
{   
    belle_sip_header_t* ret = NULL;

    belle_sip_messageParser_header_name_return header_name95;
    #undef	RETURN_TYPE_header_name95
    #define	RETURN_TYPE_header_name95 belle_sip_messageParser_header_name_return

    belle_sip_messageParser_header_value_return header_value96;
    #undef	RETURN_TYPE_header_value96
    #define	RETURN_TYPE_header_value96 belle_sip_messageParser_header_value_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_header_extension_baseTop = pbelle_sip_messageParser_header_extension_basePush(ctx);
    	(SCOPE_TOP(header_extension_base))->as_value=0;ret=NULL;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1407:3: ( ( header_name hcolon ( header_value[(const char*)$header_name.text->chars,$is_http ] )? ) )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1407:8: ( header_name hcolon ( header_value[(const char*)$header_name.text->chars,$is_http ] )? )
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1407:8: ( header_name hcolon ( header_value[(const char*)$header_name.text->chars,$is_http ] )? )
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1407:9: header_name hcolon ( header_value[(const char*)$header_name.text->chars,$is_http ] )?
            {
                FOLLOWPUSH(FOLLOW_header_name_in_header_extension_base6246);
                header_name95=header_name(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleheader_extension_baseEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_header_extension_basePop(ctx);

                    return ret;
                }
                FOLLOWPUSH(FOLLOW_hcolon_in_header_extension_base6256);
                hcolon(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleheader_extension_baseEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_header_extension_basePop(ctx);

                    return ret;
                }

                // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1409:8: ( header_value[(const char*)$header_name.text->chars,$is_http ] )?
                {
                    int alt114=2;
                    switch ( LA(1) ) 
                    {
                        case SLASH:
                        case DIGIT:
                        case DOT:
                        case COLON:
                        case AT:
                        case AND:
                        case EQUAL:
                        case PLUS:
                        case DOLLARD:
                        case COMMA:
                        case SEMI:
                        case QMARK:
                        case DASH:
                        case DQUOTE:
                        case BSLASH:
                        case STAR:
                        case LPAREN:
                        case RPAREN:
                        case OCTET:
                        case LSBRAQUET:
                        case RSBRAQUET:
                        case PERCENT:
                        case BQUOTE:
                        case HEX_CHAR:
                        case COMMON_CHAR:
                        case LAQUOT:
                        case RAQUOT:
                        case LBRACE:
                        case RBRACE:
                        case USCORE:
                        case EMARK:
                        case TILDE:
                        case SQUOTE:
                        case HTAB:
                        case OR:
                        	{
                        		alt114=1;
                        	}
                            break;
                    }

                    switch (alt114) 
                    {
                	case 1:
                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1409:9: header_value[(const char*)$header_name.text->chars,$is_http ]
                	    {
                	        FOLLOWPUSH(FOLLOW_header_value_in_header_extension_base6271);
                	        header_value96=header_value(ctx, (const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name95.start, header_name95.stop))->chars, is_http);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleheader_extension_baseEx;
                	        }
                	        if (HASFAILED())
                	        {
                	            pbelle_sip_messageParser_header_extension_basePop(ctx);

                	            return ret;
                	        }
                	        if ( BACKTRACKING==0 ) 
                	        {
                	            	(SCOPE_TOP(header_extension_base))->as_value=1;ret=header_value96.ret;
                	        }

                	    }
                	    break;

                    }
                }

            }

            if ( BACKTRACKING==0 ) 
            {

                       	if (!ret && !	(SCOPE_TOP(header_extension_base))->as_value) { /*to handle value parsing error*/
                       	/*special case: header without value*/
                       		ret=belle_sip_header_create((const char*)(STRSTREAM->toStringTT(STRSTREAM, header_name95.start, header_name95.stop))->chars,NULL);
                       	}
                       
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_extension_baseEx; /* Prevent compiler warnings */
    ruleheader_extension_baseEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (ret) belle_sip_object_unref(ret);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_header_extension_basePop(ctx);

    return ret;
}
/* $ANTLR end header_extension_base */

/** 
 * $ANTLR start header_name
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1422:1: header_name : token ;
 */
static belle_sip_messageParser_header_name_return
header_name(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_header_name_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1423:3: ( token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1423:7: token
        {
            FOLLOWPUSH(FOLLOW_token_in_header_name6342);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheader_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_nameEx; /* Prevent compiler warnings */
    ruleheader_nameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end header_name */

/** 
 * $ANTLR start header_value
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1425:1: header_value[const char* name, ANTLR3_BOOLEAN is_http] returns [belle_sip_header_t* ret] options {greedy=false; } : (~ ( SP | CRLF ) ( ( CRLF SP ) | ~ CRLF )* ) ;
 */
static belle_sip_messageParser_header_value_return
header_value(pbelle_sip_messageParser ctx, const char* name, ANTLR3_BOOLEAN is_http)
{   
    belle_sip_messageParser_header_value_return retval;

    /* Initialize rule variables
     */


    retval.ret=NULL;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:3: ( (~ ( SP | CRLF ) ( ( CRLF SP ) | ~ CRLF )* ) )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:6: (~ ( SP | CRLF ) ( ( CRLF SP ) | ~ CRLF )* )
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:6: (~ ( SP | CRLF ) ( ( CRLF SP ) | ~ CRLF )* )
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:7: ~ ( SP | CRLF ) ( ( CRLF SP ) | ~ CRLF )*
            {
                if ( ((LA(1) >= SLASH) && (LA(1) <= OR)) )
                {
                    CONSUME();
                    PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

                }
                else 
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                    EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                    EXCEPTION->expectingSet = &FOLLOW_set_in_header_value6385;
                    RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_header_value6385);    goto ruleheader_valueEx;
                }


                // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:18: ( ( CRLF SP ) | ~ CRLF )*

                for (;;)
                {
                    int alt115=3;
                    switch ( LA(1) ) 
                    {
                    case CRLF:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		case SP:
                    			{
                    				alt115=1;
                    			}
                    		    break;

                    		}

                    	}
                        break;
                    case SP:
                    case SLASH:
                    case DIGIT:
                    case DOT:
                    case COLON:
                    case AT:
                    case AND:
                    case EQUAL:
                    case PLUS:
                    case DOLLARD:
                    case COMMA:
                    case SEMI:
                    case QMARK:
                    case DASH:
                    case DQUOTE:
                    case BSLASH:
                    case STAR:
                    case LPAREN:
                    case RPAREN:
                    case OCTET:
                    case LSBRAQUET:
                    case RSBRAQUET:
                    case PERCENT:
                    case BQUOTE:
                    case HEX_CHAR:
                    case COMMON_CHAR:
                    case LAQUOT:
                    case RAQUOT:
                    case LBRACE:
                    case RBRACE:
                    case USCORE:
                    case EMARK:
                    case TILDE:
                    case SQUOTE:
                    case HTAB:
                    case OR:
                    	{
                    		alt115=2;
                    	}
                        break;

                    }

                    switch (alt115) 
                    {
                	case 1:
                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:19: ( CRLF SP )
                	    {
                	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:19: ( CRLF SP )
                	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:20: CRLF SP
                	        {
                	             MATCHT(CRLF, &FOLLOW_CRLF_in_header_value6394); 
                	            if  (HASEXCEPTION())
                	            {
                	                goto ruleheader_valueEx;
                	            }
                	            if (HASFAILED())
                	            {
                	                return retval;
                	            }
                	             MATCHT(SP, &FOLLOW_SP_in_header_value6396); 
                	            if  (HASEXCEPTION())
                	            {
                	                goto ruleheader_valueEx;
                	            }
                	            if (HASFAILED())
                	            {
                	                return retval;
                	            }

                	        }


                	    }
                	    break;
                	case 2:
                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1428:31: ~ CRLF
                	    {
                	        if ( ((LA(1) >= SP) && (LA(1) <= OR)) )
                	        {
                	            CONSUME();
                	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

                	        }
                	        else 
                	        {
                	            if (BACKTRACKING>0)
                	            {
                	                FAILEDFLAG = ANTLR3_TRUE;
                	                return retval;
                	            }
                	            CONSTRUCTEX();
                	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                	            EXCEPTION->expectingSet = &FOLLOW_set_in_header_value6401;
                	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_header_value6401);    goto ruleheader_valueEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop115;	/* break out of the loop */
                	    break;
                    }
                }
                loop115: ; /* Jump out to here if this rule does not match */


            }

            if ( BACKTRACKING==0 ) 
            {

                                    if (is_http) {
                                    	retval.ret=belle_http_header_create(name,(const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                                    }else {
                                    	retval.ret=belle_sip_header_create(name,(const char*)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                                    }
                                   
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheader_valueEx; /* Prevent compiler warnings */
    ruleheader_valueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end header_value */

/** 
 * $ANTLR start message_body
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1436:1: message_body options {greedy=false; } : ( OCTET )+ ;
 */
static void
message_body(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1438:3: ( ( OCTET )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1438:7: ( OCTET )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1438:7: ( OCTET )+
            {
                int cnt116=0;

                for (;;)
                {
                    int alt116=2;
            	switch ( LA(1) ) 
            	{
            	case OCTET:
            		{
            			alt116=1;
            		}
            	    break;

            	}

            	switch (alt116) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1438:7: OCTET
            	        {
            	             MATCHT(OCTET, &FOLLOW_OCTET_in_message_body6438); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemessage_bodyEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt116 >= 1 )
            		{
            		    goto loop116;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulemessage_bodyEx;
            	}
            	cnt116++;
                }
                loop116: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemessage_bodyEx; /* Prevent compiler warnings */
    rulemessage_bodyEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end message_body */

/** 
 * $ANTLR start paramless_uri
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1440:1: paramless_uri returns [belle_sip_uri_t* ret=NULL] : sip_schema[$paramless_uri::current] ( ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] ) ( headers[$paramless_uri::current] )? ;
 */
static belle_sip_uri_t*
paramless_uri(pbelle_sip_messageParser ctx)
{   
    belle_sip_uri_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_paramless_uriTop = pbelle_sip_messageParser_paramless_uriPush(ctx);
     	(SCOPE_TOP(paramless_uri))->current= belle_sip_uri_new(); 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:4: ( sip_schema[$paramless_uri::current] ( ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] ) ( headers[$paramless_uri::current] )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:7: sip_schema[$paramless_uri::current] ( ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] ) ( headers[$paramless_uri::current] )?
        {
            FOLLOWPUSH(FOLLOW_sip_schema_in_paramless_uri6469);
            sip_schema(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleparamless_uriEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_paramless_uriPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:43: ( ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] ) | hostport[$paramless_uri::current] )
            {
                int alt117=2;
                alt117 = cdfa117.predict(ctx, RECOGNIZER, ISTREAM, &cdfa117);
                if  (HASEXCEPTION())
                {
                    goto ruleparamless_uriEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_paramless_uriPop(ctx);

                    return ret;
                }
                switch (alt117) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:45: ( userinfo[$paramless_uri::current] )=> ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:83: ( userinfo[$paramless_uri::current] hostport[$paramless_uri::current] )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:84: userinfo[$paramless_uri::current] hostport[$paramless_uri::current]
            	        {
            	            FOLLOWPUSH(FOLLOW_userinfo_in_paramless_uri6481);
            	            userinfo(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparamless_uriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_paramless_uriPop(ctx);

            	                return ret;
            	            }
            	            FOLLOWPUSH(FOLLOW_hostport_in_paramless_uri6484);
            	            hostport(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleparamless_uriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_paramless_uriPop(ctx);

            	                return ret;
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:155: hostport[$paramless_uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_hostport_in_paramless_uri6490);
            	        hostport(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_paramless_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1444:4: ( headers[$paramless_uri::current] )?
            {
                int alt118=2;
                switch ( LA(1) ) 
                {
                    case QMARK:
                    	{
                    		alt118=1;
                    	}
                        break;
                }

                switch (alt118) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1444:4: headers[$paramless_uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_headers_in_paramless_uri6497);
            	        headers(ctx, 	(SCOPE_TOP(paramless_uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamless_uriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_paramless_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(paramless_uri))->current;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamless_uriEx; /* Prevent compiler warnings */
    ruleparamless_uriEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(paramless_uri))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_paramless_uriPop(ctx);

    return ret;
}
/* $ANTLR end paramless_uri */

/** 
 * $ANTLR start uri
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1452:1: uri returns [belle_sip_uri_t* ret=NULL] : sip_schema[$uri::current] ( ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] ) ( uri_parameters[$uri::current] )? ( headers[$uri::current] )? ;
 */
static belle_sip_uri_t*
uri(pbelle_sip_messageParser ctx)
{   
    belle_sip_uri_t* ret = NULL;

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_uriTop = pbelle_sip_messageParser_uriPush(ctx);
     	(SCOPE_TOP(uri))->current= belle_sip_uri_new(); 
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:4: ( sip_schema[$uri::current] ( ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] ) ( uri_parameters[$uri::current] )? ( headers[$uri::current] )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:7: sip_schema[$uri::current] ( ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] ) ( uri_parameters[$uri::current] )? ( headers[$uri::current] )?
        {
            FOLLOWPUSH(FOLLOW_sip_schema_in_uri6538);
            sip_schema(ctx, 	(SCOPE_TOP(uri))->current);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuriEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_uriPop(ctx);

                return ret;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:33: ( ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] ) | hostport[$uri::current] )
            {
                int alt119=2;
                alt119 = cdfa119.predict(ctx, RECOGNIZER, ISTREAM, &cdfa119);
                if  (HASEXCEPTION())
                {
                    goto ruleuriEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_uriPop(ctx);

                    return ret;
                }
                switch (alt119) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:35: ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] )
            	    {
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:35: ( ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current] )
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:36: ( userinfo[NULL] )=> userinfo[$uri::current] hostport[$uri::current]
            	        {
            	            FOLLOWPUSH(FOLLOW_userinfo_in_uri6549);
            	            userinfo(ctx, 	(SCOPE_TOP(uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_uriPop(ctx);

            	                return ret;
            	            }
            	            FOLLOWPUSH(FOLLOW_hostport_in_uri6552);
            	            hostport(ctx, 	(SCOPE_TOP(uri))->current);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuriEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sip_messageParser_uriPop(ctx);

            	                return ret;
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:105: hostport[$uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_hostport_in_uri6558);
            	        hostport(ctx, 	(SCOPE_TOP(uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1456:4: ( uri_parameters[$uri::current] )?
            {
                int alt120=2;
                alt120 = cdfa120.predict(ctx, RECOGNIZER, ISTREAM, &cdfa120);
                if  (HASEXCEPTION())
                {
                    goto ruleuriEx;
                }
                if (HASFAILED())
                {
                    pbelle_sip_messageParser_uriPop(ctx);

                    return ret;
                }
                switch (alt120) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1456:4: uri_parameters[$uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_uri_parameters_in_uri6567);
            	        uri_parameters(ctx, 	(SCOPE_TOP(uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1457:4: ( headers[$uri::current] )?
            {
                int alt121=2;
                switch ( LA(1) ) 
                {
                    case QMARK:
                    	{
                    		alt121=1;
                    	}
                        break;
                }

                switch (alt121) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1457:4: headers[$uri::current]
            	    {
            	        FOLLOWPUSH(FOLLOW_headers_in_uri6575);
            	        headers(ctx, 	(SCOPE_TOP(uri))->current);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuriEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_uriPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret= 	(SCOPE_TOP(uri))->current;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuriEx; /* Prevent compiler warnings */
    ruleuriEx: ;

    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(	(SCOPE_TOP(uri))->current);
	       ret=NULL;

	}


    }
    else
    {
    }
    pbelle_sip_messageParser_uriPop(ctx);

    return ret;
}
/* $ANTLR end uri */

/** 
 * $ANTLR start sip_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1465:1: sip_token : {...}? token ;
 */
static void
sip_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1465:10: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1465:13: {...}? token
        {
            if ( !((IS_TOKEN(sip))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(sip)";
                    EXCEPTION->ruleName	 = (void *)"sip_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_sip_token6596);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesip_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_tokenEx; /* Prevent compiler warnings */
    rulesip_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sip_token */

/** 
 * $ANTLR start sips_token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1466:1: sips_token : {...}? token ;
 */
static void
sips_token(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1466:11: ({...}? token )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1466:14: {...}? token
        {
            if ( !((IS_TOKEN(sips))) ) 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(sips)";
                    EXCEPTION->ruleName	 = (void *)"sips_token";


            }
            FOLLOWPUSH(FOLLOW_token_in_sips_token6605);
            token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesips_tokenEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesips_tokenEx; /* Prevent compiler warnings */
    rulesips_tokenEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sips_token */

/** 
 * $ANTLR start sip_schema
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1468:1: sip_schema[belle_sip_uri_t* uri] : ( sips_token | sip_token ) COLON ;
 */
static void
sip_schema(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1468:35: ( ( sips_token | sip_token ) COLON )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1468:37: ( sips_token | sip_token ) COLON
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1468:37: ( sips_token | sip_token )
            {
                int alt122=2;
                switch ( LA(1) ) 
                {
                case HEX_CHAR:
                case COMMON_CHAR:
                	{

                		{
                		    int LA122_1 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt122=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt122=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 122;
                		        EXCEPTION->state        = 1;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case DIGIT:
                	{

                		{
                		    int LA122_2 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt122=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt122=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 122;
                		        EXCEPTION->state        = 2;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case DOT:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{

                		{
                		    int LA122_3 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt122=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt122=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 122;
                		        EXCEPTION->state        = 3;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case PERCENT:
                	{

                		{
                		    int LA122_4 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt122=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt122=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 122;
                		        EXCEPTION->state        = 4;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case PLUS:
                	{

                		{
                		    int LA122_5 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt122=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt122=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 122;
                		        EXCEPTION->state        = 5;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;
                case BQUOTE:
                	{

                		{
                		    int LA122_6 = LA(2);
                		    if ( ((IS_TOKEN(sips))) ) 
                		    {
                		        alt122=1;
                		    }
                		    else if ( ((IS_TOKEN(sip))) ) 
                		    {
                		        alt122=2;
                		    }
                		    else 
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            return ;
                		        }
                		    
                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 122;
                		        EXCEPTION->state        = 6;


                		        goto rulesip_schemaEx;
                		    }
                		}
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 122;
                    EXCEPTION->state        = 0;


                    goto rulesip_schemaEx;
                }

                switch (alt122) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1468:38: sips_token
            	    {
            	        FOLLOWPUSH(FOLLOW_sips_token_in_sip_schema6616);
            	        sips_token(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesip_schemaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_uri_set_secure(uri,1);
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1469:15: sip_token
            	    {
            	        FOLLOWPUSH(FOLLOW_sip_token_in_sip_schema6634);
            	        sip_token(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesip_schemaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(COLON, &FOLLOW_COLON_in_sip_schema6637); 
            if  (HASEXCEPTION())
            {
                goto rulesip_schemaEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesip_schemaEx; /* Prevent compiler warnings */
    rulesip_schemaEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sip_schema */

/** 
 * $ANTLR start userinfo
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1470:1: userinfo[belle_sip_uri_t* uri] : user ( COLON password )? AT ;
 */
static void
userinfo(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_userinfoTop = pbelle_sip_messageParser_userinfoPush(ctx);
    	(SCOPE_TOP(userinfo))->current=uri;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1473:8: ( user ( COLON password )? AT )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1473:11: user ( COLON password )? AT
        {
            FOLLOWPUSH(FOLLOW_user_in_userinfo6664);
            user(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuserinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_userinfoPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1473:16: ( COLON password )?
            {
                int alt123=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt123=1;
                    	}
                        break;
                }

                switch (alt123) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1473:18: COLON password
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_userinfo6668); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserinfoEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_userinfoPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_password_in_userinfo6670);
            	        password(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuserinfoEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_userinfoPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(AT, &FOLLOW_AT_in_userinfo6676); 
            if  (HASEXCEPTION())
            {
                goto ruleuserinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_userinfoPop(ctx);

                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuserinfoEx; /* Prevent compiler warnings */
    ruleuserinfoEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_userinfoPop(ctx);

    return ;
}
/* $ANTLR end userinfo */

/** 
 * $ANTLR start user
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1474:1: user : ( unreserved | escaped | user_unreserved )+ ;
 */
static belle_sip_messageParser_user_return
user(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_user_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1474:17: ( ( unreserved | escaped | user_unreserved )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1474:21: ( unreserved | escaped | user_unreserved )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1474:21: ( unreserved | escaped | user_unreserved )+
            {
                int cnt124=0;

                for (;;)
                {
                    int alt124=4;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case DOT:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt124=1;
            		}
            	    break;
            	case PERCENT:
            		{
            			alt124=2;
            		}
            	    break;
            	case SLASH:
            	case AND:
            	case EQUAL:
            	case PLUS:
            	case DOLLARD:
            	case COMMA:
            	case SEMI:
            	case QMARK:
            		{
            			alt124=3;
            		}
            	    break;

            	}

            	switch (alt124) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1474:23: unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_unreserved_in_user6698);
            	            unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuserEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1474:37: escaped
            	        {
            	            FOLLOWPUSH(FOLLOW_escaped_in_user6703);
            	            escaped(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuserEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1474:47: user_unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_user_unreserved_in_user6707);
            	            user_unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleuserEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt124 >= 1 )
            		{
            		    goto loop124;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleuserEx;
            	}
            	cnt124++;
                }
                loop124: ;	/* Jump to here if this rule does not match */
            }
            if ( BACKTRACKING==0 ) 
            {

                                                                                  char* unescaped_username;
                                                                                  unescaped_username=belle_sip_to_unescaped_string((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                                                                                  belle_sip_uri_set_user(	(SCOPE_TOP(userinfo))->current,unescaped_username);
                                                                                  belle_sip_free(unescaped_username);
                                                                                  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuserEx; /* Prevent compiler warnings */
    ruleuserEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end user */

/** 
 * $ANTLR start password
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:1: password : ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )* ;
 */
static belle_sip_messageParser_password_return
password(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_password_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:17: ( ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:21: ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )*
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:21: ( unreserved | escaped | AND | EQUAL | PLUS | DOLLARD | COMMA )*

            for (;;)
            {
                int alt125=8;
                switch ( LA(1) ) 
                {
                case DIGIT:
                case DOT:
                case DASH:
                case STAR:
                case LPAREN:
                case RPAREN:
                case HEX_CHAR:
                case COMMON_CHAR:
                case USCORE:
                case EMARK:
                case TILDE:
                case SQUOTE:
                	{
                		alt125=1;
                	}
                    break;
                case PERCENT:
                	{
                		alt125=2;
                	}
                    break;
                case AND:
                	{
                		alt125=3;
                	}
                    break;
                case EQUAL:
                	{
                		alt125=4;
                	}
                    break;
                case PLUS:
                	{
                		alt125=5;
                	}
                    break;
                case DOLLARD:
                	{
                		alt125=6;
                	}
                    break;
                case COMMA:
                	{
                		alt125=7;
                	}
                    break;

                }

                switch (alt125) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:23: unreserved
            	    {
            	        FOLLOWPUSH(FOLLOW_unreserved_in_password6730);
            	        unreserved(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:36: escaped
            	    {
            	        FOLLOWPUSH(FOLLOW_escaped_in_password6734);
            	        escaped(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 3:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:45: AND
            	    {
            	         MATCHT(AND, &FOLLOW_AND_in_password6737); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 4:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:51: EQUAL
            	    {
            	         MATCHT(EQUAL, &FOLLOW_EQUAL_in_password6741); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 5:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:59: PLUS
            	    {
            	         MATCHT(PLUS, &FOLLOW_PLUS_in_password6745); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 6:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:66: DOLLARD
            	    {
            	         MATCHT(DOLLARD, &FOLLOW_DOLLARD_in_password6749); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;
            	case 7:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1480:76: COMMA
            	    {
            	         MATCHT(COMMA, &FOLLOW_COMMA_in_password6753); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepasswordEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop125;	/* break out of the loop */
            	    break;
                }
            }
            loop125: ; /* Jump out to here if this rule does not match */

            if ( BACKTRACKING==0 ) 
            {

                                                                                              char* unescaped_userpasswd;
                                                                                              unescaped_userpasswd=belle_sip_to_unescaped_string((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars);
                                                                                              belle_sip_uri_set_user_password(	(SCOPE_TOP(userinfo))->current,unescaped_userpasswd);
                                                                                              belle_sip_free(unescaped_userpasswd);
                                                                                              
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepasswordEx; /* Prevent compiler warnings */
    rulepasswordEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end password */

/** 
 * $ANTLR start hostport
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1486:1: hostport[belle_sip_uri_t* uri] : host ( COLON port )? ;
 */
static void
hostport(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    belle_sip_messageParser_port_return port97;
    #undef	RETURN_TYPE_port97
    #define	RETURN_TYPE_port97 belle_sip_messageParser_port_return

    const char* host98;
    #undef	RETURN_TYPE_host98
    #define	RETURN_TYPE_host98 const char*

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_hostportTop = pbelle_sip_messageParser_hostportPush(ctx);
    	(SCOPE_TOP(hostport))->current=uri;
    host98 = NULL;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1489:9: ( host ( COLON port )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1489:13: host ( COLON port )?
        {
            FOLLOWPUSH(FOLLOW_host_in_hostport6786);
            host98=host(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehostportEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_hostportPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1489:18: ( COLON port )?
            {
                int alt126=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt126=1;
                    	}
                        break;
                }

                switch (alt126) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1489:20: COLON port
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_hostport6790); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostportEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostportPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_port_in_hostport6792);
            	        port97=port(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostportEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostportPop(ctx);

            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            belle_sip_uri_set_port(	(SCOPE_TOP(hostport))->current,port97.ret);
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                belle_sip_uri_set_host(	(SCOPE_TOP(hostport))->current,host98);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehostportEx; /* Prevent compiler warnings */
    rulehostportEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_hostportPop(ctx);

    return ;
}
/* $ANTLR end hostport */

/** 
 * $ANTLR start uri_parameters
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1491:1: uri_parameters[belle_sip_uri_t* uri] : ( ( semi uri_parameter ) | ( ( lws )? SEMI ) )+ ;
 */
static void
uri_parameters(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_uri_parametersTop = pbelle_sip_messageParser_uri_parametersPush(ctx);
    	(SCOPE_TOP(uri_parameters))->current=uri;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:3: ( ( ( semi uri_parameter ) | ( ( lws )? SEMI ) )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:7: ( ( semi uri_parameter ) | ( ( lws )? SEMI ) )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:7: ( ( semi uri_parameter ) | ( ( lws )? SEMI ) )+
            {
                int cnt128=0;

                for (;;)
                {
                    int alt128=3;
            	alt128 = cdfa128.predict(ctx, RECOGNIZER, ISTREAM, &cdfa128);
            	if  (HASEXCEPTION())
            	{
            	    goto ruleuri_parametersEx;
            	}
            	if (HASFAILED())
            	{
            	    pbelle_sip_messageParser_uri_parametersPop(ctx);

            	    return ;
            	}
            	switch (alt128) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:9: ( semi uri_parameter )
            	        {
            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:9: ( semi uri_parameter )
            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:10: semi uri_parameter
            	            {
            	                FOLLOWPUSH(FOLLOW_semi_in_uri_parameters6828);
            	                semi(ctx);

            	                FOLLOWPOP();
            	                if  (HASEXCEPTION())
            	                {
            	                    goto ruleuri_parametersEx;
            	                }
            	                if (HASFAILED())
            	                {
            	                    pbelle_sip_messageParser_uri_parametersPop(ctx);

            	                    return ;
            	                }
            	                FOLLOWPUSH(FOLLOW_uri_parameter_in_uri_parameters6830);
            	                uri_parameter(ctx);

            	                FOLLOWPOP();
            	                if  (HASEXCEPTION())
            	                {
            	                    goto ruleuri_parametersEx;
            	                }
            	                if (HASFAILED())
            	                {
            	                    pbelle_sip_messageParser_uri_parametersPop(ctx);

            	                    return ;
            	                }

            	            }


            	        }
            	        break;
            	    case 2:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:30: ( ( lws )? SEMI )
            	        {
            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:30: ( ( lws )? SEMI )
            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:31: ( lws )? SEMI
            	            {

            	                // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:31: ( lws )?
            	                {
            	                    int alt127=2;
            	                    switch ( LA(1) ) 
            	                    {
            	                        case CRLF:
            	                        case SP:
            	                        	{
            	                        		alt127=1;
            	                        	}
            	                            break;
            	                    }

            	                    switch (alt127) 
            	                    {
            	                	case 1:
            	                	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1494:31: lws
            	                	    {
            	                	        FOLLOWPUSH(FOLLOW_lws_in_uri_parameters6834);
            	                	        lws(ctx);

            	                	        FOLLOWPOP();
            	                	        if  (HASEXCEPTION())
            	                	        {
            	                	            goto ruleuri_parametersEx;
            	                	        }
            	                	        if (HASFAILED())
            	                	        {
            	                	            pbelle_sip_messageParser_uri_parametersPop(ctx);

            	                	            return ;
            	                	        }

            	                	    }
            	                	    break;

            	                    }
            	                }
            	                 MATCHT(SEMI, &FOLLOW_SEMI_in_uri_parameters6837); 
            	                if  (HASEXCEPTION())
            	                {
            	                    goto ruleuri_parametersEx;
            	                }
            	                if (HASFAILED())
            	                {
            	                    pbelle_sip_messageParser_uri_parametersPop(ctx);

            	                    return ;
            	                }

            	            }


            	        }
            	        break;

            	    default:
            	    
            		if ( cnt128 >= 1 )
            		{
            		    goto loop128;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    pbelle_sip_messageParser_uri_parametersPop(ctx);

            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleuri_parametersEx;
            	}
            	cnt128++;
                }
                loop128: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuri_parametersEx; /* Prevent compiler warnings */
    ruleuri_parametersEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_uri_parametersPop(ctx);

    return ;
}
/* $ANTLR end uri_parameters */

/** 
 * $ANTLR start uri_parameter
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1495:1: uri_parameter : other_param ;
 */
static void
uri_parameter(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1496:3: ( other_param )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1496:8: other_param
        {
            FOLLOWPUSH(FOLLOW_other_param_in_uri_parameter6857);
            other_param(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuri_parameterEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuri_parameterEx; /* Prevent compiler warnings */
    ruleuri_parameterEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end uri_parameter */

/** 
 * $ANTLR start other_param
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1497:1: other_param : ( pname | ( pname EQUAL pvalue ) );
 */
static void
other_param(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_pname_return pname99;
    #undef	RETURN_TYPE_pname99
    #define	RETURN_TYPE_pname99 belle_sip_messageParser_pname_return

    belle_sip_messageParser_pname_return pname100;
    #undef	RETURN_TYPE_pname100
    #define	RETURN_TYPE_pname100 belle_sip_messageParser_pname_return

    belle_sip_messageParser_pvalue_return pvalue101;
    #undef	RETURN_TYPE_pvalue101
    #define	RETURN_TYPE_pvalue101 belle_sip_messageParser_pvalue_return

    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1498:1: ( pname | ( pname EQUAL pvalue ) )
            
            ANTLR3_UINT32 alt129;

            alt129=2;

            alt129 = cdfa129.predict(ctx, RECOGNIZER, ISTREAM, &cdfa129);
            if  (HASEXCEPTION())
            {
                goto ruleother_paramEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt129) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1498:4: pname
        	    {
        	        FOLLOWPUSH(FOLLOW_pname_in_other_param6873);
        	        pname99=pname(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleother_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	        if ( BACKTRACKING==0 ) 
        	        {

        	              char* unescaped_parameters = belle_sip_to_unescaped_string((const char *) (STRSTREAM->toStringTT(STRSTREAM, pname99.start, pname99.stop))->chars);
        	              belle_sip_parameters_set_parameter(BELLE_SIP_PARAMETERS(	(SCOPE_TOP(uri_parameters))->current)
        	                                                  ,unescaped_parameters
        	                                                  ,NULL);
        	              belle_sip_free(unescaped_parameters);

        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1506:4: ( pname EQUAL pvalue )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1506:4: ( pname EQUAL pvalue )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1506:5: pname EQUAL pvalue
        	        {
        	            FOLLOWPUSH(FOLLOW_pname_in_other_param6885);
        	            pname100=pname(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleother_paramEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(EQUAL, &FOLLOW_EQUAL_in_other_param6887); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleother_paramEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            FOLLOWPUSH(FOLLOW_pvalue_in_other_param6889);
        	            pvalue101=pvalue(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleother_paramEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }

        	        if ( BACKTRACKING==0 ) 
        	        {

        	               char* unescaped_pname = belle_sip_to_unescaped_string((const char *) (STRSTREAM->toStringTT(STRSTREAM, pname100.start, pname100.stop))->chars);
        	               char* unescaped_pvalue = belle_sip_to_unescaped_string((const char *) (STRSTREAM->toStringTT(STRSTREAM, pvalue101.start, pvalue101.stop))->chars);
        	               belle_sip_parameters_set_parameter(BELLE_SIP_PARAMETERS(	(SCOPE_TOP(uri_parameters))->current)
        	                                                  ,unescaped_pname
        	                                                  ,unescaped_pvalue);
        	              belle_sip_free(unescaped_pname);
        	              belle_sip_free(unescaped_pvalue);
        	              
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleother_paramEx; /* Prevent compiler warnings */
    ruleother_paramEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end other_param */

/** 
 * $ANTLR start pname
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1517:1: pname : ( paramchar )+ ;
 */
static belle_sip_messageParser_pname_return
pname(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_pname_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1518:3: ( ( paramchar )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1518:7: ( paramchar )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1518:7: ( paramchar )+
            {
                int cnt130=0;

                for (;;)
                {
                    int alt130=2;
            	switch ( LA(1) ) 
            	{
            	case SLASH:
            	case DIGIT:
            	case DOT:
            	case COLON:
            	case AND:
            	case PLUS:
            	case DOLLARD:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case LSBRAQUET:
            	case RSBRAQUET:
            	case PERCENT:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt130=1;
            		}
            	    break;

            	}

            	switch (alt130) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1518:7: paramchar
            	        {
            	            FOLLOWPUSH(FOLLOW_paramchar_in_pname6922);
            	            paramchar(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt130 >= 1 )
            		{
            		    goto loop130;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepnameEx;
            	}
            	cnt130++;
                }
                loop130: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepnameEx; /* Prevent compiler warnings */
    rulepnameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end pname */

/** 
 * $ANTLR start pvalue
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1519:1: pvalue : ( paramchar )+ ;
 */
static belle_sip_messageParser_pvalue_return
pvalue(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_pvalue_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1520:3: ( ( paramchar )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1520:7: ( paramchar )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1520:7: ( paramchar )+
            {
                int cnt131=0;

                for (;;)
                {
                    int alt131=2;
            	switch ( LA(1) ) 
            	{
            	case SLASH:
            	case DIGIT:
            	case DOT:
            	case COLON:
            	case AND:
            	case PLUS:
            	case DOLLARD:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case LSBRAQUET:
            	case RSBRAQUET:
            	case PERCENT:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt131=1;
            		}
            	    break;

            	}

            	switch (alt131) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1520:7: paramchar
            	        {
            	            FOLLOWPUSH(FOLLOW_paramchar_in_pvalue6946);
            	            paramchar(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt131 >= 1 )
            		{
            		    goto loop131;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepvalueEx;
            	}
            	cnt131++;
                }
                loop131: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulepvalueEx; /* Prevent compiler warnings */
    rulepvalueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end pvalue */

/** 
 * $ANTLR start paramchar
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1521:1: paramchar : ( ( param_unreserved )=> param_unreserved | unreserved | escaped );
 */
static void
paramchar(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1522:3: ( ( param_unreserved )=> param_unreserved | unreserved | escaped )
            
            ANTLR3_UINT32 alt132;

            alt132=3;


            {
                int LA132_0 = LA(1);
                if ( (LA132_0 == DOT) ) 
                {

                    {
                        int LA132_1 = LA(2);
                        if ( (synpred11_belle_sip_message(ctx)) ) 
                        {
                            alt132=1;
                        }
                        else if ( (ANTLR3_TRUE) ) 
                        {
                            alt132=2;
                        }
                        else 
                        {
                            if (BACKTRACKING>0)
                            {
                                FAILEDFLAG = ANTLR3_TRUE;
                                return ;
                            }
                        
                            CONSTRUCTEX();
                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                            EXCEPTION->message      = (void *)"";
                            EXCEPTION->decisionNum  = 132;
                            EXCEPTION->state        = 1;


                            goto ruleparamcharEx;
                        }
                    }
                }
                else if ( (LA132_0 == DIGIT || LA132_0 == DASH || ((LA132_0 >= STAR) && (LA132_0 <= RPAREN)) || ((LA132_0 >= HEX_CHAR) && (LA132_0 <= COMMON_CHAR)) || ((LA132_0 >= USCORE) && (LA132_0 <= SQUOTE))) ) 
                {
                    alt132=2;
                }
                else if ( (LA132_0 == SLASH || LA132_0 == COLON || LA132_0 == AND || ((LA132_0 >= PLUS) && (LA132_0 <= DOLLARD)) || ((LA132_0 >= LSBRAQUET) && (LA132_0 <= RSBRAQUET))) && (synpred11_belle_sip_message(ctx))) 
                {
                    alt132=1;
                }
                else if ( (LA132_0 == PERCENT) ) 
                {
                    alt132=3;
                }
                else 
                {
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return ;
                    }
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 132;
                    EXCEPTION->state        = 0;


                    goto ruleparamcharEx;
                }
            }
            switch (alt132) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1522:7: ( param_unreserved )=> param_unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_param_unreserved_in_paramchar6971);
        	        param_unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1522:46: unreserved
        	    {
        	        FOLLOWPUSH(FOLLOW_unreserved_in_paramchar6975);
        	        unreserved(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1522:59: escaped
        	    {
        	        FOLLOWPUSH(FOLLOW_escaped_in_paramchar6979);
        	        escaped(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparamcharEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleparamcharEx; /* Prevent compiler warnings */
    ruleparamcharEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end paramchar */

/** 
 * $ANTLR start param_unreserved
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1523:1: param_unreserved : ( LSBRAQUET | RSBRAQUET | SLASH | COLON | AND | PLUS | DOLLARD | DOT );
 */
static void
param_unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1524:3: ( LSBRAQUET | RSBRAQUET | SLASH | COLON | AND | PLUS | DOLLARD | DOT )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
        {
            if ( LA(1) == SLASH || ((LA(1) >= DOT) && (LA(1) <= COLON)) || LA(1) == AND || ((LA(1) >= PLUS) && (LA(1) <= DOLLARD)) || ((LA(1) >= LSBRAQUET) && (LA(1) <= RSBRAQUET)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_param_unreserved0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_param_unreserved0);    goto ruleparam_unreservedEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleparam_unreservedEx; /* Prevent compiler warnings */
    ruleparam_unreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end param_unreserved */

/** 
 * $ANTLR start headers
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1526:1: headers[belle_sip_uri_t* uri] : QMARK uri_header ( AND uri_header )* ;
 */
static void
headers(pbelle_sip_messageParser ctx, belle_sip_uri_t* uri)
{   
    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_headersTop = pbelle_sip_messageParser_headersPush(ctx);
    	(SCOPE_TOP(headers))->current=uri; 	(SCOPE_TOP(headers))->is_hvalue=0;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1529:17: ( QMARK uri_header ( AND uri_header )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1529:20: QMARK uri_header ( AND uri_header )*
        {
             MATCHT(QMARK, &FOLLOW_QMARK_in_headers7057); 
            if  (HASEXCEPTION())
            {
                goto ruleheadersEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_headersPop(ctx);

                return ;
            }
            FOLLOWPUSH(FOLLOW_uri_header_in_headers7059);
            uri_header(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheadersEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_headersPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1529:37: ( AND uri_header )*

            for (;;)
            {
                int alt133=2;
                switch ( LA(1) ) 
                {
                case AND:
                	{
                		alt133=1;
                	}
                    break;

                }

                switch (alt133) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1529:39: AND uri_header
            	    {
            	         MATCHT(AND, &FOLLOW_AND_in_headers7063); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheadersEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_headersPop(ctx);

            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_uri_header_in_headers7065);
            	        uri_header(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheadersEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_headersPop(ctx);

            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop133;	/* break out of the loop */
            	    break;
                }
            }
            loop133: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheadersEx; /* Prevent compiler warnings */
    ruleheadersEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_headersPop(ctx);

    return ;
}
/* $ANTLR end headers */

/** 
 * $ANTLR start uri_header
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1530:1: uri_header : hname EQUAL ( hvalue )? ;
 */
static void
uri_header(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hname_return hname102;
    #undef	RETURN_TYPE_hname102
    #define	RETURN_TYPE_hname102 belle_sip_messageParser_hname_return

    belle_sip_messageParser_hvalue_return hvalue103;
    #undef	RETURN_TYPE_hvalue103
    #define	RETURN_TYPE_hvalue103 belle_sip_messageParser_hvalue_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_uri_headerTop = pbelle_sip_messageParser_uri_headerPush(ctx);
    	(SCOPE_TOP(uri_header))->is_hvalue=0;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1533:15: ( hname EQUAL ( hvalue )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1533:17: hname EQUAL ( hvalue )?
        {
            FOLLOWPUSH(FOLLOW_hname_in_uri_header7110);
            hname102=hname(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuri_headerEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_uri_headerPop(ctx);

                return ;
            }
             MATCHT(EQUAL, &FOLLOW_EQUAL_in_uri_header7112); 
            if  (HASEXCEPTION())
            {
                goto ruleuri_headerEx;
            }
            if (HASFAILED())
            {
                pbelle_sip_messageParser_uri_headerPop(ctx);

                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1533:29: ( hvalue )?
            {
                int alt134=2;
                switch ( LA(1) ) 
                {
                    case SLASH:
                    case DIGIT:
                    case DOT:
                    case COLON:
                    case PLUS:
                    case DOLLARD:
                    case QMARK:
                    case DASH:
                    case STAR:
                    case LPAREN:
                    case RPAREN:
                    case LSBRAQUET:
                    case RSBRAQUET:
                    case PERCENT:
                    case HEX_CHAR:
                    case COMMON_CHAR:
                    case USCORE:
                    case EMARK:
                    case TILDE:
                    case SQUOTE:
                    	{
                    		alt134=1;
                    	}
                        break;
                }

                switch (alt134) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1533:30: hvalue
            	    {
            	        FOLLOWPUSH(FOLLOW_hvalue_in_uri_header7115);
            	        hvalue103=hvalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleuri_headerEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_uri_headerPop(ctx);

            	            return ;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            	(SCOPE_TOP(uri_header))->is_hvalue= 1;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {

                                      char* unescaped_hname = belle_sip_to_unescaped_string((const char *)(STRSTREAM->toStringTT(STRSTREAM, hname102.start, hname102.stop))->chars);
                                      char* unescaped_hvalue = (	(SCOPE_TOP(uri_header))->is_hvalue)?belle_sip_to_unescaped_string((const char *)(STRSTREAM->toStringTT(STRSTREAM, hvalue103.start, hvalue103.stop))->chars):NULL;
                                      belle_sip_uri_set_header(	(SCOPE_TOP(headers))->current,unescaped_hname,unescaped_hvalue);
                                      belle_sip_free(unescaped_hname);
                                      if (unescaped_hvalue) belle_sip_free(unescaped_hvalue);
                                  
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuri_headerEx; /* Prevent compiler warnings */
    ruleuri_headerEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_uri_headerPop(ctx);

    return ;
}
/* $ANTLR end uri_header */

/** 
 * $ANTLR start hname
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1540:1: hname : ( hnv_unreserved | unreserved | escaped )+ ;
 */
static belle_sip_messageParser_hname_return
hname(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hname_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1540:17: ( ( hnv_unreserved | unreserved | escaped )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1540:20: ( hnv_unreserved | unreserved | escaped )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1540:20: ( hnv_unreserved | unreserved | escaped )+
            {
                int cnt135=0;

                for (;;)
                {
                    int alt135=4;
            	switch ( LA(1) ) 
            	{
            	case SLASH:
            	case COLON:
            	case PLUS:
            	case DOLLARD:
            	case QMARK:
            	case LSBRAQUET:
            	case RSBRAQUET:
            		{
            			alt135=1;
            		}
            	    break;
            	case DIGIT:
            	case DOT:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt135=2;
            		}
            	    break;
            	case PERCENT:
            		{
            			alt135=3;
            		}
            	    break;

            	}

            	switch (alt135) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1540:22: hnv_unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_hnv_unreserved_in_hname7140);
            	            hnv_unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1540:39: unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_unreserved_in_hname7144);
            	            unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1540:52: escaped
            	        {
            	            FOLLOWPUSH(FOLLOW_escaped_in_hname7148);
            	            escaped(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehnameEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt135 >= 1 )
            		{
            		    goto loop135;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehnameEx;
            	}
            	cnt135++;
                }
                loop135: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehnameEx; /* Prevent compiler warnings */
    rulehnameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end hname */

/** 
 * $ANTLR start hvalue
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1541:1: hvalue : ( hnv_unreserved | unreserved | escaped )+ ;
 */
static belle_sip_messageParser_hvalue_return
hvalue(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hvalue_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1541:17: ( ( hnv_unreserved | unreserved | escaped )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1541:20: ( hnv_unreserved | unreserved | escaped )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1541:20: ( hnv_unreserved | unreserved | escaped )+
            {
                int cnt136=0;

                for (;;)
                {
                    int alt136=4;
            	switch ( LA(1) ) 
            	{
            	case SLASH:
            	case COLON:
            	case PLUS:
            	case DOLLARD:
            	case QMARK:
            	case LSBRAQUET:
            	case RSBRAQUET:
            		{
            			alt136=1;
            		}
            	    break;
            	case DIGIT:
            	case DOT:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt136=2;
            		}
            	    break;
            	case PERCENT:
            		{
            			alt136=3;
            		}
            	    break;

            	}

            	switch (alt136) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1541:22: hnv_unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_hnv_unreserved_in_hvalue7170);
            	            hnv_unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1541:39: unreserved
            	        {
            	            FOLLOWPUSH(FOLLOW_unreserved_in_hvalue7174);
            	            unreserved(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1541:52: escaped
            	        {
            	            FOLLOWPUSH(FOLLOW_escaped_in_hvalue7178);
            	            escaped(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehvalueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt136 >= 1 )
            		{
            		    goto loop136;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehvalueEx;
            	}
            	cnt136++;
                }
                loop136: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehvalueEx; /* Prevent compiler warnings */
    rulehvalueEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end hvalue */

/** 
 * $ANTLR start hnv_unreserved
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1544:1: hnv_unreserved : ( LSBRAQUET | RSBRAQUET | SLASH | QMARK | COLON | PLUS | DOLLARD );
 */
static void
hnv_unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1544:17: ( LSBRAQUET | RSBRAQUET | SLASH | QMARK | COLON | PLUS | DOLLARD )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
        {
            if ( LA(1) == SLASH || LA(1) == COLON || ((LA(1) >= PLUS) && (LA(1) <= DOLLARD)) || LA(1) == QMARK || ((LA(1) >= LSBRAQUET) && (LA(1) <= RSBRAQUET)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_hnv_unreserved0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_hnv_unreserved0);    goto rulehnv_unreservedEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehnv_unreservedEx; /* Prevent compiler warnings */
    rulehnv_unreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end hnv_unreserved */

/** 
 * $ANTLR start user_unreserved
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1552:1: user_unreserved : ( AND | EQUAL | PLUS | DOLLARD | COMMA | SEMI | QMARK | SLASH );
 */
static void
user_unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1552:17: ( AND | EQUAL | PLUS | DOLLARD | COMMA | SEMI | QMARK | SLASH )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
        {
            if ( LA(1) == SLASH || ((LA(1) >= AND) && (LA(1) <= QMARK)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_user_unreserved0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_user_unreserved0);    goto ruleuser_unreservedEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleuser_unreservedEx; /* Prevent compiler warnings */
    ruleuser_unreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end user_unreserved */

/** 
 * $ANTLR start host
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1553:1: host returns [const char* ret] : ( hostname | ipv4address | ipv6reference ) ;
 */
static const char*
host(pbelle_sip_messageParser ctx)
{   
    const char* ret = NULL;

    belle_sip_messageParser_hostname_return hostname104;
    #undef	RETURN_TYPE_hostname104
    #define	RETURN_TYPE_hostname104 belle_sip_messageParser_hostname_return

    belle_sip_messageParser_ipv4address_return ipv4address105;
    #undef	RETURN_TYPE_ipv4address105
    #define	RETURN_TYPE_ipv4address105 belle_sip_messageParser_ipv4address_return

    /* Initialize rule variables
     */

    ctx->pbelle_sip_messageParser_hostTop = pbelle_sip_messageParser_hostPush(ctx);
    	(SCOPE_TOP(host))->current=ret=NULL;
    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1556:13: ( ( hostname | ipv4address | ipv6reference ) )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1556:17: ( hostname | ipv4address | ipv6reference )
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1556:17: ( hostname | ipv4address | ipv6reference )
            {
                int alt137=3;
                switch ( LA(1) ) 
                {
                case HEX_CHAR:
                case COMMON_CHAR:
                	{
                		alt137=1;
                	}
                    break;
                case DIGIT:
                	{
                		switch ( LA(2) ) 
                		{
                		case DIGIT:
                			{
                				switch ( LA(3) ) 
                				{
                				case DIGIT:
                					{
                						switch ( LA(4) ) 
                						{
                						case DOT:
                							{
                								switch ( LA(5) ) 
                								{
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;
                														case DOT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case DOT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																													{
                																														switch ( LA(16) ) 
                																														{
                																														case DIGIT:
                																														case DOT:
                																														case DASH:
                																														case HEX_CHAR:
                																														case COMMON_CHAR:
                																															{
                																																alt137=1;
                																															}
                																														    break;
                																														case EOF:
                																														case CRLF:
                																														case SP:
                																														case SLASH:
                																														case COLON:
                																														case COMMA:
                																														case SEMI:
                																														case QMARK:
                																														case DQUOTE:
                																														case RAQUOT:
                																															{
                																																alt137=2;
                																															}
                																														    break;

                																														default:
                																														    if (BACKTRACKING>0)
                																														    {
                																														        FAILEDFLAG = ANTLR3_TRUE;
                																														        pbelle_sip_messageParser_hostPop(ctx);

                																														        return ret;
                																														    }
                																														    CONSTRUCTEX();
                																														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																														    EXCEPTION->message      = (void *)"";
                																														    EXCEPTION->decisionNum  = 137;
                																														    EXCEPTION->state        = 18;


                																														    goto rulehostEx;
                																														}

                																													}
                																												    break;
                																												case DOT:
                																												case DASH:
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																													{
                																														alt137=1;
                																													}
                																												    break;
                																												case EOF:
                																												case CRLF:
                																												case SP:
                																												case SLASH:
                																												case COLON:
                																												case COMMA:
                																												case SEMI:
                																												case QMARK:
                																												case DQUOTE:
                																												case RAQUOT:
                																													{
                																														alt137=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 137;
                																												    EXCEPTION->state        = 16;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 15;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 13;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 14;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DOT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																												case DOT:
                																												case DASH:
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																													{
                																														alt137=1;
                																													}
                																												    break;
                																												case EOF:
                																												case CRLF:
                																												case SP:
                																												case SLASH:
                																												case COLON:
                																												case COMMA:
                																												case SEMI:
                																												case QMARK:
                																												case DQUOTE:
                																												case RAQUOT:
                																													{
                																														alt137=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 137;
                																												    EXCEPTION->state        = 18;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 16;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 15;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 13;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 12;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case DOT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 11;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 9;


                																    goto rulehostEx;
                																}

                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 10;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case DASH:
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;
                												case DOT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case DOT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																												case DOT:
                																												case DASH:
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																													{
                																														alt137=1;
                																													}
                																												    break;
                																												case EOF:
                																												case CRLF:
                																												case SP:
                																												case SLASH:
                																												case COLON:
                																												case COMMA:
                																												case SEMI:
                																												case QMARK:
                																												case DQUOTE:
                																												case RAQUOT:
                																													{
                																														alt137=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 137;
                																												    EXCEPTION->state        = 18;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 16;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 15;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 13;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 14;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DOT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 12;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;
                																case DOT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 11;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 9;


                														    goto rulehostEx;
                														}

                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 8;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case DASH:
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt137=1;
                											}
                										    break;
                										case DOT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case DOT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 14;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DOT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 12;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;
                														case DOT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 11;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 9;


                												    goto rulehostEx;
                												}

                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 137;
                										    EXCEPTION->state        = 7;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case HEX_CHAR:
                								case COMMON_CHAR:
                									{
                										alt137=1;
                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 137;
                								    EXCEPTION->state        = 5;


                								    goto rulehostEx;
                								}

                							}
                						    break;
                						case DIGIT:
                						case DASH:
                						case HEX_CHAR:
                						case COMMON_CHAR:
                							{
                								alt137=1;
                							}
                						    break;

                						default:
                						    if (BACKTRACKING>0)
                						    {
                						        FAILEDFLAG = ANTLR3_TRUE;
                						        pbelle_sip_messageParser_hostPop(ctx);

                						        return ret;
                						    }
                						    CONSTRUCTEX();
                						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                						    EXCEPTION->message      = (void *)"";
                						    EXCEPTION->decisionNum  = 137;
                						    EXCEPTION->state        = 6;


                						    goto rulehostEx;
                						}

                					}
                				    break;
                				case DASH:
                				case HEX_CHAR:
                				case COMMON_CHAR:
                					{
                						alt137=1;
                					}
                				    break;
                				case DOT:
                					{
                						switch ( LA(4) ) 
                						{
                						case DIGIT:
                							{
                								switch ( LA(5) ) 
                								{
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                												case DASH:
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;
                												case DOT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case DOT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																											{
                																												switch ( LA(15) ) 
                																												{
                																												case DIGIT:
                																												case DOT:
                																												case DASH:
                																												case HEX_CHAR:
                																												case COMMON_CHAR:
                																													{
                																														alt137=1;
                																													}
                																												    break;
                																												case EOF:
                																												case CRLF:
                																												case SP:
                																												case SLASH:
                																												case COLON:
                																												case COMMA:
                																												case SEMI:
                																												case QMARK:
                																												case DQUOTE:
                																												case RAQUOT:
                																													{
                																														alt137=2;
                																													}
                																												    break;

                																												default:
                																												    if (BACKTRACKING>0)
                																												    {
                																												        FAILEDFLAG = ANTLR3_TRUE;
                																												        pbelle_sip_messageParser_hostPop(ctx);

                																												        return ret;
                																												    }
                																												    CONSTRUCTEX();
                																												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																												    EXCEPTION->message      = (void *)"";
                																												    EXCEPTION->decisionNum  = 137;
                																												    EXCEPTION->state        = 18;


                																												    goto rulehostEx;
                																												}

                																											}
                																										    break;
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 16;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 15;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 13;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 14;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DOT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 12;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;
                																case DOT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 11;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 9;


                														    goto rulehostEx;
                														}

                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 10;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case DASH:
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt137=1;
                											}
                										    break;
                										case DOT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case DOT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 14;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DOT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 12;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;
                														case DOT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 11;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 9;


                												    goto rulehostEx;
                												}

                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 137;
                										    EXCEPTION->state        = 8;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case DASH:
                								case HEX_CHAR:
                								case COMMON_CHAR:
                									{
                										alt137=1;
                									}
                								    break;
                								case DOT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;
                																case DOT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 14;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DOT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 12;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case DASH:
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;
                												case DOT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 18;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 16;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case EOF:
                																case CRLF:
                																case SP:
                																case SLASH:
                																case COLON:
                																case COMMA:
                																case SEMI:
                																case QMARK:
                																case DQUOTE:
                																case RAQUOT:
                																	{
                																		alt137=2;
                																	}
                																    break;
                																case DOT:
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 15;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 13;


                														    goto rulehostEx;
                														}

                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 11;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt137=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 137;
                										    EXCEPTION->state        = 9;


                										    goto rulehostEx;
                										}

                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 137;
                								    EXCEPTION->state        = 7;


                								    goto rulehostEx;
                								}

                							}
                						    break;
                						case HEX_CHAR:
                						case COMMON_CHAR:
                							{
                								alt137=1;
                							}
                						    break;

                						default:
                						    if (BACKTRACKING>0)
                						    {
                						        FAILEDFLAG = ANTLR3_TRUE;
                						        pbelle_sip_messageParser_hostPop(ctx);

                						        return ret;
                						    }
                						    CONSTRUCTEX();
                						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                						    EXCEPTION->message      = (void *)"";
                						    EXCEPTION->decisionNum  = 137;
                						    EXCEPTION->state        = 5;


                						    goto rulehostEx;
                						}

                					}
                				    break;

                				default:
                				    if (BACKTRACKING>0)
                				    {
                				        FAILEDFLAG = ANTLR3_TRUE;
                				        pbelle_sip_messageParser_hostPop(ctx);

                				        return ret;
                				    }
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 137;
                				    EXCEPTION->state        = 4;


                				    goto rulehostEx;
                				}

                			}
                		    break;
                		case DASH:
                		case HEX_CHAR:
                		case COMMON_CHAR:
                			{
                				alt137=1;
                			}
                		    break;
                		case DOT:
                			{
                				switch ( LA(3) ) 
                				{
                				case DIGIT:
                					{
                						switch ( LA(4) ) 
                						{
                						case DIGIT:
                							{
                								switch ( LA(5) ) 
                								{
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                										case DASH:
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt137=1;
                											}
                										    break;
                										case DOT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case DOT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																									{
                																										switch ( LA(14) ) 
                																										{
                																										case DIGIT:
                																										case DOT:
                																										case DASH:
                																										case HEX_CHAR:
                																										case COMMON_CHAR:
                																											{
                																												alt137=1;
                																											}
                																										    break;
                																										case EOF:
                																										case CRLF:
                																										case SP:
                																										case SLASH:
                																										case COLON:
                																										case COMMA:
                																										case SEMI:
                																										case QMARK:
                																										case DQUOTE:
                																										case RAQUOT:
                																											{
                																												alt137=2;
                																											}
                																										    break;

                																										default:
                																										    if (BACKTRACKING>0)
                																										    {
                																										        FAILEDFLAG = ANTLR3_TRUE;
                																										        pbelle_sip_messageParser_hostPop(ctx);

                																										        return ret;
                																										    }
                																										    CONSTRUCTEX();
                																										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																										    EXCEPTION->message      = (void *)"";
                																										    EXCEPTION->decisionNum  = 137;
                																										    EXCEPTION->state        = 18;


                																										    goto rulehostEx;
                																										}

                																									}
                																								    break;
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 16;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 15;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 13;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 14;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DOT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 12;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;
                														case DOT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 11;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 9;


                												    goto rulehostEx;
                												}

                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 137;
                										    EXCEPTION->state        = 10;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case DASH:
                								case HEX_CHAR:
                								case COMMON_CHAR:
                									{
                										alt137=1;
                									}
                								    break;
                								case DOT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;
                																case DOT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																							{
                																								switch ( LA(13) ) 
                																								{
                																								case DIGIT:
                																								case DOT:
                																								case DASH:
                																								case HEX_CHAR:
                																								case COMMON_CHAR:
                																									{
                																										alt137=1;
                																									}
                																								    break;
                																								case EOF:
                																								case CRLF:
                																								case SP:
                																								case SLASH:
                																								case COLON:
                																								case COMMA:
                																								case SEMI:
                																								case QMARK:
                																								case DQUOTE:
                																								case RAQUOT:
                																									{
                																										alt137=2;
                																									}
                																								    break;

                																								default:
                																								    if (BACKTRACKING>0)
                																								    {
                																								        FAILEDFLAG = ANTLR3_TRUE;
                																								        pbelle_sip_messageParser_hostPop(ctx);

                																								        return ret;
                																								    }
                																								    CONSTRUCTEX();
                																								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																								    EXCEPTION->message      = (void *)"";
                																								    EXCEPTION->decisionNum  = 137;
                																								    EXCEPTION->state        = 18;


                																								    goto rulehostEx;
                																								}

                																							}
                																						    break;
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 16;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 15;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 13;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 14;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DOT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 12;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case DASH:
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;
                												case DOT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 18;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 16;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case EOF:
                																case CRLF:
                																case SP:
                																case SLASH:
                																case COLON:
                																case COMMA:
                																case SEMI:
                																case QMARK:
                																case DQUOTE:
                																case RAQUOT:
                																	{
                																		alt137=2;
                																	}
                																    break;
                																case DOT:
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 15;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 13;


                														    goto rulehostEx;
                														}

                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 11;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt137=1;
                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 137;
                										    EXCEPTION->state        = 9;


                										    goto rulehostEx;
                										}

                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 137;
                								    EXCEPTION->state        = 8;


                								    goto rulehostEx;
                								}

                							}
                						    break;
                						case DASH:
                						case HEX_CHAR:
                						case COMMON_CHAR:
                							{
                								alt137=1;
                							}
                						    break;
                						case DOT:
                							{
                								switch ( LA(5) ) 
                								{
                								case DIGIT:
                									{
                										switch ( LA(6) ) 
                										{
                										case DIGIT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;
                														case DOT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																					{
                																						switch ( LA(12) ) 
                																						{
                																						case DIGIT:
                																						case DOT:
                																						case DASH:
                																						case HEX_CHAR:
                																						case COMMON_CHAR:
                																							{
                																								alt137=1;
                																							}
                																						    break;
                																						case EOF:
                																						case CRLF:
                																						case SP:
                																						case SLASH:
                																						case COLON:
                																						case COMMA:
                																						case SEMI:
                																						case QMARK:
                																						case DQUOTE:
                																						case RAQUOT:
                																							{
                																								alt137=2;
                																							}
                																						    break;

                																						default:
                																						    if (BACKTRACKING>0)
                																						    {
                																						        FAILEDFLAG = ANTLR3_TRUE;
                																						        pbelle_sip_messageParser_hostPop(ctx);

                																						        return ret;
                																						    }
                																						    CONSTRUCTEX();
                																						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																						    EXCEPTION->message      = (void *)"";
                																						    EXCEPTION->decisionNum  = 137;
                																						    EXCEPTION->state        = 18;


                																						    goto rulehostEx;
                																						}

                																					}
                																				    break;
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 16;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 15;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 13;


                																    goto rulehostEx;
                																}

                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 14;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case DOT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																			{
                																				switch ( LA(11) ) 
                																				{
                																				case DIGIT:
                																				case DOT:
                																				case DASH:
                																				case HEX_CHAR:
                																				case COMMON_CHAR:
                																					{
                																						alt137=1;
                																					}
                																				    break;
                																				case EOF:
                																				case CRLF:
                																				case SP:
                																				case SLASH:
                																				case COLON:
                																				case COMMA:
                																				case SEMI:
                																				case QMARK:
                																				case DQUOTE:
                																				case RAQUOT:
                																					{
                																						alt137=2;
                																					}
                																				    break;

                																				default:
                																				    if (BACKTRACKING>0)
                																				    {
                																				        FAILEDFLAG = ANTLR3_TRUE;
                																				        pbelle_sip_messageParser_hostPop(ctx);

                																				        return ret;
                																				    }
                																				    CONSTRUCTEX();
                																				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																				    EXCEPTION->message      = (void *)"";
                																				    EXCEPTION->decisionNum  = 137;
                																				    EXCEPTION->state        = 18;


                																				    goto rulehostEx;
                																				}

                																			}
                																		    break;
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 16;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case EOF:
                																case CRLF:
                																case SP:
                																case SLASH:
                																case COLON:
                																case COMMA:
                																case SEMI:
                																case QMARK:
                																case DQUOTE:
                																case RAQUOT:
                																	{
                																		alt137=2;
                																	}
                																    break;
                																case DOT:
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 15;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 13;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case DASH:
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 12;


                												    goto rulehostEx;
                												}

                											}
                										    break;
                										case DASH:
                										case HEX_CHAR:
                										case COMMON_CHAR:
                											{
                												alt137=1;
                											}
                										    break;
                										case DOT:
                											{
                												switch ( LA(7) ) 
                												{
                												case DIGIT:
                													{
                														switch ( LA(8) ) 
                														{
                														case DIGIT:
                															{
                																switch ( LA(9) ) 
                																{
                																case DIGIT:
                																	{
                																		switch ( LA(10) ) 
                																		{
                																		case DIGIT:
                																		case DOT:
                																		case DASH:
                																		case HEX_CHAR:
                																		case COMMON_CHAR:
                																			{
                																				alt137=1;
                																			}
                																		    break;
                																		case EOF:
                																		case CRLF:
                																		case SP:
                																		case SLASH:
                																		case COLON:
                																		case COMMA:
                																		case SEMI:
                																		case QMARK:
                																		case DQUOTE:
                																		case RAQUOT:
                																			{
                																				alt137=2;
                																			}
                																		    break;

                																		default:
                																		    if (BACKTRACKING>0)
                																		    {
                																		        FAILEDFLAG = ANTLR3_TRUE;
                																		        pbelle_sip_messageParser_hostPop(ctx);

                																		        return ret;
                																		    }
                																		    CONSTRUCTEX();
                																		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																		    EXCEPTION->message      = (void *)"";
                																		    EXCEPTION->decisionNum  = 137;
                																		    EXCEPTION->state        = 18;


                																		    goto rulehostEx;
                																		}

                																	}
                																    break;
                																case DOT:
                																case DASH:
                																case HEX_CHAR:
                																case COMMON_CHAR:
                																	{
                																		alt137=1;
                																	}
                																    break;
                																case EOF:
                																case CRLF:
                																case SP:
                																case SLASH:
                																case COLON:
                																case COMMA:
                																case SEMI:
                																case QMARK:
                																case DQUOTE:
                																case RAQUOT:
                																	{
                																		alt137=2;
                																	}
                																    break;

                																default:
                																    if (BACKTRACKING>0)
                																    {
                																        FAILEDFLAG = ANTLR3_TRUE;
                																        pbelle_sip_messageParser_hostPop(ctx);

                																        return ret;
                																    }
                																    CONSTRUCTEX();
                																    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                																    EXCEPTION->message      = (void *)"";
                																    EXCEPTION->decisionNum  = 137;
                																    EXCEPTION->state        = 16;


                																    goto rulehostEx;
                																}

                															}
                														    break;
                														case EOF:
                														case CRLF:
                														case SP:
                														case SLASH:
                														case COLON:
                														case COMMA:
                														case SEMI:
                														case QMARK:
                														case DQUOTE:
                														case RAQUOT:
                															{
                																alt137=2;
                															}
                														    break;
                														case DOT:
                														case DASH:
                														case HEX_CHAR:
                														case COMMON_CHAR:
                															{
                																alt137=1;
                															}
                														    break;

                														default:
                														    if (BACKTRACKING>0)
                														    {
                														        FAILEDFLAG = ANTLR3_TRUE;
                														        pbelle_sip_messageParser_hostPop(ctx);

                														        return ret;
                														    }
                														    CONSTRUCTEX();
                														    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                														    EXCEPTION->message      = (void *)"";
                														    EXCEPTION->decisionNum  = 137;
                														    EXCEPTION->state        = 15;


                														    goto rulehostEx;
                														}

                													}
                												    break;
                												case HEX_CHAR:
                												case COMMON_CHAR:
                													{
                														alt137=1;
                													}
                												    break;

                												default:
                												    if (BACKTRACKING>0)
                												    {
                												        FAILEDFLAG = ANTLR3_TRUE;
                												        pbelle_sip_messageParser_hostPop(ctx);

                												        return ret;
                												    }
                												    CONSTRUCTEX();
                												    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                												    EXCEPTION->message      = (void *)"";
                												    EXCEPTION->decisionNum  = 137;
                												    EXCEPTION->state        = 13;


                												    goto rulehostEx;
                												}

                											}
                										    break;

                										default:
                										    if (BACKTRACKING>0)
                										    {
                										        FAILEDFLAG = ANTLR3_TRUE;
                										        pbelle_sip_messageParser_hostPop(ctx);

                										        return ret;
                										    }
                										    CONSTRUCTEX();
                										    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                										    EXCEPTION->message      = (void *)"";
                										    EXCEPTION->decisionNum  = 137;
                										    EXCEPTION->state        = 11;


                										    goto rulehostEx;
                										}

                									}
                								    break;
                								case HEX_CHAR:
                								case COMMON_CHAR:
                									{
                										alt137=1;
                									}
                								    break;

                								default:
                								    if (BACKTRACKING>0)
                								    {
                								        FAILEDFLAG = ANTLR3_TRUE;
                								        pbelle_sip_messageParser_hostPop(ctx);

                								        return ret;
                								    }
                								    CONSTRUCTEX();
                								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                								    EXCEPTION->message      = (void *)"";
                								    EXCEPTION->decisionNum  = 137;
                								    EXCEPTION->state        = 9;


                								    goto rulehostEx;
                								}

                							}
                						    break;

                						default:
                						    if (BACKTRACKING>0)
                						    {
                						        FAILEDFLAG = ANTLR3_TRUE;
                						        pbelle_sip_messageParser_hostPop(ctx);

                						        return ret;
                						    }
                						    CONSTRUCTEX();
                						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                						    EXCEPTION->message      = (void *)"";
                						    EXCEPTION->decisionNum  = 137;
                						    EXCEPTION->state        = 7;


                						    goto rulehostEx;
                						}

                					}
                				    break;
                				case HEX_CHAR:
                				case COMMON_CHAR:
                					{
                						alt137=1;
                					}
                				    break;

                				default:
                				    if (BACKTRACKING>0)
                				    {
                				        FAILEDFLAG = ANTLR3_TRUE;
                				        pbelle_sip_messageParser_hostPop(ctx);

                				        return ret;
                				    }
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 137;
                				    EXCEPTION->state        = 5;


                				    goto rulehostEx;
                				}

                			}
                		    break;

                		default:
                		    if (BACKTRACKING>0)
                		    {
                		        FAILEDFLAG = ANTLR3_TRUE;
                		        pbelle_sip_messageParser_hostPop(ctx);

                		        return ret;
                		    }
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 137;
                		    EXCEPTION->state        = 2;


                		    goto rulehostEx;
                		}

                	}
                    break;
                case LSBRAQUET:
                	{
                		alt137=3;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        pbelle_sip_messageParser_hostPop(ctx);

                        return ret;
                    }
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 137;
                    EXCEPTION->state        = 0;


                    goto rulehostEx;
                }

                switch (alt137) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1556:18: hostname
            	    {
            	        FOLLOWPUSH(FOLLOW_hostname_in_host7300);
            	        hostname104=hostname(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            	(SCOPE_TOP(host))->current=(const char *)(STRSTREAM->toStringTT(STRSTREAM, hostname104.start, hostname104.stop))->chars;
            	        }

            	    }
            	    break;
            	case 2:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1557:23: ipv4address
            	    {
            	        FOLLOWPUSH(FOLLOW_ipv4address_in_host7326);
            	        ipv4address105=ipv4address(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostPop(ctx);

            	            return ret;
            	        }
            	        if ( BACKTRACKING==0 ) 
            	        {
            	            	(SCOPE_TOP(host))->current=(const char *)(STRSTREAM->toStringTT(STRSTREAM, ipv4address105.start, ipv4address105.stop))->chars;
            	        }

            	    }
            	    break;
            	case 3:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1558:23: ipv6reference
            	    {
            	        FOLLOWPUSH(FOLLOW_ipv6reference_in_host7352);
            	        ipv6reference(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sip_messageParser_hostPop(ctx);

            	            return ret;
            	        }

            	    }
            	    break;

                }
            }
            if ( BACKTRACKING==0 ) 
            {
                ret=	(SCOPE_TOP(host))->current;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehostEx; /* Prevent compiler warnings */
    rulehostEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }

    pbelle_sip_messageParser_hostPop(ctx);

    return ret;
}
/* $ANTLR end host */

/** 
 * $ANTLR start hostname
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:1: hostname : ( domainlabel DOT )* ( toplabel )=> toplabel ( DOT )? ;
 */
static belle_sip_messageParser_hostname_return
hostname(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_hostname_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:17: ( ( domainlabel DOT )* ( toplabel )=> toplabel ( DOT )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:21: ( domainlabel DOT )* ( toplabel )=> toplabel ( DOT )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:21: ( domainlabel DOT )*

            for (;;)
            {
                int alt138=2;
                alt138 = cdfa138.predict(ctx, RECOGNIZER, ISTREAM, &cdfa138);
                if  (HASEXCEPTION())
                {
                    goto rulehostnameEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }
                switch (alt138) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:23: domainlabel DOT
            	    {
            	        FOLLOWPUSH(FOLLOW_domainlabel_in_hostname7374);
            	        domainlabel(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostnameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	         MATCHT(DOT, &FOLLOW_DOT_in_hostname7376); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostnameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop138;	/* break out of the loop */
            	    break;
                }
            }
            loop138: ; /* Jump out to here if this rule does not match */

            FOLLOWPUSH(FOLLOW_toplabel_in_hostname7385);
            toplabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehostnameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:63: ( DOT )?
            {
                int alt139=2;
                switch ( LA(1) ) 
                {
                    case DOT:
                    	{
                    		alt139=1;
                    	}
                        break;
                }

                switch (alt139) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:63: DOT
            	    {
            	         MATCHT(DOT, &FOLLOW_DOT_in_hostname7387); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehostnameEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehostnameEx; /* Prevent compiler warnings */
    rulehostnameEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end hostname */

/** 
 * $ANTLR start domainlabel
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:1: domainlabel : ( alphanum | ( alphanum ( alphanum | DASH )* alphanum ) );
 */
static void
domainlabel(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:17: ( alphanum | ( alphanum ( alphanum | DASH )* alphanum ) )
            
            ANTLR3_UINT32 alt141;

            alt141=2;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		switch ( LA(2) ) 
            		{
            		case DOT:
            			{
            				alt141=1;
            			}
            		    break;
            		case DIGIT:
            		case DASH:
            		case HEX_CHAR:
            		case COMMON_CHAR:
            			{
            				alt141=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 141;
            		    EXCEPTION->state        = 1;


            		    goto ruledomainlabelEx;
            		}

            	}
                break;
            case DIGIT:
            	{
            		switch ( LA(2) ) 
            		{
            		case DOT:
            			{
            				alt141=1;
            			}
            		    break;
            		case DIGIT:
            		case DASH:
            		case HEX_CHAR:
            		case COMMON_CHAR:
            			{
            				alt141=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 141;
            		    EXCEPTION->state        = 2;


            		    goto ruledomainlabelEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 141;
                EXCEPTION->state        = 0;


                goto ruledomainlabelEx;
            }

            switch (alt141) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:21: alphanum
        	    {
        	        FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel7405);
        	        alphanum(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledomainlabelEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:32: ( alphanum ( alphanum | DASH )* alphanum )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:32: ( alphanum ( alphanum | DASH )* alphanum )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:33: alphanum ( alphanum | DASH )* alphanum
        	        {
        	            FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel7410);
        	            alphanum(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledomainlabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:42: ( alphanum | DASH )*

        	            for (;;)
        	            {
        	                int alt140=3;
        	                switch ( LA(1) ) 
        	                {
        	                case HEX_CHAR:
        	                case COMMON_CHAR:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case DIGIT:
        	                		case DASH:
        	                		case HEX_CHAR:
        	                		case COMMON_CHAR:
        	                			{
        	                				alt140=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DIGIT:
        	                	{
        	                		switch ( LA(2) ) 
        	                		{
        	                		case DIGIT:
        	                		case DASH:
        	                		case HEX_CHAR:
        	                		case COMMON_CHAR:
        	                			{
        	                				alt140=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DASH:
        	                	{
        	                		alt140=2;
        	                	}
        	                    break;

        	                }

        	                switch (alt140) 
        	                {
        	            	case 1:
        	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:44: alphanum
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel7414);
        	            	        alphanum(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruledomainlabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1561:55: DASH
        	            	    {
        	            	         MATCHT(DASH, &FOLLOW_DASH_in_domainlabel7418); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruledomainlabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop140;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop140: ; /* Jump out to here if this rule does not match */

        	            FOLLOWPUSH(FOLLOW_alphanum_in_domainlabel7423);
        	            alphanum(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledomainlabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledomainlabelEx; /* Prevent compiler warnings */
    ruledomainlabelEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end domainlabel */

/** 
 * $ANTLR start toplabel
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:1: toplabel : ( alpha | ( alpha ( ( DASH )? alphanum )+ ) );
 */
static void
toplabel(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:17: ( alpha | ( alpha ( ( DASH )? alphanum )+ ) )
            
            ANTLR3_UINT32 alt144;

            alt144=2;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		switch ( LA(2) ) 
            		{
            		case EOF:
            		case CRLF:
            		case SP:
            		case SLASH:
            		case DOT:
            		case COLON:
            		case COMMA:
            		case SEMI:
            		case QMARK:
            		case DQUOTE:
            		case RAQUOT:
            			{
            				alt144=1;
            			}
            		    break;
            		case DIGIT:
            		case DASH:
            		case HEX_CHAR:
            		case COMMON_CHAR:
            			{
            				alt144=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return ;
            		    }
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 144;
            		    EXCEPTION->state        = 1;


            		    goto ruletoplabelEx;
            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 144;
                EXCEPTION->state        = 0;


                goto ruletoplabelEx;
            }

            switch (alt144) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:21: alpha
        	    {
        	        FOLLOWPUSH(FOLLOW_alpha_in_toplabel7441);
        	        alpha(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletoplabelEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:29: ( alpha ( ( DASH )? alphanum )+ )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:29: ( alpha ( ( DASH )? alphanum )+ )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:30: alpha ( ( DASH )? alphanum )+
        	        {
        	            FOLLOWPUSH(FOLLOW_alpha_in_toplabel7446);
        	            alpha(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletoplabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:36: ( ( DASH )? alphanum )+
        	            {
        	                int cnt143=0;

        	                for (;;)
        	                {
        	                    int alt143=2;
        	            	switch ( LA(1) ) 
        	            	{
        	            	case DIGIT:
        	            	case DASH:
        	            	case HEX_CHAR:
        	            	case COMMON_CHAR:
        	            		{
        	            			alt143=1;
        	            		}
        	            	    break;

        	            	}

        	            	switch (alt143) 
        	            	{
        	            	    case 1:
        	            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:39: ( DASH )? alphanum
        	            	        {

        	            	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:39: ( DASH )?
        	            	            {
        	            	                int alt142=2;
        	            	                switch ( LA(1) ) 
        	            	                {
        	            	                    case DASH:
        	            	                    	{
        	            	                    		alt142=1;
        	            	                    	}
        	            	                        break;
        	            	                }

        	            	                switch (alt142) 
        	            	                {
        	            	            	case 1:
        	            	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1562:39: DASH
        	            	            	    {
        	            	            	         MATCHT(DASH, &FOLLOW_DASH_in_toplabel7451); 
        	            	            	        if  (HASEXCEPTION())
        	            	            	        {
        	            	            	            goto ruletoplabelEx;
        	            	            	        }
        	            	            	        if (HASFAILED())
        	            	            	        {
        	            	            	            return ;
        	            	            	        }

        	            	            	    }
        	            	            	    break;

        	            	                }
        	            	            }
        	            	            FOLLOWPUSH(FOLLOW_alphanum_in_toplabel7455);
        	            	            alphanum(ctx);

        	            	            FOLLOWPOP();
        	            	            if  (HASEXCEPTION())
        	            	            {
        	            	                goto ruletoplabelEx;
        	            	            }
        	            	            if (HASFAILED())
        	            	            {
        	            	                return ;
        	            	            }

        	            	        }
        	            	        break;

        	            	    default:
        	            	    
        	            		if ( cnt143 >= 1 )
        	            		{
        	            		    goto loop143;
        	            		}
        	            		if (BACKTRACKING>0)
        	            		{
        	            		    FAILEDFLAG = ANTLR3_TRUE;
        	            		    return ;
        	            		}
        	            		/* mismatchedSetEx()
        	            		 */
        	            		CONSTRUCTEX();
        	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	            		goto ruletoplabelEx;
        	            	}
        	            	cnt143++;
        	                }
        	                loop143: ;	/* Jump to here if this rule does not match */
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruletoplabelEx; /* Prevent compiler warnings */
    ruletoplabelEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end toplabel */

/** 
 * $ANTLR start ipv4address
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1564:1: ipv4address : three_digit DOT three_digit DOT three_digit DOT three_digit ;
 */
static belle_sip_messageParser_ipv4address_return
ipv4address(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_ipv4address_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1564:16: ( three_digit DOT three_digit DOT three_digit DOT three_digit )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1564:19: three_digit DOT three_digit DOT three_digit DOT three_digit
        {
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address7471);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DOT, &FOLLOW_DOT_in_ipv4address7473); 
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address7475);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DOT, &FOLLOW_DOT_in_ipv4address7477); 
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address7479);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
             MATCHT(DOT, &FOLLOW_DOT_in_ipv4address7481); 
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }
            FOLLOWPUSH(FOLLOW_three_digit_in_ipv4address7483);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleipv4addressEx; /* Prevent compiler warnings */
    ruleipv4addressEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end ipv4address */

/** 
 * $ANTLR start ipv6reference
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1565:1: ipv6reference : LSBRAQUET ipv6address RSBRAQUET ;
 */
static void
ipv6reference(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_ipv6address_return ipv6address106;
    #undef	RETURN_TYPE_ipv6address106
    #define	RETURN_TYPE_ipv6address106 belle_sip_messageParser_ipv6address_return

    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1565:16: ( LSBRAQUET ipv6address RSBRAQUET )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1565:19: LSBRAQUET ipv6address RSBRAQUET
        {
             MATCHT(LSBRAQUET, &FOLLOW_LSBRAQUET_in_ipv6reference7493); 
            if  (HASEXCEPTION())
            {
                goto ruleipv6referenceEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_ipv6address_in_ipv6reference7495);
            ipv6address106=ipv6address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv6referenceEx;
            }
            if (HASFAILED())
            {
                return ;
            }
             MATCHT(RSBRAQUET, &FOLLOW_RSBRAQUET_in_ipv6reference7497); 
            if  (HASEXCEPTION())
            {
                goto ruleipv6referenceEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            if ( BACKTRACKING==0 ) 
            {
                	(SCOPE_TOP(host))->current=(const char *)(STRSTREAM->toStringTT(STRSTREAM, ipv6address106.start, ipv6address106.stop))->chars;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleipv6referenceEx; /* Prevent compiler warnings */
    ruleipv6referenceEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end ipv6reference */

/** 
 * $ANTLR start ipv6address
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1566:1: ipv6address : hexpart ( COLON ipv4address )? ;
 */
static belle_sip_messageParser_ipv6address_return
ipv6address(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_ipv6address_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1566:16: ( hexpart ( COLON ipv4address )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1566:19: hexpart ( COLON ipv4address )?
        {
            FOLLOWPUSH(FOLLOW_hexpart_in_ipv6address7510);
            hexpart(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv6addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1566:27: ( COLON ipv4address )?
            {
                int alt145=2;
                switch ( LA(1) ) 
                {
                    case COLON:
                    	{
                    		alt145=1;
                    	}
                        break;
                }

                switch (alt145) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1566:29: COLON ipv4address
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_ipv6address7514); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleipv6addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }
            	        FOLLOWPUSH(FOLLOW_ipv4address_in_ipv6address7516);
            	        ipv4address(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleipv6addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleipv6addressEx; /* Prevent compiler warnings */
    ruleipv6addressEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end ipv6address */

/** 
 * $ANTLR start hexpart
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:1: hexpart : ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? );
 */
static void
hexpart(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:16: ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? )
            
            ANTLR3_UINT32 alt148;

            alt148=3;

            alt148 = cdfa148.predict(ctx, RECOGNIZER, ISTREAM, &cdfa148);
            if  (HASEXCEPTION())
            {
                goto rulehexpartEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt148) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:19: hexseq
        	    {
        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart7535);
        	        hexseq(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:28: hexseq COLON COLON ( hexseq )?
        	    {
        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart7539);
        	        hexseq(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(COLON, &FOLLOW_COLON_in_hexpart7541); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(COLON, &FOLLOW_COLON_in_hexpart7543); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:47: ( hexseq )?
        	        {
        	            int alt146=2;
        	            switch ( LA(1) ) 
        	            {
        	                case DIGIT:
        	                case HEX_CHAR:
        	                	{
        	                		alt146=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt146) 
        	            {
        	        	case 1:
        	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:49: hexseq
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart7547);
        	        	        hexseq(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulehexpartEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:61: COLON COLON ( hexseq )?
        	    {
        	         MATCHT(COLON, &FOLLOW_COLON_in_hexpart7554); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }
        	         MATCHT(COLON, &FOLLOW_COLON_in_hexpart7556); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:73: ( hexseq )?
        	        {
        	            int alt147=2;
        	            switch ( LA(1) ) 
        	            {
        	                case DIGIT:
        	                case HEX_CHAR:
        	                	{
        	                		alt147=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt147) 
        	            {
        	        	case 1:
        	        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1567:75: hexseq
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart7560);
        	        	        hexseq(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulehexpartEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulehexpartEx; /* Prevent compiler warnings */
    rulehexpartEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end hexpart */

/** 
 * $ANTLR start hexseq
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1568:1: hexseq : hex4 ( COLON hex4 )* ;
 */
static void
hexseq(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1568:16: ( hex4 ( COLON hex4 )* )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1568:19: hex4 ( COLON hex4 )*
        {
            FOLLOWPUSH(FOLLOW_hex4_in_hexseq7579);
            hex4(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehexseqEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1568:24: ( COLON hex4 )*

            for (;;)
            {
                int alt149=2;
                switch ( LA(1) ) 
                {
                case COLON:
                	{
                		switch ( LA(2) ) 
                		{
                		case DIGIT:
                			{
                				switch ( LA(3) ) 
                				{
                				case DIGIT:
                					{
                						switch ( LA(4) ) 
                						{
                						case DIGIT:
                							{
                								switch ( LA(5) ) 
                								{
                								case EOF:
                								case CRLF:
                								case SP:
                								case DIGIT:
                								case COLON:
                								case COMMA:
                								case SEMI:
                								case RSBRAQUET:
                								case HEX_CHAR:
                									{
                										alt149=1;
                									}
                								    break;

                								}

                							}
                						    break;
                						case EOF:
                						case CRLF:
                						case SP:
                						case COLON:
                						case COMMA:
                						case SEMI:
                						case RSBRAQUET:
                						case HEX_CHAR:
                							{
                								alt149=1;
                							}
                						    break;

                						}

                					}
                				    break;
                				case EOF:
                				case CRLF:
                				case SP:
                				case COLON:
                				case COMMA:
                				case SEMI:
                				case RSBRAQUET:
                				case HEX_CHAR:
                					{
                						alt149=1;
                					}
                				    break;

                				}

                			}
                		    break;
                		case HEX_CHAR:
                			{
                				alt149=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt149) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1568:26: COLON hex4
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_hexseq7583); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehexseqEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }
            	        FOLLOWPUSH(FOLLOW_hex4_in_hexseq7585);
            	        hex4(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehexseqEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop149;	/* break out of the loop */
            	    break;
                }
            }
            loop149: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehexseqEx; /* Prevent compiler warnings */
    rulehexseqEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end hexseq */

/** 
 * $ANTLR start hex4
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1569:1: hex4 : ( hexdigit )+ ;
 */
static void
hex4(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1569:16: ( ( hexdigit )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1569:19: ( hexdigit )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1569:19: ( hexdigit )+
            {
                int cnt150=0;

                for (;;)
                {
                    int alt150=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt150=1;
            		}
            	    break;

            	}

            	switch (alt150) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1569:19: hexdigit
            	        {
            	            FOLLOWPUSH(FOLLOW_hexdigit_in_hex47605);
            	            hexdigit(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehex4Ex;
            	            }
            	            if (HASFAILED())
            	            {
            	                return ;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt150 >= 1 )
            		{
            		    goto loop150;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return ;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehex4Ex;
            	}
            	cnt150++;
                }
                loop150: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehex4Ex; /* Prevent compiler warnings */
    rulehex4Ex: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end hex4 */

/** 
 * $ANTLR start port
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1571:1: port returns [int ret] : ( DIGIT )+ ;
 */
static belle_sip_messageParser_port_return
port(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_port_return retval;

    /* Initialize rule variables
     */


    retval.ret=-1;
    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1573:2: ( ( DIGIT )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1573:5: ( DIGIT )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1573:5: ( DIGIT )+
            {
                int cnt151=0;

                for (;;)
                {
                    int alt151=2;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            		{
            			alt151=1;
            		}
            	    break;

            	}

            	switch (alt151) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1573:5: DIGIT
            	        {
            	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_port7627); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleportEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt151 >= 1 )
            		{
            		    goto loop151;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleportEx;
            	}
            	cnt151++;
                }
                loop151: ;	/* Jump to here if this rule does not match */
            }
            if ( BACKTRACKING==0 ) 
            {
                 retval.ret=atoi((const char *)STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))->chars); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleportEx; /* Prevent compiler warnings */
    ruleportEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end port */

/** 
 * $ANTLR start escaped
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1575:1: escaped : PERCENT hexdigit hexdigit ;
 */
static void
escaped(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1575:13: ( PERCENT hexdigit hexdigit )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1575:16: PERCENT hexdigit hexdigit
        {
             MATCHT(PERCENT, &FOLLOW_PERCENT_in_escaped7643); 
            if  (HASEXCEPTION())
            {
                goto ruleescapedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_hexdigit_in_escaped7645);
            hexdigit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleescapedEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            FOLLOWPUSH(FOLLOW_hexdigit_in_escaped7647);
            hexdigit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleescapedEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleescapedEx; /* Prevent compiler warnings */
    ruleescapedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end escaped */

/** 
 * $ANTLR start ttl
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1576:1: ttl : three_digit ;
 */
static void
ttl(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1576:5: ( three_digit )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1576:7: three_digit
        {
            FOLLOWPUSH(FOLLOW_three_digit_in_ttl7654);
            three_digit(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulettlEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulettlEx; /* Prevent compiler warnings */
    rulettlEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end ttl */

/** 
 * $ANTLR start three_digit
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1577:1: three_digit : ( ( DIGIT )=> DIGIT | ( DIGIT DIGIT )=> ( DIGIT DIGIT ) | ( DIGIT DIGIT DIGIT )=> ( DIGIT DIGIT DIGIT ) );
 */
static void
three_digit(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1577:12: ( ( DIGIT )=> DIGIT | ( DIGIT DIGIT )=> ( DIGIT DIGIT ) | ( DIGIT DIGIT DIGIT )=> ( DIGIT DIGIT DIGIT ) )
            
            ANTLR3_UINT32 alt152;

            alt152=3;

            switch ( LA(1) ) 
            {
            case DIGIT:
            	{

            		{
            		    int LA152_1 = LA(2);
            		    if ( (LA152_1 == DIGIT) ) 
            		    {

            		        {
            		            int LA152_2 = LA(3);
            		            if ( (LA152_2 == DIGIT) && (synpred15_belle_sip_message(ctx))) 
            		            {
            		                alt152=3;
            		            }
            		            else if ( (LA152_2 == DOT) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == SP) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == CRLF) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == COMMA) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == EOF) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == SEMI) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == COLON) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == SLASH) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == QMARK) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == RAQUOT) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == DQUOTE) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else if ( (LA152_2 == RSBRAQUET) && (synpred14_belle_sip_message(ctx))) 
            		            {
            		                alt152=2;
            		            }
            		            else 
            		            {
            		                if (BACKTRACKING>0)
            		                {
            		                    FAILEDFLAG = ANTLR3_TRUE;
            		                    return ;
            		                }
            		            
            		                CONSTRUCTEX();
            		                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		                EXCEPTION->message      = (void *)"";
            		                EXCEPTION->decisionNum  = 152;
            		                EXCEPTION->state        = 2;


            		                goto rulethree_digitEx;
            		            }
            		        }
            		    }
            		    else if ( (LA152_1 == DOT) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == SP) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == CRLF) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == COMMA) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == EOF) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == SEMI) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == COLON) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == SLASH) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == QMARK) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == RAQUOT) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == DQUOTE) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else if ( (LA152_1 == RSBRAQUET) && (synpred13_belle_sip_message(ctx))) 
            		    {
            		        alt152=1;
            		    }
            		    else 
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return ;
            		        }
            		    
            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 152;
            		        EXCEPTION->state        = 1;


            		        goto rulethree_digitEx;
            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 152;
                EXCEPTION->state        = 0;


                goto rulethree_digitEx;
            }

            switch (alt152) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1577:14: ( DIGIT )=> DIGIT
        	    {
        	         MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit7666); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulethree_digitEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1579:13: ( DIGIT DIGIT )=> ( DIGIT DIGIT )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1579:30: ( DIGIT DIGIT )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1579:31: DIGIT DIGIT
        	        {
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit7705); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit7707); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1581:13: ( DIGIT DIGIT DIGIT )=> ( DIGIT DIGIT DIGIT )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1581:35: ( DIGIT DIGIT DIGIT )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1581:36: DIGIT DIGIT DIGIT
        	        {
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit7748); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit7750); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_three_digit7752); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulethree_digitEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulethree_digitEx; /* Prevent compiler warnings */
    rulethree_digitEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end three_digit */

/** 
 * $ANTLR start token
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1582:1: token : ( alphanum | mark | PERCENT | PLUS | BQUOTE )+ ;
 */
static belle_sip_messageParser_token_return
token(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_token_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:3: ( ( alphanum | mark | PERCENT | PLUS | BQUOTE )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:7: ( alphanum | mark | PERCENT | PLUS | BQUOTE )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:7: ( alphanum | mark | PERCENT | PLUS | BQUOTE )+
            {
                int cnt153=0;

                for (;;)
                {
                    int alt153=6;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            		{
            			alt153=1;
            		}
            	    break;
            	case DOT:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt153=2;
            		}
            	    break;
            	case PERCENT:
            		{
            			alt153=3;
            		}
            	    break;
            	case PLUS:
            		{
            			alt153=4;
            		}
            	    break;
            	case BQUOTE:
            		{
            			alt153=5;
            		}
            	    break;

            	}

            	switch (alt153) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:8: alphanum
            	        {
            	            FOLLOWPUSH(FOLLOW_alphanum_in_token7774);
            	            alphanum(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:19: mark
            	        {
            	            FOLLOWPUSH(FOLLOW_mark_in_token7778);
            	            mark(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:26: PERCENT
            	        {
            	             MATCHT(PERCENT, &FOLLOW_PERCENT_in_token7782); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 4:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:36: PLUS
            	        {
            	             MATCHT(PLUS, &FOLLOW_PLUS_in_token7786); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 5:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1583:43: BQUOTE
            	        {
            	             MATCHT(BQUOTE, &FOLLOW_BQUOTE_in_token7790); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt153 >= 1 )
            		{
            		    goto loop153;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletokenEx;
            	}
            	cnt153++;
                }
                loop153: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruletokenEx; /* Prevent compiler warnings */
    ruletokenEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end token */

/** 
 * $ANTLR start reserved_for_from_to_contact_addr_spec
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1585:1: reserved_for_from_to_contact_addr_spec : ( COLON | AT | AND | EQUAL | PLUS | DOLLARD | SLASH );
 */
static void
reserved_for_from_to_contact_addr_spec(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1585:39: ( COLON | AT | AND | EQUAL | PLUS | DOLLARD | SLASH )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
        {
            if ( LA(1) == SLASH || ((LA(1) >= COLON) && (LA(1) <= DOLLARD)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_reserved_for_from_to_contact_addr_spec0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_reserved_for_from_to_contact_addr_spec0);    goto rulereserved_for_from_to_contact_addr_specEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulereserved_for_from_to_contact_addr_specEx; /* Prevent compiler warnings */
    rulereserved_for_from_to_contact_addr_specEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end reserved_for_from_to_contact_addr_spec */

/** 
 * $ANTLR start reserved
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1588:1: reserved : ( SEMI | COMMA | QMARK | reserved_for_from_to_contact_addr_spec );
 */
static void
reserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1589:3: ( SEMI | COMMA | QMARK | reserved_for_from_to_contact_addr_spec )
            
            ANTLR3_UINT32 alt154;

            alt154=4;

            switch ( LA(1) ) 
            {
            case SEMI:
            	{
            		alt154=1;
            	}
                break;
            case COMMA:
            	{
            		alt154=2;
            	}
                break;
            case QMARK:
            	{
            		alt154=3;
            	}
                break;
            case SLASH:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            	{
            		alt154=4;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 154;
                EXCEPTION->state        = 0;


                goto rulereservedEx;
            }

            switch (alt154) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1589:7: SEMI
        	    {
        	         MATCHT(SEMI, &FOLLOW_SEMI_in_reserved7845); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulereservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1589:14: COMMA
        	    {
        	         MATCHT(COMMA, &FOLLOW_COMMA_in_reserved7849); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulereservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 3:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1589:23: QMARK
        	    {
        	         MATCHT(QMARK, &FOLLOW_QMARK_in_reserved7854); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulereservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 4:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1589:32: reserved_for_from_to_contact_addr_spec
        	    {
        	        FOLLOWPUSH(FOLLOW_reserved_for_from_to_contact_addr_spec_in_reserved7859);
        	        reserved_for_from_to_contact_addr_spec(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulereservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulereservedEx; /* Prevent compiler warnings */
    rulereservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end reserved */

/** 
 * $ANTLR start unreserved
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1591:1: unreserved : ( alphanum | mark );
 */
static void
unreserved(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1591:12: ( alphanum | mark )
            
            ANTLR3_UINT32 alt155;

            alt155=2;

            switch ( LA(1) ) 
            {
            case DIGIT:
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		alt155=1;
            	}
                break;
            case DOT:
            case DASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            	{
            		alt155=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 155;
                EXCEPTION->state        = 0;


                goto ruleunreservedEx;
            }

            switch (alt155) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1591:17: alphanum
        	    {
        	        FOLLOWPUSH(FOLLOW_alphanum_in_unreserved7892);
        	        alphanum(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunreservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1591:27: mark
        	    {
        	        FOLLOWPUSH(FOLLOW_mark_in_unreserved7895);
        	        mark(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleunreservedEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleunreservedEx; /* Prevent compiler warnings */
    ruleunreservedEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end unreserved */

/** 
 * $ANTLR start alphanum
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1592:1: alphanum : ( alpha | DIGIT );
 */
static void
alphanum(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1592:10: ( alpha | DIGIT )
            
            ANTLR3_UINT32 alt156;

            alt156=2;

            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		alt156=1;
            	}
                break;
            case DIGIT:
            	{
            		alt156=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 156;
                EXCEPTION->state        = 0;


                goto rulealphanumEx;
            }

            switch (alt156) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1592:16: alpha
        	    {
        	        FOLLOWPUSH(FOLLOW_alpha_in_alphanum7908);
        	        alpha(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulealphanumEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1592:24: DIGIT
        	    {
        	         MATCHT(DIGIT, &FOLLOW_DIGIT_in_alphanum7912); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulealphanumEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulealphanumEx; /* Prevent compiler warnings */
    rulealphanumEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end alphanum */

/** 
 * $ANTLR start hexdigit
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1593:1: hexdigit : ( HEX_CHAR | DIGIT );
 */
static void
hexdigit(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1594:3: ( HEX_CHAR | DIGIT )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
        {
            if ( LA(1) == DIGIT || LA(1) == HEX_CHAR )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_hexdigit0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_hexdigit0);    goto rulehexdigitEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehexdigitEx; /* Prevent compiler warnings */
    rulehexdigitEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end hexdigit */

/** 
 * $ANTLR start alpha
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1595:1: alpha : ( HEX_CHAR | COMMON_CHAR );
 */
static void
alpha(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1595:7: ( HEX_CHAR | COMMON_CHAR )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
        {
            if ( ((LA(1) >= HEX_CHAR) && (LA(1) <= COMMON_CHAR)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_alpha0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_alpha0);    goto rulealphaEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealphaEx; /* Prevent compiler warnings */
    rulealphaEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end alpha */

/** 
 * $ANTLR start word
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1597:1: word : ( alphanum | mark | PERCENT | PLUS | BQUOTE | LAQUOT | RAQUOT | COLON | BSLASH | DQUOTE | SLASH | LSBRAQUET | RSBRAQUET | QMARK | LBRACE | RBRACE )+ ;
 */
static belle_sip_messageParser_word_return
word(pbelle_sip_messageParser ctx)
{   
    belle_sip_messageParser_word_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1598:3: ( ( alphanum | mark | PERCENT | PLUS | BQUOTE | LAQUOT | RAQUOT | COLON | BSLASH | DQUOTE | SLASH | LSBRAQUET | RSBRAQUET | QMARK | LBRACE | RBRACE )+ )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1598:7: ( alphanum | mark | PERCENT | PLUS | BQUOTE | LAQUOT | RAQUOT | COLON | BSLASH | DQUOTE | SLASH | LSBRAQUET | RSBRAQUET | QMARK | LBRACE | RBRACE )+
        {
            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1598:7: ( alphanum | mark | PERCENT | PLUS | BQUOTE | LAQUOT | RAQUOT | COLON | BSLASH | DQUOTE | SLASH | LSBRAQUET | RSBRAQUET | QMARK | LBRACE | RBRACE )+
            {
                int cnt157=0;

                for (;;)
                {
                    int alt157=17;
            	switch ( LA(1) ) 
            	{
            	case DIGIT:
            	case HEX_CHAR:
            	case COMMON_CHAR:
            		{
            			alt157=1;
            		}
            	    break;
            	case DOT:
            	case DASH:
            	case STAR:
            	case LPAREN:
            	case RPAREN:
            	case USCORE:
            	case EMARK:
            	case TILDE:
            	case SQUOTE:
            		{
            			alt157=2;
            		}
            	    break;
            	case PERCENT:
            		{
            			alt157=3;
            		}
            	    break;
            	case PLUS:
            		{
            			alt157=4;
            		}
            	    break;
            	case BQUOTE:
            		{
            			alt157=5;
            		}
            	    break;
            	case LAQUOT:
            		{
            			alt157=6;
            		}
            	    break;
            	case RAQUOT:
            		{
            			alt157=7;
            		}
            	    break;
            	case COLON:
            		{
            			alt157=8;
            		}
            	    break;
            	case BSLASH:
            		{
            			alt157=9;
            		}
            	    break;
            	case DQUOTE:
            		{
            			alt157=10;
            		}
            	    break;
            	case SLASH:
            		{
            			alt157=11;
            		}
            	    break;
            	case LSBRAQUET:
            		{
            			alt157=12;
            		}
            	    break;
            	case RSBRAQUET:
            		{
            			alt157=13;
            		}
            	    break;
            	case QMARK:
            		{
            			alt157=14;
            		}
            	    break;
            	case LBRACE:
            		{
            			alt157=15;
            		}
            	    break;
            	case RBRACE:
            		{
            			alt157=16;
            		}
            	    break;

            	}

            	switch (alt157) 
            	{
            	    case 1:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1598:8: alphanum
            	        {
            	            FOLLOWPUSH(FOLLOW_alphanum_in_word7982);
            	            alphanum(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 2:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1598:19: mark
            	        {
            	            FOLLOWPUSH(FOLLOW_mark_in_word7986);
            	            mark(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 3:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1598:28: PERCENT
            	        {
            	             MATCHT(PERCENT, &FOLLOW_PERCENT_in_word7992); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 4:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1599:25: PLUS
            	        {
            	             MATCHT(PLUS, &FOLLOW_PLUS_in_word8019); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 5:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1599:32: BQUOTE
            	        {
            	             MATCHT(BQUOTE, &FOLLOW_BQUOTE_in_word8023); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 6:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1600:22: LAQUOT
            	        {
            	             MATCHT(LAQUOT, &FOLLOW_LAQUOT_in_word8048); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 7:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1600:31: RAQUOT
            	        {
            	             MATCHT(RAQUOT, &FOLLOW_RAQUOT_in_word8052); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 8:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:22: COLON
            	        {
            	             MATCHT(COLON, &FOLLOW_COLON_in_word8077); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 9:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:30: BSLASH
            	        {
            	             MATCHT(BSLASH, &FOLLOW_BSLASH_in_word8081); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 10:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:39: DQUOTE
            	        {
            	             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_word8085); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 11:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:48: SLASH
            	        {
            	             MATCHT(SLASH, &FOLLOW_SLASH_in_word8089); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 12:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:56: LSBRAQUET
            	        {
            	             MATCHT(LSBRAQUET, &FOLLOW_LSBRAQUET_in_word8093); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 13:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:68: RSBRAQUET
            	        {
            	             MATCHT(RSBRAQUET, &FOLLOW_RSBRAQUET_in_word8097); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 14:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:80: QMARK
            	        {
            	             MATCHT(QMARK, &FOLLOW_QMARK_in_word8101); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 15:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:88: LBRACE
            	        {
            	             MATCHT(LBRACE, &FOLLOW_LBRACE_in_word8105); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;
            	    case 16:
            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1601:97: RBRACE
            	        {
            	             MATCHT(RBRACE, &FOLLOW_RBRACE_in_word8109); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt157 >= 1 )
            		{
            		    goto loop157;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulewordEx;
            	}
            	cnt157++;
                }
                loop157: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulewordEx; /* Prevent compiler warnings */
    rulewordEx: ;
    retval.stop = LT(-1);


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return retval;
}
/* $ANTLR end word */

/** 
 * $ANTLR start mark
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1603:1: mark : ( DASH | USCORE | DOT | EMARK | TILDE | STAR | SQUOTE | LPAREN | RPAREN );
 */
static void
mark(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1603:7: ( DASH | USCORE | DOT | EMARK | TILDE | STAR | SQUOTE | LPAREN | RPAREN )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
        {
            if ( LA(1) == DOT || LA(1) == DASH || ((LA(1) >= STAR) && (LA(1) <= RPAREN)) || ((LA(1) >= USCORE) && (LA(1) <= SQUOTE)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            }
            else 
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_mark0;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_mark0);    goto rulemarkEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulemarkEx; /* Prevent compiler warnings */
    rulemarkEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end mark */

/** 
 * $ANTLR start sp_tab_colon
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1604:1: sp_tab_colon : ( SP | HTAB )* COLON ;
 */
static void
sp_tab_colon(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1605:2: ( ( SP | HTAB )* COLON )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1605:3: ( SP | HTAB )* COLON
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1605:3: ( SP | HTAB )*

            for (;;)
            {
                int alt158=2;
                switch ( LA(1) ) 
                {
                case SP:
                case HTAB:
                	{
                		alt158=1;
                	}
                    break;

                }

                switch (alt158) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:
            	    {
            	        if ( LA(1) == SP || LA(1) == HTAB )
            	        {
            	            CONSUME();
            	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else 
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return ;
            	            }
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = &FOLLOW_set_in_sp_tab_colon8172;
            	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_sp_tab_colon8172);    goto rulesp_tab_colonEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop158;	/* break out of the loop */
            	    break;
                }
            }
            loop158: ; /* Jump out to here if this rule does not match */

             MATCHT(COLON, &FOLLOW_COLON_in_sp_tab_colon8183); 
            if  (HASEXCEPTION())
            {
                goto rulesp_tab_colonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesp_tab_colonEx; /* Prevent compiler warnings */
    rulesp_tab_colonEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sp_tab_colon */

/** 
 * $ANTLR start hcolon
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1606:1: hcolon : sp_tab_colon ( lws )? ;
 */
static void
hcolon(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1606:9: ( sp_tab_colon ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1606:11: sp_tab_colon ( lws )?
        {
            FOLLOWPUSH(FOLLOW_sp_tab_colon_in_hcolon8193);
            sp_tab_colon(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehcolonEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1606:24: ( lws )?
            {
                int alt159=2;
                switch ( LA(1) ) 
                {
                    case SP:
                    	{
                    		alt159=1;
                    	}
                        break;
                    case CRLF:
                    	{
                    		switch ( LA(2) ) 
                    		{
                    		    case SP:
                    		    	{
                    		    		alt159=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt159) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1606:24: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_hcolon8195);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehcolonEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulehcolonEx; /* Prevent compiler warnings */
    rulehcolonEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end hcolon */

/** 
 * $ANTLR start ldquot
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1608:1: ldquot : ( lws )? DQUOTE ;
 */
static void
ldquot(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1608:9: ( ( lws )? DQUOTE )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1608:12: ( lws )? DQUOTE
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1608:12: ( lws )?
            {
                int alt160=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt160=1;
                    	}
                        break;
                }

                switch (alt160) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1608:12: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_ldquot8216);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleldquotEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_ldquot8219); 
            if  (HASEXCEPTION())
            {
                goto ruleldquotEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleldquotEx; /* Prevent compiler warnings */
    ruleldquotEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end ldquot */

/** 
 * $ANTLR start rdquot
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1609:1: rdquot : DQUOTE ( lws )? ;
 */
static void
rdquot(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1609:8: ( DQUOTE ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1609:10: DQUOTE ( lws )?
        {
             MATCHT(DQUOTE, &FOLLOW_DQUOTE_in_rdquot8227); 
            if  (HASEXCEPTION())
            {
                goto rulerdquotEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1609:17: ( lws )?
            {
                int alt161=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt161=1;
                    	}
                        break;
                }

                switch (alt161) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1609:17: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_rdquot8229);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerdquotEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerdquotEx; /* Prevent compiler warnings */
    rulerdquotEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end rdquot */

/** 
 * $ANTLR start semi
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1610:1: semi : ( lws )? SEMI ( lws )? ;
 */
static void
semi(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1610:5: ( ( lws )? SEMI ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1610:7: ( lws )? SEMI ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1610:7: ( lws )?
            {
                int alt162=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt162=1;
                    	}
                        break;
                }

                switch (alt162) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1610:7: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_semi8236);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesemiEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(SEMI, &FOLLOW_SEMI_in_semi8239); 
            if  (HASEXCEPTION())
            {
                goto rulesemiEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1610:17: ( lws )?
            {
                int alt163=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt163=1;
                    	}
                        break;
                }

                switch (alt163) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1610:17: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_semi8241);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesemiEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesemiEx; /* Prevent compiler warnings */
    rulesemiEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end semi */

/** 
 * $ANTLR start comma
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1611:1: comma : ( lws )? COMMA ( lws )? ;
 */
static void
comma(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1611:7: ( ( lws )? COMMA ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1611:9: ( lws )? COMMA ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1611:9: ( lws )?
            {
                int alt164=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt164=1;
                    	}
                        break;
                }

                switch (alt164) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1611:9: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_comma8249);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(COMMA, &FOLLOW_COMMA_in_comma8252); 
            if  (HASEXCEPTION())
            {
                goto rulecommaEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1611:20: ( lws )?
            {
                int alt165=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt165=1;
                    	}
                        break;
                }

                switch (alt165) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1611:20: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_comma8254);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecommaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulecommaEx; /* Prevent compiler warnings */
    rulecommaEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end comma */

/** 
 * $ANTLR start sp_laquot
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1612:1: sp_laquot : ( lws )? LAQUOT ;
 */
static void
sp_laquot(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1613:3: ( ( lws )? LAQUOT )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1613:5: ( lws )? LAQUOT
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1613:5: ( lws )?
            {
                int alt166=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt166=1;
                    	}
                        break;
                }

                switch (alt166) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1613:5: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_sp_laquot8264);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesp_laquotEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(LAQUOT, &FOLLOW_LAQUOT_in_sp_laquot8267); 
            if  (HASEXCEPTION())
            {
                goto rulesp_laquotEx;
            }
            if (HASFAILED())
            {
                return ;
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesp_laquotEx; /* Prevent compiler warnings */
    rulesp_laquotEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end sp_laquot */

/** 
 * $ANTLR start raquot_sp
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1614:1: raquot_sp : RAQUOT ( lws )? ;
 */
static void
raquot_sp(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1615:3: ( RAQUOT ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1615:5: RAQUOT ( lws )?
        {
             MATCHT(RAQUOT, &FOLLOW_RAQUOT_in_raquot_sp8277); 
            if  (HASEXCEPTION())
            {
                goto ruleraquot_spEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1615:12: ( lws )?
            {
                int alt167=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt167=1;
                    	}
                        break;
                }

                switch (alt167) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1615:12: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_raquot_sp8279);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleraquot_spEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleraquot_spEx; /* Prevent compiler warnings */
    ruleraquot_spEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end raquot_sp */

/** 
 * $ANTLR start equal
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1616:1: equal : ( lws )? EQUAL ( lws )? ;
 */
static void
equal(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1616:6: ( ( lws )? EQUAL ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1617:4: ( lws )? EQUAL ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1617:4: ( lws )?
            {
                int alt168=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt168=1;
                    	}
                        break;
                }

                switch (alt168) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1617:4: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_equal8289);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(EQUAL, &FOLLOW_EQUAL_in_equal8292); 
            if  (HASEXCEPTION())
            {
                goto ruleequalEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1617:15: ( lws )?
            {
                int alt169=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt169=1;
                    	}
                        break;
                }

                switch (alt169) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1617:15: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_equal8294);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleequalEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleequalEx; /* Prevent compiler warnings */
    ruleequalEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end equal */

/** 
 * $ANTLR start slash
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1618:1: slash : ( lws )? SLASH ( lws )? ;
 */
static void
slash(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1618:7: ( ( lws )? SLASH ( lws )? )
        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1618:9: ( lws )? SLASH ( lws )?
        {

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1618:9: ( lws )?
            {
                int alt170=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt170=1;
                    	}
                        break;
                }

                switch (alt170) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1618:9: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_slash8302);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleslashEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }
             MATCHT(SLASH, &FOLLOW_SLASH_in_slash8305); 
            if  (HASEXCEPTION())
            {
                goto ruleslashEx;
            }
            if (HASFAILED())
            {
                return ;
            }

            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1618:20: ( lws )?
            {
                int alt171=2;
                switch ( LA(1) ) 
                {
                    case CRLF:
                    case SP:
                    	{
                    		alt171=1;
                    	}
                        break;
                }

                switch (alt171) 
                {
            	case 1:
            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1618:20: lws
            	    {
            	        FOLLOWPUSH(FOLLOW_lws_in_slash8307);
            	        lws(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleslashEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return ;
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleslashEx; /* Prevent compiler warnings */
    ruleslashEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end slash */

/** 
 * $ANTLR start lws
 * /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:1: lws : ( ( ( SP )* CRLF ( SP )+ ) | ( SP )+ );
 */
static void
lws(pbelle_sip_messageParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:5: ( ( ( SP )* CRLF ( SP )+ ) | ( SP )+ )
            
            ANTLR3_UINT32 alt175;

            alt175=2;

            alt175 = cdfa175.predict(ctx, RECOGNIZER, ISTREAM, &cdfa175);
            if  (HASEXCEPTION())
            {
                goto rulelwsEx;
            }
            if (HASFAILED())
            {
                return ;
            }
            switch (alt175) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:7: ( ( SP )* CRLF ( SP )+ )
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:7: ( ( SP )* CRLF ( SP )+ )
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:8: ( SP )* CRLF ( SP )+
        	        {

        	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:8: ( SP )*

        	            for (;;)
        	            {
        	                int alt172=2;
        	                switch ( LA(1) ) 
        	                {
        	                case SP:
        	                	{
        	                		alt172=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt172) 
        	                {
        	            	case 1:
        	            	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:8: SP
        	            	    {
        	            	         MATCHT(SP, &FOLLOW_SP_in_lws8316); 
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulelwsEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return ;
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop172;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop172: ; /* Jump out to here if this rule does not match */

        	             MATCHT(CRLF, &FOLLOW_CRLF_in_lws8319); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulelwsEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:17: ( SP )+
        	            {
        	                int cnt173=0;

        	                for (;;)
        	                {
        	                    int alt173=2;
        	            	switch ( LA(1) ) 
        	            	{
        	            	case SP:
        	            		{
        	            			alt173=1;
        	            		}
        	            	    break;

        	            	}

        	            	switch (alt173) 
        	            	{
        	            	    case 1:
        	            	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:17: SP
        	            	        {
        	            	             MATCHT(SP, &FOLLOW_SP_in_lws8321); 
        	            	            if  (HASEXCEPTION())
        	            	            {
        	            	                goto rulelwsEx;
        	            	            }
        	            	            if (HASFAILED())
        	            	            {
        	            	                return ;
        	            	            }

        	            	        }
        	            	        break;

        	            	    default:
        	            	    
        	            		if ( cnt173 >= 1 )
        	            		{
        	            		    goto loop173;
        	            		}
        	            		if (BACKTRACKING>0)
        	            		{
        	            		    FAILEDFLAG = ANTLR3_TRUE;
        	            		    return ;
        	            		}
        	            		/* mismatchedSetEx()
        	            		 */
        	            		CONSTRUCTEX();
        	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	            		goto rulelwsEx;
        	            	}
        	            	cnt173++;
        	                }
        	                loop173: ;	/* Jump to here if this rule does not match */
        	            }

        	        }


        	    }
        	    break;
        	case 2:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:24: ( SP )+
        	    {
        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:24: ( SP )+
        	        {
        	            int cnt174=0;

        	            for (;;)
        	            {
        	                int alt174=2;
        	        	switch ( LA(1) ) 
        	        	{
        	        	case SP:
        	        		{
        	        			alt174=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt174) 
        	        	{
        	        	    case 1:
        	        	        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1619:24: SP
        	        	        {
        	        	             MATCHT(SP, &FOLLOW_SP_in_lws8327); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulelwsEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }

        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt174 >= 1 )
        	        		{
        	        		    goto loop174;
        	        		}
        	        		if (BACKTRACKING>0)
        	        		{
        	        		    FAILEDFLAG = ANTLR3_TRUE;
        	        		    return ;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulelwsEx;
        	        	}
        	        	cnt174++;
        	            }
        	            loop174: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulelwsEx; /* Prevent compiler warnings */
    rulelwsEx: ;


                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION; 
                }


    return ;
}
/* $ANTLR end lws */

// $ANTLR start synpred1_belle_sip_message
static void synpred1_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:9: ( (~ ( CRLF ) )* sip_version CRLF )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:11: (~ ( CRLF ) )* sip_version CRLF
    {

        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:11: (~ ( CRLF ) )*

        for (;;)
        {
            int alt176=2;
            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		{
            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            		    */
            		    int LA176_1 = LA(2);
            		    if ( (!( ((IS_TOKEN(SIP/))) )) ) 
            		    {
            		        alt176=1;
            		    }

            		}
            	}
                break;
            case SP:
            case SLASH:
            case DIGIT:
            case DOT:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            case COMMA:
            case SEMI:
            case QMARK:
            case DASH:
            case DQUOTE:
            case BSLASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case OCTET:
            case LSBRAQUET:
            case RSBRAQUET:
            case PERCENT:
            case BQUOTE:
            case LAQUOT:
            case RAQUOT:
            case LBRACE:
            case RBRACE:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            case HTAB:
            case OR:
            	{
            		alt176=1;
            	}
                break;

            }

            switch (alt176) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:117:11: ~ ( CRLF )
        	    {
        	        if ( ((LA(1) >= SP) && (LA(1) <= OR)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_synpred1_belle_sip_message174;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_synpred1_belle_sip_message174);    goto rulesynpred1_belle_sip_messageEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop176;	/* break out of the loop */
        	    break;
            }
        }
        loop176: ; /* Jump out to here if this rule does not match */

        FOLLOWPUSH(FOLLOW_sip_version_in_synpred1_belle_sip_message180);
        sip_version(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(CRLF, &FOLLOW_CRLF_in_synpred1_belle_sip_message182); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred1_belle_sip_messageEx: ;

}
// $ANTLR end synpred1_belle_sip_message

// $ANTLR start synpred2_belle_sip_message
static void synpred2_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:118:8: ( (~ ( CRLF ) )* http_version CRLF )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:118:10: (~ ( CRLF ) )* http_version CRLF
    {

        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:118:10: (~ ( CRLF ) )*

        for (;;)
        {
            int alt177=2;
            switch ( LA(1) ) 
            {
            case HEX_CHAR:
            case COMMON_CHAR:
            	{
            		{
            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            		    */
            		    int LA177_1 = LA(2);
            		    if ( (!( ((IS_TOKEN(HTTP/))) )) ) 
            		    {
            		        alt177=1;
            		    }

            		}
            	}
                break;
            case SP:
            case SLASH:
            case DIGIT:
            case DOT:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            case COMMA:
            case SEMI:
            case QMARK:
            case DASH:
            case DQUOTE:
            case BSLASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case OCTET:
            case LSBRAQUET:
            case RSBRAQUET:
            case PERCENT:
            case BQUOTE:
            case LAQUOT:
            case RAQUOT:
            case LBRACE:
            case RBRACE:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            case HTAB:
            case OR:
            	{
            		alt177=1;
            	}
                break;

            }

            switch (alt177) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:118:10: ~ ( CRLF )
        	    {
        	        if ( ((LA(1) >= SP) && (LA(1) <= OR)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_synpred2_belle_sip_message202;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_synpred2_belle_sip_message202);    goto rulesynpred2_belle_sip_messageEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop177;	/* break out of the loop */
        	    break;
            }
        }
        loop177: ; /* Jump out to here if this rule does not match */

        FOLLOWPUSH(FOLLOW_http_version_in_synpred2_belle_sip_message208);
        http_version(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(CRLF, &FOLLOW_CRLF_in_synpred2_belle_sip_message210); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred2_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred2_belle_sip_messageEx: ;

}
// $ANTLR end synpred2_belle_sip_message

// $ANTLR start synpred3_belle_sip_message
static void synpred3_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:11: ( sip_version (~ ( CRLF ) )* CRLF )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:12: sip_version (~ ( CRLF ) )* CRLF
    {
        FOLLOWPUSH(FOLLOW_sip_version_in_synpred3_belle_sip_message558);
        sip_version(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:25: (~ ( CRLF ) )*

        for (;;)
        {
            int alt178=2;
            switch ( LA(1) ) 
            {
            case SP:
            case SLASH:
            case DIGIT:
            case DOT:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            case COMMA:
            case SEMI:
            case QMARK:
            case DASH:
            case DQUOTE:
            case BSLASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case OCTET:
            case LSBRAQUET:
            case RSBRAQUET:
            case PERCENT:
            case BQUOTE:
            case HEX_CHAR:
            case COMMON_CHAR:
            case LAQUOT:
            case RAQUOT:
            case LBRACE:
            case RBRACE:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            case HTAB:
            case OR:
            	{
            		alt178=1;
            	}
                break;

            }

            switch (alt178) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:220:25: ~ ( CRLF )
        	    {
        	        if ( ((LA(1) >= SP) && (LA(1) <= OR)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_synpred3_belle_sip_message561;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_synpred3_belle_sip_message561);    goto rulesynpred3_belle_sip_messageEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop178;	/* break out of the loop */
        	    break;
            }
        }
        loop178: ; /* Jump out to here if this rule does not match */

         MATCHT(CRLF, &FOLLOW_CRLF_in_synpred3_belle_sip_message567); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred3_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred3_belle_sip_messageEx: ;

}
// $ANTLR end synpred3_belle_sip_message

// $ANTLR start synpred4_belle_sip_message
static void synpred4_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:221:11: ( http_version (~ ( CRLF ) )* CRLF )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:221:12: http_version (~ ( CRLF ) )* CRLF
    {
        FOLLOWPUSH(FOLLOW_http_version_in_synpred4_belle_sip_message589);
        http_version(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:221:25: (~ ( CRLF ) )*

        for (;;)
        {
            int alt179=2;
            switch ( LA(1) ) 
            {
            case SP:
            case SLASH:
            case DIGIT:
            case DOT:
            case COLON:
            case AT:
            case AND:
            case EQUAL:
            case PLUS:
            case DOLLARD:
            case COMMA:
            case SEMI:
            case QMARK:
            case DASH:
            case DQUOTE:
            case BSLASH:
            case STAR:
            case LPAREN:
            case RPAREN:
            case OCTET:
            case LSBRAQUET:
            case RSBRAQUET:
            case PERCENT:
            case BQUOTE:
            case HEX_CHAR:
            case COMMON_CHAR:
            case LAQUOT:
            case RAQUOT:
            case LBRACE:
            case RBRACE:
            case USCORE:
            case EMARK:
            case TILDE:
            case SQUOTE:
            case HTAB:
            case OR:
            	{
            		alt179=1;
            	}
                break;

            }

            switch (alt179) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:221:25: ~ ( CRLF )
        	    {
        	        if ( ((LA(1) >= SP) && (LA(1) <= OR)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_synpred4_belle_sip_message591;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_synpred4_belle_sip_message591);    goto rulesynpred4_belle_sip_messageEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop179;	/* break out of the loop */
        	    break;
            }
        }
        loop179: ; /* Jump out to here if this rule does not match */

         MATCHT(CRLF, &FOLLOW_CRLF_in_synpred4_belle_sip_message598); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred4_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred4_belle_sip_messageEx: ;

}
// $ANTLR end synpred4_belle_sip_message

// $ANTLR start synpred6_belle_sip_message
static void synpred6_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:345:2: ( SLASH SLASH path_segments[NULL] )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:345:3: SLASH SLASH path_segments[NULL]
    {
         MATCHT(SLASH, &FOLLOW_SLASH_in_synpred6_belle_sip_message1253); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred6_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(SLASH, &FOLLOW_SLASH_in_synpred6_belle_sip_message1255); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred6_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_path_segments_in_synpred6_belle_sip_message1257);
        path_segments(ctx, NULL);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred6_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred6_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred6_belle_sip_messageEx: ;

}
// $ANTLR end synpred6_belle_sip_message

// $ANTLR start synpred7_belle_sip_message
static void synpred7_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:3: ( SLASH SLASH authority[NULL] ( path_segments[NULL] )? )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:4: SLASH SLASH authority[NULL] ( path_segments[NULL] )?
    {
         MATCHT(SLASH, &FOLLOW_SLASH_in_synpred7_belle_sip_message1279); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred7_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(SLASH, &FOLLOW_SLASH_in_synpred7_belle_sip_message1281); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred7_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        FOLLOWPUSH(FOLLOW_authority_in_synpred7_belle_sip_message1283);
        authority(ctx, NULL);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred7_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:32: ( path_segments[NULL] )?
        {
            int alt180=2;
            switch ( LA(1) ) 
            {
                case SLASH:
                	{
                		alt180=1;
                	}
                    break;
            }

            switch (alt180) 
            {
        	case 1:
        	    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:347:33: path_segments[NULL]
        	    {
        	        FOLLOWPUSH(FOLLOW_path_segments_in_synpred7_belle_sip_message1287);
        	        path_segments(ctx, NULL);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesynpred7_belle_sip_messageEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred7_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred7_belle_sip_messageEx: ;

}
// $ANTLR end synpred7_belle_sip_message

// $ANTLR start synpred8_belle_sip_message
static void synpred8_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:377:4: ( authority_userinfo[NULL] )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:377:5: authority_userinfo[NULL]
    {
        FOLLOWPUSH(FOLLOW_authority_userinfo_in_synpred8_belle_sip_message1519);
        authority_userinfo(ctx, NULL);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred8_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred8_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred8_belle_sip_messageEx: ;

}
// $ANTLR end synpred8_belle_sip_message

// $ANTLR start synpred9_belle_sip_message
static void synpred9_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:45: ( userinfo[$paramless_uri::current] )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1443:46: userinfo[$paramless_uri::current]
    {
        FOLLOWPUSH(FOLLOW_userinfo_in_synpred9_belle_sip_message6475);
        userinfo(ctx, 	(SCOPE_TOP(paramless_uri))->current);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred9_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred9_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred9_belle_sip_messageEx: ;

}
// $ANTLR end synpred9_belle_sip_message

// $ANTLR start synpred10_belle_sip_message
static void synpred10_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:36: ( userinfo[NULL] )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1455:37: userinfo[NULL]
    {
        FOLLOWPUSH(FOLLOW_userinfo_in_synpred10_belle_sip_message6545);
        userinfo(ctx, NULL);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred10_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred10_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred10_belle_sip_messageEx: ;

}
// $ANTLR end synpred10_belle_sip_message

// $ANTLR start synpred11_belle_sip_message
static void synpred11_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1522:7: ( param_unreserved )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1522:8: param_unreserved
    {
        FOLLOWPUSH(FOLLOW_param_unreserved_in_synpred11_belle_sip_message6968);
        param_unreserved(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred11_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred11_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred11_belle_sip_messageEx: ;

}
// $ANTLR end synpred11_belle_sip_message

// $ANTLR start synpred12_belle_sip_message
static void synpred12_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:42: ( toplabel )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1559:43: toplabel
    {
        FOLLOWPUSH(FOLLOW_toplabel_in_synpred12_belle_sip_message7382);
        toplabel(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred12_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred12_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred12_belle_sip_messageEx: ;

}
// $ANTLR end synpred12_belle_sip_message

// $ANTLR start synpred13_belle_sip_message
static void synpred13_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1577:14: ( DIGIT )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1577:15: DIGIT
    {
         MATCHT(DIGIT, &FOLLOW_DIGIT_in_synpred13_belle_sip_message7661); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred13_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred13_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred13_belle_sip_messageEx: ;

}
// $ANTLR end synpred13_belle_sip_message

// $ANTLR start synpred14_belle_sip_message
static void synpred14_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1579:13: ( DIGIT DIGIT )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1579:14: DIGIT DIGIT
    {
         MATCHT(DIGIT, &FOLLOW_DIGIT_in_synpred14_belle_sip_message7697); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred14_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(DIGIT, &FOLLOW_DIGIT_in_synpred14_belle_sip_message7699); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred14_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred14_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred14_belle_sip_messageEx: ;

}
// $ANTLR end synpred14_belle_sip_message

// $ANTLR start synpred15_belle_sip_message
static void synpred15_belle_sip_message_fragment(pbelle_sip_messageParser ctx ) 
{
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1581:13: ( DIGIT DIGIT DIGIT )
    // /Users/macbookair/linphone-android/submodules/belle-sip/src/grammars/belle_sip_message.g:1581:14: DIGIT DIGIT DIGIT
    {
         MATCHT(DIGIT, &FOLLOW_DIGIT_in_synpred15_belle_sip_message7739); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred15_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(DIGIT, &FOLLOW_DIGIT_in_synpred15_belle_sip_message7741); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred15_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }
         MATCHT(DIGIT, &FOLLOW_DIGIT_in_synpred15_belle_sip_message7743); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred15_belle_sip_messageEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred15_belle_sip_messageEx; /* Prevent compiler warnings */
rulesynpred15_belle_sip_messageEx: ;

}
// $ANTLR end synpred15_belle_sip_message
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred13_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred13_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred8_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred8_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred9_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred9_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred14_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred14_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred6_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred6_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred3_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred3_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred11_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred11_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred4_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred4_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred12_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred12_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred10_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred10_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred15_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred15_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred7_belle_sip_message(pbelle_sip_messageParser ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred7_belle_sip_message_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
